/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/server-services-core-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_CheckpointService": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_CheckpointService = requireAssignableTo<TypeOnly<old.CheckpointService>, TypeOnly<current.CheckpointService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_CheckpointService": {"backCompat": false}
 */
declare type current_as_old_for_Class_CheckpointService = requireAssignableTo<TypeOnly<current.CheckpointService>, TypeOnly<old.CheckpointService>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_CombinedContext": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_CombinedContext = requireAssignableTo<TypeOnly<old.CombinedContext>, TypeOnly<current.CombinedContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_CombinedContext": {"backCompat": false}
 */
declare type current_as_old_for_Class_CombinedContext = requireAssignableTo<TypeOnly<current.CombinedContext>, TypeOnly<old.CombinedContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_CombinedLambda": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_CombinedLambda = requireAssignableTo<TypeOnly<old.CombinedLambda>, TypeOnly<current.CombinedLambda>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_CombinedLambda": {"backCompat": false}
 */
declare type current_as_old_for_Class_CombinedLambda = requireAssignableTo<TypeOnly<current.CombinedLambda>, TypeOnly<old.CombinedLambda>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_CombinedProducer": {"forwardCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type old_as_current_for_Class_CombinedProducer = requireAssignableTo<TypeOnly<old.CombinedProducer>, TypeOnly<current.CombinedProducer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_CombinedProducer": {"backCompat": false}
 */
declare type current_as_old_for_Class_CombinedProducer = requireAssignableTo<TypeOnly<current.CombinedProducer>, TypeOnly<old.CombinedProducer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DefaultMetricClient": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_DefaultMetricClient = requireAssignableTo<TypeOnly<old.DefaultMetricClient>, TypeOnly<current.DefaultMetricClient>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DefaultMetricClient": {"backCompat": false}
 */
declare type current_as_old_for_Class_DefaultMetricClient = requireAssignableTo<TypeOnly<current.DefaultMetricClient>, TypeOnly<old.DefaultMetricClient>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_EmptyTaskMessageSender": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_EmptyTaskMessageSender = requireAssignableTo<TypeOnly<old.EmptyTaskMessageSender>, TypeOnly<current.EmptyTaskMessageSender>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_EmptyTaskMessageSender": {"backCompat": false}
 */
declare type current_as_old_for_Class_EmptyTaskMessageSender = requireAssignableTo<TypeOnly<current.EmptyTaskMessageSender>, TypeOnly<old.EmptyTaskMessageSender>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MongoCheckpointRepository": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_MongoCheckpointRepository = requireAssignableTo<TypeOnly<old.MongoCheckpointRepository>, TypeOnly<current.MongoCheckpointRepository>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MongoCheckpointRepository": {"backCompat": false}
 */
declare type current_as_old_for_Class_MongoCheckpointRepository = requireAssignableTo<TypeOnly<current.MongoCheckpointRepository>, TypeOnly<old.MongoCheckpointRepository>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MongoDatabaseManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_MongoDatabaseManager = requireAssignableTo<TypeOnly<old.MongoDatabaseManager>, TypeOnly<current.MongoDatabaseManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MongoDatabaseManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_MongoDatabaseManager = requireAssignableTo<TypeOnly<current.MongoDatabaseManager>, TypeOnly<old.MongoDatabaseManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MongoDocumentRepository": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_MongoDocumentRepository = requireAssignableTo<TypeOnly<old.MongoDocumentRepository>, TypeOnly<current.MongoDocumentRepository>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MongoDocumentRepository": {"backCompat": false}
 */
declare type current_as_old_for_Class_MongoDocumentRepository = requireAssignableTo<TypeOnly<current.MongoDocumentRepository>, TypeOnly<old.MongoDocumentRepository>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MongoManager": {"forwardCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type old_as_current_for_Class_MongoManager = requireAssignableTo<TypeOnly<old.MongoManager>, TypeOnly<current.MongoManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MongoManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_MongoManager = requireAssignableTo<TypeOnly<current.MongoManager>, TypeOnly<old.MongoManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_PendingBoxcar": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_PendingBoxcar = requireAssignableTo<TypeOnly<old.PendingBoxcar>, TypeOnly<current.PendingBoxcar>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_PendingBoxcar": {"backCompat": false}
 */
declare type current_as_old_for_Class_PendingBoxcar = requireAssignableTo<TypeOnly<current.PendingBoxcar>, TypeOnly<old.PendingBoxcar>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ThrottlingError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_ThrottlingError = requireAssignableTo<TypeOnly<old.ThrottlingError>, TypeOnly<current.ThrottlingError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ThrottlingError": {"backCompat": false}
 */
declare type current_as_old_for_Class_ThrottlingError = requireAssignableTo<TypeOnly<current.ThrottlingError>, TypeOnly<old.ThrottlingError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TokenRevocationError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TokenRevocationError = requireAssignableTo<TypeOnly<old.TokenRevocationError>, TypeOnly<current.TokenRevocationError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TokenRevocationError": {"backCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type current_as_old_for_Class_TokenRevocationError = requireAssignableTo<TypeOnly<current.TokenRevocationError>, TypeOnly<old.TokenRevocationError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TokenRevokedError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TokenRevokedError = requireAssignableTo<TypeOnly<old.TokenRevokedError>, TypeOnly<current.TokenRevokedError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TokenRevokedError": {"backCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type current_as_old_for_Class_TokenRevokedError = requireAssignableTo<TypeOnly<current.TokenRevokedError>, TypeOnly<old.TokenRevokedError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_CheckpointService": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_CheckpointService = requireAssignableTo<TypeOnly<typeof current.CheckpointService>, TypeOnly<typeof old.CheckpointService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_CombinedContext": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_CombinedContext = requireAssignableTo<TypeOnly<typeof current.CombinedContext>, TypeOnly<typeof old.CombinedContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_CombinedLambda": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_CombinedLambda = requireAssignableTo<TypeOnly<typeof current.CombinedLambda>, TypeOnly<typeof old.CombinedLambda>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_CombinedProducer": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_CombinedProducer = requireAssignableTo<TypeOnly<typeof current.CombinedProducer>, TypeOnly<typeof old.CombinedProducer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DefaultMetricClient": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DefaultMetricClient = requireAssignableTo<TypeOnly<typeof current.DefaultMetricClient>, TypeOnly<typeof old.DefaultMetricClient>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_EmptyTaskMessageSender": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_EmptyTaskMessageSender = requireAssignableTo<TypeOnly<typeof current.EmptyTaskMessageSender>, TypeOnly<typeof old.EmptyTaskMessageSender>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_MongoCheckpointRepository": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_MongoCheckpointRepository = requireAssignableTo<TypeOnly<typeof current.MongoCheckpointRepository>, TypeOnly<typeof old.MongoCheckpointRepository>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_MongoDatabaseManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_MongoDatabaseManager = requireAssignableTo<TypeOnly<typeof current.MongoDatabaseManager>, TypeOnly<typeof old.MongoDatabaseManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_MongoDocumentRepository": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_MongoDocumentRepository = requireAssignableTo<TypeOnly<typeof current.MongoDocumentRepository>, TypeOnly<typeof old.MongoDocumentRepository>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_MongoManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_MongoManager = requireAssignableTo<TypeOnly<typeof current.MongoManager>, TypeOnly<typeof old.MongoManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_PendingBoxcar": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_PendingBoxcar = requireAssignableTo<TypeOnly<typeof current.PendingBoxcar>, TypeOnly<typeof old.PendingBoxcar>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ThrottlingError": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ThrottlingError = requireAssignableTo<TypeOnly<typeof current.ThrottlingError>, TypeOnly<typeof old.ThrottlingError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TokenRevocationError": {"backCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type current_as_old_for_ClassStatics_TokenRevocationError = requireAssignableTo<TypeOnly<typeof current.TokenRevocationError>, TypeOnly<typeof old.TokenRevocationError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TokenRevokedError": {"backCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type current_as_old_for_ClassStatics_TokenRevokedError = requireAssignableTo<TypeOnly<typeof current.TokenRevokedError>, TypeOnly<typeof old.TokenRevokedError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_ControlMessageType": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_ControlMessageType = requireAssignableTo<TypeOnly<old.ControlMessageType>, TypeOnly<current.ControlMessageType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_ControlMessageType": {"backCompat": false}
 */
declare type current_as_old_for_Enum_ControlMessageType = requireAssignableTo<TypeOnly<current.ControlMessageType>, TypeOnly<old.ControlMessageType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_EncryptionKeyVersion": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_EncryptionKeyVersion = requireAssignableTo<TypeOnly<old.EncryptionKeyVersion>, TypeOnly<current.EncryptionKeyVersion>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_EncryptionKeyVersion": {"backCompat": false}
 */
declare type current_as_old_for_Enum_EncryptionKeyVersion = requireAssignableTo<TypeOnly<current.EncryptionKeyVersion>, TypeOnly<old.EncryptionKeyVersion>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_KeyName": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_KeyName = requireAssignableTo<TypeOnly<old.KeyName>, TypeOnly<current.KeyName>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_KeyName": {"backCompat": false}
 */
declare type current_as_old_for_Enum_KeyName = requireAssignableTo<TypeOnly<current.KeyName>, TypeOnly<old.KeyName>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_LambdaCloseType": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_LambdaCloseType = requireAssignableTo<TypeOnly<old.LambdaCloseType>, TypeOnly<current.LambdaCloseType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_LambdaCloseType": {"backCompat": false}
 */
declare type current_as_old_for_Enum_LambdaCloseType = requireAssignableTo<TypeOnly<current.LambdaCloseType>, TypeOnly<old.LambdaCloseType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_LambdaName": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_LambdaName = requireAssignableTo<TypeOnly<old.LambdaName>, TypeOnly<current.LambdaName>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_LambdaName": {"backCompat": false}
 */
declare type current_as_old_for_Enum_LambdaName = requireAssignableTo<TypeOnly<current.LambdaName>, TypeOnly<old.LambdaName>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_NackMessagesType": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_NackMessagesType = requireAssignableTo<TypeOnly<old.NackMessagesType>, TypeOnly<current.NackMessagesType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_NackMessagesType": {"backCompat": false}
 */
declare type current_as_old_for_Enum_NackMessagesType = requireAssignableTo<TypeOnly<current.NackMessagesType>, TypeOnly<old.NackMessagesType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_SystemOperations": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_SystemOperations = requireAssignableTo<TypeOnly<old.SystemOperations>, TypeOnly<current.SystemOperations>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_SystemOperations": {"backCompat": false}
 */
declare type current_as_old_for_Enum_SystemOperations = requireAssignableTo<TypeOnly<current.SystemOperations>, TypeOnly<old.SystemOperations>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_calculateRetryIntervalForNetworkError": {"backCompat": false}
 */
declare type current_as_old_for_Function_calculateRetryIntervalForNetworkError = requireAssignableTo<TypeOnly<typeof current.calculateRetryIntervalForNetworkError>, TypeOnly<typeof old.calculateRetryIntervalForNetworkError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createCompositeTokenId": {"backCompat": false}
 */
declare type current_as_old_for_Function_createCompositeTokenId = requireAssignableTo<TypeOnly<typeof current.createCompositeTokenId>, TypeOnly<typeof old.createCompositeTokenId>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_extractBoxcar": {"backCompat": false}
 */
declare type current_as_old_for_Function_extractBoxcar = requireAssignableTo<TypeOnly<typeof current.extractBoxcar>, TypeOnly<typeof old.extractBoxcar>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_isRetryEnabled": {"backCompat": false}
 */
declare type current_as_old_for_Function_isRetryEnabled = requireAssignableTo<TypeOnly<typeof current.isRetryEnabled>, TypeOnly<typeof old.isRetryEnabled>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_requestWithRetry": {"backCompat": false}
 */
declare type current_as_old_for_Function_requestWithRetry = requireAssignableTo<TypeOnly<typeof current.requestWithRetry>, TypeOnly<typeof old.requestWithRetry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_runWithRetry": {"backCompat": false}
 */
declare type current_as_old_for_Function_runWithRetry = requireAssignableTo<TypeOnly<typeof current.runWithRetry>, TypeOnly<typeof old.runWithRetry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_shouldRetryNetworkError": {"backCompat": false}
 */
declare type current_as_old_for_Function_shouldRetryNetworkError = requireAssignableTo<TypeOnly<typeof current.shouldRetryNetworkError>, TypeOnly<typeof old.shouldRetryNetworkError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAgent": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IAgent = requireAssignableTo<TypeOnly<old.IAgent>, TypeOnly<current.IAgent>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAgent": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IAgent = requireAssignableTo<TypeOnly<current.IAgent>, TypeOnly<old.IAgent>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAgentUploader": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IAgentUploader = requireAssignableTo<TypeOnly<old.IAgentUploader>, TypeOnly<current.IAgentUploader>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAgentUploader": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IAgentUploader = requireAssignableTo<TypeOnly<current.IAgentUploader>, TypeOnly<old.IAgentUploader>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IBoxcarMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IBoxcarMessage = requireAssignableTo<TypeOnly<old.IBoxcarMessage>, TypeOnly<current.IBoxcarMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IBoxcarMessage": {"backCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type current_as_old_for_Interface_IBoxcarMessage = requireAssignableTo<TypeOnly<current.IBoxcarMessage>, TypeOnly<old.IBoxcarMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IBroadcasterServerConfiguration": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IBroadcasterServerConfiguration = requireAssignableTo<TypeOnly<old.IBroadcasterServerConfiguration>, TypeOnly<current.IBroadcasterServerConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IBroadcasterServerConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IBroadcasterServerConfiguration = requireAssignableTo<TypeOnly<current.IBroadcasterServerConfiguration>, TypeOnly<old.IBroadcasterServerConfiguration>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICache": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ICache = requireAssignableTo<TypeOnly<old.ICache>, TypeOnly<current.ICache>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICache": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ICache = requireAssignableTo<TypeOnly<current.ICache>, TypeOnly<old.ICache>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICheckpoint": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ICheckpoint = requireAssignableTo<TypeOnly<old.ICheckpoint>, TypeOnly<current.ICheckpoint>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICheckpoint": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ICheckpoint = requireAssignableTo<TypeOnly<current.ICheckpoint>, TypeOnly<old.ICheckpoint>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICheckpointHeuristicsServerConfiguration": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ICheckpointHeuristicsServerConfiguration = requireAssignableTo<TypeOnly<old.ICheckpointHeuristicsServerConfiguration>, TypeOnly<current.ICheckpointHeuristicsServerConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICheckpointHeuristicsServerConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ICheckpointHeuristicsServerConfiguration = requireAssignableTo<TypeOnly<current.ICheckpointHeuristicsServerConfiguration>, TypeOnly<old.ICheckpointHeuristicsServerConfiguration>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICheckpointRepository": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ICheckpointRepository = requireAssignableTo<TypeOnly<old.ICheckpointRepository>, TypeOnly<current.ICheckpointRepository>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICheckpointRepository": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ICheckpointRepository = requireAssignableTo<TypeOnly<current.ICheckpointRepository>, TypeOnly<old.ICheckpointRepository>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICheckpointService": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ICheckpointService = requireAssignableTo<TypeOnly<old.ICheckpointService>, TypeOnly<current.ICheckpointService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICheckpointService": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ICheckpointService = requireAssignableTo<TypeOnly<current.ICheckpointService>, TypeOnly<old.ICheckpointService>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IClientManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IClientManager = requireAssignableTo<TypeOnly<old.IClientManager>, TypeOnly<current.IClientManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IClientManager": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IClientManager = requireAssignableTo<TypeOnly<current.IClientManager>, TypeOnly<old.IClientManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IClientSequenceNumber": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IClientSequenceNumber = requireAssignableTo<TypeOnly<old.IClientSequenceNumber>, TypeOnly<current.IClientSequenceNumber>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IClientSequenceNumber": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IClientSequenceNumber = requireAssignableTo<TypeOnly<current.IClientSequenceNumber>, TypeOnly<old.IClientSequenceNumber>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IClusterDrainingChecker": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IClusterDrainingChecker = requireAssignableTo<TypeOnly<old.IClusterDrainingChecker>, TypeOnly<current.IClusterDrainingChecker>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IClusterDrainingChecker": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IClusterDrainingChecker = requireAssignableTo<TypeOnly<current.IClusterDrainingChecker>, TypeOnly<old.IClusterDrainingChecker>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICollection": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ICollection = requireAssignableTo<TypeOnly<old.ICollection<never>>, TypeOnly<current.ICollection<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICollection": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ICollection = requireAssignableTo<TypeOnly<current.ICollection<never>>, TypeOnly<old.ICollection<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConsumer": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IConsumer = requireAssignableTo<TypeOnly<old.IConsumer>, TypeOnly<current.IConsumer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConsumer": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IConsumer = requireAssignableTo<TypeOnly<current.IConsumer>, TypeOnly<old.IConsumer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IContext": {"forwardCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type old_as_current_for_Interface_IContext = requireAssignableTo<TypeOnly<old.IContext>, TypeOnly<current.IContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IContext": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IContext = requireAssignableTo<TypeOnly<current.IContext>, TypeOnly<old.IContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IContextErrorData": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IContextErrorData = requireAssignableTo<TypeOnly<old.IContextErrorData>, TypeOnly<current.IContextErrorData>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IContextErrorData": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IContextErrorData = requireAssignableTo<TypeOnly<current.IContextErrorData>, TypeOnly<old.IContextErrorData>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IControlMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IControlMessage = requireAssignableTo<TypeOnly<old.IControlMessage>, TypeOnly<current.IControlMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IControlMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IControlMessage = requireAssignableTo<TypeOnly<current.IControlMessage>, TypeOnly<old.IControlMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDatabaseManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDatabaseManager = requireAssignableTo<TypeOnly<old.IDatabaseManager>, TypeOnly<current.IDatabaseManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDatabaseManager": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDatabaseManager = requireAssignableTo<TypeOnly<current.IDatabaseManager>, TypeOnly<old.IDatabaseManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDb": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDb = requireAssignableTo<TypeOnly<old.IDb>, TypeOnly<current.IDb>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDb": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDb = requireAssignableTo<TypeOnly<current.IDb>, TypeOnly<old.IDb>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDbFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDbFactory = requireAssignableTo<TypeOnly<old.IDbFactory>, TypeOnly<current.IDbFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDbFactory": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDbFactory = requireAssignableTo<TypeOnly<current.IDbFactory>, TypeOnly<old.IDbFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDeliOpEventServerConfiguration": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDeliOpEventServerConfiguration = requireAssignableTo<TypeOnly<old.IDeliOpEventServerConfiguration>, TypeOnly<current.IDeliOpEventServerConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDeliOpEventServerConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDeliOpEventServerConfiguration = requireAssignableTo<TypeOnly<current.IDeliOpEventServerConfiguration>, TypeOnly<old.IDeliOpEventServerConfiguration>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDeliServerConfiguration": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDeliServerConfiguration = requireAssignableTo<TypeOnly<old.IDeliServerConfiguration>, TypeOnly<current.IDeliServerConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDeliServerConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDeliServerConfiguration = requireAssignableTo<TypeOnly<current.IDeliServerConfiguration>, TypeOnly<old.IDeliServerConfiguration>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDeliState": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDeliState = requireAssignableTo<TypeOnly<old.IDeliState>, TypeOnly<current.IDeliState>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDeliState": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDeliState = requireAssignableTo<TypeOnly<current.IDeliState>, TypeOnly<old.IDeliState>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDeliSummaryNackMessagesServerConfiguration": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDeliSummaryNackMessagesServerConfiguration = requireAssignableTo<TypeOnly<old.IDeliSummaryNackMessagesServerConfiguration>, TypeOnly<current.IDeliSummaryNackMessagesServerConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDeliSummaryNackMessagesServerConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDeliSummaryNackMessagesServerConfiguration = requireAssignableTo<TypeOnly<current.IDeliSummaryNackMessagesServerConfiguration>, TypeOnly<old.IDeliSummaryNackMessagesServerConfiguration>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDeltaService": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDeltaService = requireAssignableTo<TypeOnly<old.IDeltaService>, TypeOnly<current.IDeltaService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDeltaService": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDeltaService = requireAssignableTo<TypeOnly<current.IDeltaService>, TypeOnly<old.IDeltaService>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDisableNackMessagesControlMessageContents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDisableNackMessagesControlMessageContents = requireAssignableTo<TypeOnly<old.IDisableNackMessagesControlMessageContents>, TypeOnly<current.IDisableNackMessagesControlMessageContents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDisableNackMessagesControlMessageContents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDisableNackMessagesControlMessageContents = requireAssignableTo<TypeOnly<current.IDisableNackMessagesControlMessageContents>, TypeOnly<old.IDisableNackMessagesControlMessageContents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocument": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDocument = requireAssignableTo<TypeOnly<old.IDocument>, TypeOnly<current.IDocument>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocument": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDocument = requireAssignableTo<TypeOnly<current.IDocument>, TypeOnly<old.IDocument>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentDetails": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDocumentDetails = requireAssignableTo<TypeOnly<old.IDocumentDetails>, TypeOnly<current.IDocumentDetails>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentDetails": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDocumentDetails = requireAssignableTo<TypeOnly<current.IDocumentDetails>, TypeOnly<old.IDocumentDetails>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentLambdaServerConfiguration": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDocumentLambdaServerConfiguration = requireAssignableTo<TypeOnly<old.IDocumentLambdaServerConfiguration>, TypeOnly<current.IDocumentLambdaServerConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentLambdaServerConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDocumentLambdaServerConfiguration = requireAssignableTo<TypeOnly<current.IDocumentLambdaServerConfiguration>, TypeOnly<old.IDocumentLambdaServerConfiguration>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDocumentManager = requireAssignableTo<TypeOnly<old.IDocumentManager>, TypeOnly<current.IDocumentManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentManager": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDocumentManager = requireAssignableTo<TypeOnly<current.IDocumentManager>, TypeOnly<old.IDocumentManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentRepository": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDocumentRepository = requireAssignableTo<TypeOnly<old.IDocumentRepository>, TypeOnly<current.IDocumentRepository>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentRepository": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDocumentRepository = requireAssignableTo<TypeOnly<current.IDocumentRepository>, TypeOnly<old.IDocumentRepository>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentStaticProperties": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDocumentStaticProperties = requireAssignableTo<TypeOnly<old.IDocumentStaticProperties>, TypeOnly<current.IDocumentStaticProperties>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentStaticProperties": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDocumentStaticProperties = requireAssignableTo<TypeOnly<current.IDocumentStaticProperties>, TypeOnly<old.IDocumentStaticProperties>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentStorage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDocumentStorage = requireAssignableTo<TypeOnly<old.IDocumentStorage>, TypeOnly<current.IDocumentStorage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDocumentStorage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDocumentStorage = requireAssignableTo<TypeOnly<current.IDocumentStorage>, TypeOnly<old.IDocumentStorage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IEncryptedTenantKeys": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IEncryptedTenantKeys = requireAssignableTo<TypeOnly<old.IEncryptedTenantKeys>, TypeOnly<current.IEncryptedTenantKeys>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IEncryptedTenantKeys": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IEncryptedTenantKeys = requireAssignableTo<TypeOnly<current.IEncryptedTenantKeys>, TypeOnly<old.IEncryptedTenantKeys>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IExtendClientControlMessageContents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IExtendClientControlMessageContents = requireAssignableTo<TypeOnly<old.IExtendClientControlMessageContents>, TypeOnly<current.IExtendClientControlMessageContents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IExtendClientControlMessageContents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IExtendClientControlMessageContents = requireAssignableTo<TypeOnly<current.IExtendClientControlMessageContents>, TypeOnly<old.IExtendClientControlMessageContents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IHttpServer": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IHttpServer = requireAssignableTo<TypeOnly<old.IHttpServer>, TypeOnly<current.IHttpServer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IHttpServer": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IHttpServer = requireAssignableTo<TypeOnly<current.IHttpServer>, TypeOnly<old.IHttpServer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILambdaStartControlMessageContents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ILambdaStartControlMessageContents = requireAssignableTo<TypeOnly<old.ILambdaStartControlMessageContents>, TypeOnly<current.ILambdaStartControlMessageContents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILambdaStartControlMessageContents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ILambdaStartControlMessageContents = requireAssignableTo<TypeOnly<current.ILambdaStartControlMessageContents>, TypeOnly<old.ILambdaStartControlMessageContents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILogger": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ILogger = requireAssignableTo<TypeOnly<old.ILogger>, TypeOnly<current.ILogger>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILogger": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ILogger = requireAssignableTo<TypeOnly<current.ILogger>, TypeOnly<old.ILogger>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMessage = requireAssignableTo<TypeOnly<old.IMessage>, TypeOnly<current.IMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMessage = requireAssignableTo<TypeOnly<current.IMessage>, TypeOnly<old.IMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMessageBatch": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMessageBatch = requireAssignableTo<TypeOnly<old.IMessageBatch<never>>, TypeOnly<current.IMessageBatch<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMessageBatch": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMessageBatch = requireAssignableTo<TypeOnly<current.IMessageBatch<never>>, TypeOnly<old.IMessageBatch<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMetricClient": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMetricClient = requireAssignableTo<TypeOnly<old.IMetricClient>, TypeOnly<current.IMetricClient>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMetricClient": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMetricClient = requireAssignableTo<TypeOnly<current.IMetricClient>, TypeOnly<old.IMetricClient>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMoiraServerConfiguration": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IMoiraServerConfiguration = requireAssignableTo<TypeOnly<old.IMoiraServerConfiguration>, TypeOnly<current.IMoiraServerConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IMoiraServerConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IMoiraServerConfiguration = requireAssignableTo<TypeOnly<current.IMoiraServerConfiguration>, TypeOnly<old.IMoiraServerConfiguration>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INackMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_INackMessage = requireAssignableTo<TypeOnly<old.INackMessage>, TypeOnly<current.INackMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INackMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_INackMessage = requireAssignableTo<TypeOnly<current.INackMessage>, TypeOnly<old.INackMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INackMessagesControlMessageContents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_INackMessagesControlMessageContents = requireAssignableTo<TypeOnly<old.INackMessagesControlMessageContents>, TypeOnly<current.INackMessagesControlMessageContents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INackMessagesControlMessageContents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_INackMessagesControlMessageContents = requireAssignableTo<TypeOnly<current.INackMessagesControlMessageContents>, TypeOnly<old.INackMessagesControlMessageContents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INode": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_INode = requireAssignableTo<TypeOnly<old.INode>, TypeOnly<current.INode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INode": {"backCompat": false}
 */
declare type current_as_old_for_Interface_INode = requireAssignableTo<TypeOnly<current.INode>, TypeOnly<old.INode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IObjectMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IObjectMessage = requireAssignableTo<TypeOnly<old.IObjectMessage>, TypeOnly<current.IObjectMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IObjectMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IObjectMessage = requireAssignableTo<TypeOnly<current.IObjectMessage>, TypeOnly<old.IObjectMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IOrderer": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IOrderer = requireAssignableTo<TypeOnly<old.IOrderer>, TypeOnly<current.IOrderer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IOrderer": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IOrderer = requireAssignableTo<TypeOnly<current.IOrderer>, TypeOnly<old.IOrderer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IOrdererConnection": {"forwardCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type old_as_current_for_Interface_IOrdererConnection = requireAssignableTo<TypeOnly<old.IOrdererConnection>, TypeOnly<current.IOrdererConnection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IOrdererConnection": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IOrdererConnection = requireAssignableTo<TypeOnly<current.IOrdererConnection>, TypeOnly<old.IOrdererConnection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IOrdererManager": {"forwardCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type old_as_current_for_Interface_IOrdererManager = requireAssignableTo<TypeOnly<old.IOrdererManager>, TypeOnly<current.IOrdererManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IOrdererManager": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IOrdererManager = requireAssignableTo<TypeOnly<current.IOrdererManager>, TypeOnly<old.IOrdererManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IOrdererSocket": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IOrdererSocket = requireAssignableTo<TypeOnly<old.IOrdererSocket>, TypeOnly<current.IOrdererSocket>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IOrdererSocket": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IOrdererSocket = requireAssignableTo<TypeOnly<current.IOrdererSocket>, TypeOnly<old.IOrdererSocket>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPartition": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IPartition = requireAssignableTo<TypeOnly<old.IPartition>, TypeOnly<current.IPartition>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPartition": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IPartition = requireAssignableTo<TypeOnly<current.IPartition>, TypeOnly<old.IPartition>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPartitionLambda": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IPartitionLambda = requireAssignableTo<TypeOnly<old.IPartitionLambda>, TypeOnly<current.IPartitionLambda>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPartitionLambda": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IPartitionLambda = requireAssignableTo<TypeOnly<current.IPartitionLambda>, TypeOnly<old.IPartitionLambda>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPartitionLambdaConfig": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IPartitionLambdaConfig = requireAssignableTo<TypeOnly<old.IPartitionLambdaConfig>, TypeOnly<current.IPartitionLambdaConfig>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPartitionLambdaConfig": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IPartitionLambdaConfig = requireAssignableTo<TypeOnly<current.IPartitionLambdaConfig>, TypeOnly<old.IPartitionLambdaConfig>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPartitionLambdaFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IPartitionLambdaFactory = requireAssignableTo<TypeOnly<old.IPartitionLambdaFactory>, TypeOnly<current.IPartitionLambdaFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPartitionLambdaFactory": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IPartitionLambdaFactory = requireAssignableTo<TypeOnly<current.IPartitionLambdaFactory>, TypeOnly<old.IPartitionLambdaFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPartitionLambdaPlugin": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IPartitionLambdaPlugin = requireAssignableTo<TypeOnly<old.IPartitionLambdaPlugin>, TypeOnly<current.IPartitionLambdaPlugin>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPartitionLambdaPlugin": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IPartitionLambdaPlugin = requireAssignableTo<TypeOnly<current.IPartitionLambdaPlugin>, TypeOnly<old.IPartitionLambdaPlugin>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPendingBoxcar": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IPendingBoxcar = requireAssignableTo<TypeOnly<old.IPendingBoxcar>, TypeOnly<current.IPendingBoxcar>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPendingBoxcar": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IPendingBoxcar = requireAssignableTo<TypeOnly<current.IPendingBoxcar>, TypeOnly<old.IPendingBoxcar>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPendingMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IPendingMessage = requireAssignableTo<TypeOnly<old.IPendingMessage>, TypeOnly<current.IPendingMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPendingMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IPendingMessage = requireAssignableTo<TypeOnly<current.IPendingMessage>, TypeOnly<old.IPendingMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProducer": {"forwardCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type old_as_current_for_Interface_IProducer = requireAssignableTo<TypeOnly<old.IProducer>, TypeOnly<current.IProducer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IProducer": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IProducer = requireAssignableTo<TypeOnly<current.IProducer>, TypeOnly<old.IProducer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPublisher": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IPublisher = requireAssignableTo<TypeOnly<old.IPublisher>, TypeOnly<current.IPublisher>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPublisher": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IPublisher = requireAssignableTo<TypeOnly<current.IPublisher>, TypeOnly<old.IPublisher>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IQueuedMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IQueuedMessage = requireAssignableTo<TypeOnly<old.IQueuedMessage>, TypeOnly<current.IQueuedMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IQueuedMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IQueuedMessage = requireAssignableTo<TypeOnly<current.IQueuedMessage>, TypeOnly<old.IQueuedMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRawOperationMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRawOperationMessage = requireAssignableTo<TypeOnly<old.IRawOperationMessage>, TypeOnly<current.IRawOperationMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRawOperationMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRawOperationMessage = requireAssignableTo<TypeOnly<current.IRawOperationMessage>, TypeOnly<old.IRawOperationMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRawOperationMessageBatch": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRawOperationMessageBatch = requireAssignableTo<TypeOnly<old.IRawOperationMessageBatch>, TypeOnly<current.IRawOperationMessageBatch>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRawOperationMessageBatch": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRawOperationMessageBatch = requireAssignableTo<TypeOnly<current.IRawOperationMessageBatch>, TypeOnly<old.IRawOperationMessageBatch>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IResources": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IResources = requireAssignableTo<TypeOnly<old.IResources>, TypeOnly<current.IResources>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IResources": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IResources = requireAssignableTo<TypeOnly<current.IResources>, TypeOnly<old.IResources>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IResourcesFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IResourcesFactory = requireAssignableTo<TypeOnly<old.IResourcesFactory<never>>, TypeOnly<current.IResourcesFactory<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IResourcesFactory": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IResourcesFactory = requireAssignableTo<TypeOnly<current.IResourcesFactory<never>>, TypeOnly<old.IResourcesFactory<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRetryable": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRetryable = requireAssignableTo<TypeOnly<old.IRetryable>, TypeOnly<current.IRetryable>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRetryable": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRetryable = requireAssignableTo<TypeOnly<current.IRetryable>, TypeOnly<old.IRetryable>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRevokedTokenChecker": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRevokedTokenChecker = requireAssignableTo<TypeOnly<old.IRevokedTokenChecker>, TypeOnly<current.IRevokedTokenChecker>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRevokedTokenChecker": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRevokedTokenChecker = requireAssignableTo<TypeOnly<current.IRevokedTokenChecker>, TypeOnly<old.IRevokedTokenChecker>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRevokeTokenOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRevokeTokenOptions = requireAssignableTo<TypeOnly<old.IRevokeTokenOptions>, TypeOnly<current.IRevokeTokenOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRevokeTokenOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRevokeTokenOptions = requireAssignableTo<TypeOnly<current.IRevokeTokenOptions>, TypeOnly<old.IRevokeTokenOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRoutingKey": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRoutingKey = requireAssignableTo<TypeOnly<old.IRoutingKey>, TypeOnly<current.IRoutingKey>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRoutingKey": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRoutingKey = requireAssignableTo<TypeOnly<current.IRoutingKey>, TypeOnly<old.IRoutingKey>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRunner": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRunner = requireAssignableTo<TypeOnly<old.IRunner>, TypeOnly<current.IRunner>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRunner": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRunner = requireAssignableTo<TypeOnly<current.IRunner>, TypeOnly<old.IRunner>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRunnerFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRunnerFactory = requireAssignableTo<TypeOnly<old.IRunnerFactory<never>>, TypeOnly<current.IRunnerFactory<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRunnerFactory": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRunnerFactory = requireAssignableTo<TypeOnly<current.IRunnerFactory<never>>, TypeOnly<old.IRunnerFactory<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IScribe": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IScribe = requireAssignableTo<TypeOnly<old.IScribe>, TypeOnly<current.IScribe>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IScribe": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IScribe = requireAssignableTo<TypeOnly<current.IScribe>, TypeOnly<old.IScribe>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IScribeServerConfiguration": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IScribeServerConfiguration = requireAssignableTo<TypeOnly<old.IScribeServerConfiguration>, TypeOnly<current.IScribeServerConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IScribeServerConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IScribeServerConfiguration = requireAssignableTo<TypeOnly<current.IScribeServerConfiguration>, TypeOnly<old.IScribeServerConfiguration>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISecretManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISecretManager = requireAssignableTo<TypeOnly<old.ISecretManager>, TypeOnly<current.ISecretManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISecretManager": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISecretManager = requireAssignableTo<TypeOnly<current.ISecretManager>, TypeOnly<old.ISecretManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISequencedOperationMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISequencedOperationMessage = requireAssignableTo<TypeOnly<old.ISequencedOperationMessage>, TypeOnly<current.ISequencedOperationMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISequencedOperationMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISequencedOperationMessage = requireAssignableTo<TypeOnly<current.ISequencedOperationMessage>, TypeOnly<old.ISequencedOperationMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISequencedSignalClient": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISequencedSignalClient = requireAssignableTo<TypeOnly<old.ISequencedSignalClient>, TypeOnly<current.ISequencedSignalClient>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISequencedSignalClient": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISequencedSignalClient = requireAssignableTo<TypeOnly<current.ISequencedSignalClient>, TypeOnly<old.ISequencedSignalClient>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IServerConfiguration": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IServerConfiguration = requireAssignableTo<TypeOnly<old.IServerConfiguration>, TypeOnly<current.IServerConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IServerConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IServerConfiguration = requireAssignableTo<TypeOnly<current.IServerConfiguration>, TypeOnly<old.IServerConfiguration>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IServiceConfiguration": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IServiceConfiguration = requireAssignableTo<TypeOnly<old.IServiceConfiguration>, TypeOnly<current.IServiceConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IServiceConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IServiceConfiguration = requireAssignableTo<TypeOnly<current.IServiceConfiguration>, TypeOnly<old.IServiceConfiguration>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IServiceMessageResourceManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IServiceMessageResourceManager = requireAssignableTo<TypeOnly<old.IServiceMessageResourceManager>, TypeOnly<current.IServiceMessageResourceManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IServiceMessageResourceManager": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IServiceMessageResourceManager = requireAssignableTo<TypeOnly<current.IServiceMessageResourceManager>, TypeOnly<old.IServiceMessageResourceManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IStorageNameAllocator": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IStorageNameAllocator = requireAssignableTo<TypeOnly<old.IStorageNameAllocator>, TypeOnly<current.IStorageNameAllocator>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IStorageNameAllocator": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IStorageNameAllocator = requireAssignableTo<TypeOnly<current.IStorageNameAllocator>, TypeOnly<old.IStorageNameAllocator>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IStorageNameRetriever": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IStorageNameRetriever = requireAssignableTo<TypeOnly<old.IStorageNameRetriever>, TypeOnly<current.IStorageNameRetriever>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IStorageNameRetriever": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IStorageNameRetriever = requireAssignableTo<TypeOnly<current.IStorageNameRetriever>, TypeOnly<old.IStorageNameRetriever>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISystemMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISystemMessage = requireAssignableTo<TypeOnly<old.ISystemMessage>, TypeOnly<current.ISystemMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISystemMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISystemMessage = requireAssignableTo<TypeOnly<current.ISystemMessage>, TypeOnly<old.ISystemMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITaskMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITaskMessage = requireAssignableTo<TypeOnly<old.ITaskMessage>, TypeOnly<current.ITaskMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITaskMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITaskMessage = requireAssignableTo<TypeOnly<current.ITaskMessage>, TypeOnly<old.ITaskMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITaskMessageReceiver": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITaskMessageReceiver = requireAssignableTo<TypeOnly<old.ITaskMessageReceiver>, TypeOnly<current.ITaskMessageReceiver>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITaskMessageReceiver": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITaskMessageReceiver = requireAssignableTo<TypeOnly<current.ITaskMessageReceiver>, TypeOnly<old.ITaskMessageReceiver>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITaskMessageSender": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITaskMessageSender = requireAssignableTo<TypeOnly<old.ITaskMessageSender>, TypeOnly<current.ITaskMessageSender>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITaskMessageSender": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITaskMessageSender = requireAssignableTo<TypeOnly<current.ITaskMessageSender>, TypeOnly<old.ITaskMessageSender>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITenant": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITenant = requireAssignableTo<TypeOnly<old.ITenant>, TypeOnly<current.ITenant>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITenant": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITenant = requireAssignableTo<TypeOnly<current.ITenant>, TypeOnly<old.ITenant>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITenantConfig": {"forwardCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type old_as_current_for_Interface_ITenantConfig = requireAssignableTo<TypeOnly<old.ITenantConfig>, TypeOnly<current.ITenantConfig>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITenantConfig": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITenantConfig = requireAssignableTo<TypeOnly<current.ITenantConfig>, TypeOnly<old.ITenantConfig>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITenantConfigManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITenantConfigManager = requireAssignableTo<TypeOnly<old.ITenantConfigManager>, TypeOnly<current.ITenantConfigManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITenantConfigManager": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITenantConfigManager = requireAssignableTo<TypeOnly<current.ITenantConfigManager>, TypeOnly<old.ITenantConfigManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITenantCustomData": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITenantCustomData = requireAssignableTo<TypeOnly<old.ITenantCustomData>, TypeOnly<current.ITenantCustomData>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITenantCustomData": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITenantCustomData = requireAssignableTo<TypeOnly<current.ITenantCustomData>, TypeOnly<old.ITenantCustomData>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITenantKeys": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITenantKeys = requireAssignableTo<TypeOnly<old.ITenantKeys>, TypeOnly<current.ITenantKeys>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITenantKeys": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITenantKeys = requireAssignableTo<TypeOnly<current.ITenantKeys>, TypeOnly<old.ITenantKeys>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITenantManager": {"forwardCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type old_as_current_for_Interface_ITenantManager = requireAssignableTo<TypeOnly<old.ITenantManager>, TypeOnly<current.ITenantManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITenantManager": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITenantManager = requireAssignableTo<TypeOnly<current.ITenantManager>, TypeOnly<old.ITenantManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITenantOrderer": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITenantOrderer = requireAssignableTo<TypeOnly<old.ITenantOrderer>, TypeOnly<current.ITenantOrderer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITenantOrderer": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITenantOrderer = requireAssignableTo<TypeOnly<current.ITenantOrderer>, TypeOnly<old.ITenantOrderer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITenantStorage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITenantStorage = requireAssignableTo<TypeOnly<old.ITenantStorage>, TypeOnly<current.ITenantStorage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITenantStorage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITenantStorage = requireAssignableTo<TypeOnly<current.ITenantStorage>, TypeOnly<old.ITenantStorage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IThrottleAndUsageStorageManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IThrottleAndUsageStorageManager = requireAssignableTo<TypeOnly<old.IThrottleAndUsageStorageManager>, TypeOnly<current.IThrottleAndUsageStorageManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IThrottleAndUsageStorageManager": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IThrottleAndUsageStorageManager = requireAssignableTo<TypeOnly<current.IThrottleAndUsageStorageManager>, TypeOnly<old.IThrottleAndUsageStorageManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IThrottler": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IThrottler = requireAssignableTo<TypeOnly<old.IThrottler>, TypeOnly<current.IThrottler>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IThrottler": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IThrottler = requireAssignableTo<TypeOnly<current.IThrottler>, TypeOnly<old.IThrottler>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IThrottlerHelper": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IThrottlerHelper = requireAssignableTo<TypeOnly<old.IThrottlerHelper>, TypeOnly<current.IThrottlerHelper>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IThrottlerHelper": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IThrottlerHelper = requireAssignableTo<TypeOnly<current.IThrottlerHelper>, TypeOnly<old.IThrottlerHelper>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IThrottlerResponse": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IThrottlerResponse = requireAssignableTo<TypeOnly<old.IThrottlerResponse>, TypeOnly<current.IThrottlerResponse>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IThrottlerResponse": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IThrottlerResponse = requireAssignableTo<TypeOnly<current.IThrottlerResponse>, TypeOnly<old.IThrottlerResponse>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IThrottlingMetrics": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IThrottlingMetrics = requireAssignableTo<TypeOnly<old.IThrottlingMetrics>, TypeOnly<current.IThrottlingMetrics>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IThrottlingMetrics": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IThrottlingMetrics = requireAssignableTo<TypeOnly<current.IThrottlingMetrics>, TypeOnly<old.IThrottlingMetrics>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITicketedMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITicketedMessage = requireAssignableTo<TypeOnly<old.ITicketedMessage>, TypeOnly<current.ITicketedMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITicketedMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITicketedMessage = requireAssignableTo<TypeOnly<current.ITicketedMessage>, TypeOnly<old.ITicketedMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITicketedSignalMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITicketedSignalMessage = requireAssignableTo<TypeOnly<old.ITicketedSignalMessage>, TypeOnly<current.ITicketedSignalMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITicketedSignalMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITicketedSignalMessage = requireAssignableTo<TypeOnly<current.ITicketedSignalMessage>, TypeOnly<old.ITicketedSignalMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITokenRevocationManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITokenRevocationManager = requireAssignableTo<TypeOnly<old.ITokenRevocationManager>, TypeOnly<current.ITokenRevocationManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITokenRevocationManager": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITokenRevocationManager = requireAssignableTo<TypeOnly<current.ITokenRevocationManager>, TypeOnly<old.ITokenRevocationManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITokenRevocationResponse": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITokenRevocationResponse = requireAssignableTo<TypeOnly<old.ITokenRevocationResponse>, TypeOnly<current.ITokenRevocationResponse>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITokenRevocationResponse": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITokenRevocationResponse = requireAssignableTo<TypeOnly<current.ITokenRevocationResponse>, TypeOnly<old.ITokenRevocationResponse>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITopic": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITopic = requireAssignableTo<TypeOnly<old.ITopic>, TypeOnly<current.ITopic>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITopic": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITopic = requireAssignableTo<TypeOnly<current.ITopic>, TypeOnly<old.ITopic>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IUpdateDSNControlMessageContents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IUpdateDSNControlMessageContents = requireAssignableTo<TypeOnly<old.IUpdateDSNControlMessageContents>, TypeOnly<current.IUpdateDSNControlMessageContents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IUpdateDSNControlMessageContents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IUpdateDSNControlMessageContents = requireAssignableTo<TypeOnly<current.IUpdateDSNControlMessageContents>, TypeOnly<old.IUpdateDSNControlMessageContents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IUpdateReferenceSequenceNumberMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IUpdateReferenceSequenceNumberMessage = requireAssignableTo<TypeOnly<old.IUpdateReferenceSequenceNumberMessage>, TypeOnly<current.IUpdateReferenceSequenceNumberMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IUpdateReferenceSequenceNumberMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IUpdateReferenceSequenceNumberMessage = requireAssignableTo<TypeOnly<current.IUpdateReferenceSequenceNumberMessage>, TypeOnly<old.IUpdateReferenceSequenceNumberMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IUsageData": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IUsageData = requireAssignableTo<TypeOnly<old.IUsageData>, TypeOnly<current.IUsageData>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IUsageData": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IUsageData = requireAssignableTo<TypeOnly<current.IUsageData>, TypeOnly<old.IUsageData>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWebServer": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IWebServer = requireAssignableTo<TypeOnly<old.IWebServer>, TypeOnly<current.IWebServer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWebServer": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IWebServer = requireAssignableTo<TypeOnly<current.IWebServer>, TypeOnly<old.IWebServer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWebServerFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IWebServerFactory = requireAssignableTo<TypeOnly<old.IWebServerFactory>, TypeOnly<current.IWebServerFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWebServerFactory": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IWebServerFactory = requireAssignableTo<TypeOnly<current.IWebServerFactory>, TypeOnly<old.IWebServerFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWebSocket": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IWebSocket = requireAssignableTo<TypeOnly<old.IWebSocket>, TypeOnly<current.IWebSocket>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWebSocket": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IWebSocket = requireAssignableTo<TypeOnly<current.IWebSocket>, TypeOnly<old.IWebSocket>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWebSocketServer": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IWebSocketServer = requireAssignableTo<TypeOnly<old.IWebSocketServer>, TypeOnly<current.IWebSocketServer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWebSocketServer": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IWebSocketServer = requireAssignableTo<TypeOnly<current.IWebSocketServer>, TypeOnly<old.IWebSocketServer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWebSocketTracker": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IWebSocketTracker = requireAssignableTo<TypeOnly<old.IWebSocketTracker>, TypeOnly<current.IWebSocketTracker>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWebSocketTracker": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IWebSocketTracker = requireAssignableTo<TypeOnly<current.IWebSocketTracker>, TypeOnly<old.IWebSocketTracker>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IZookeeperClient": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IZookeeperClient = requireAssignableTo<TypeOnly<old.IZookeeperClient>, TypeOnly<current.IZookeeperClient>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IZookeeperClient": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IZookeeperClient = requireAssignableTo<TypeOnly<current.IZookeeperClient>, TypeOnly<old.IZookeeperClient>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IDbEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IDbEvents = requireAssignableTo<TypeOnly<old.IDbEvents>, TypeOnly<current.IDbEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IDbEvents": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IDbEvents = requireAssignableTo<TypeOnly<current.IDbEvents>, TypeOnly<old.IDbEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_RequestListener": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_RequestListener = requireAssignableTo<TypeOnly<old.RequestListener>, TypeOnly<current.RequestListener>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_RequestListener": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_RequestListener = requireAssignableTo<TypeOnly<current.RequestListener>, TypeOnly<old.RequestListener>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TokenGenerator": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_TokenGenerator = requireAssignableTo<TypeOnly<old.TokenGenerator>, TypeOnly<current.TokenGenerator>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_TokenGenerator": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_TokenGenerator = requireAssignableTo<TypeOnly<current.TokenGenerator>, TypeOnly<old.TokenGenerator>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ZookeeperClientConstructor": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ZookeeperClientConstructor = requireAssignableTo<TypeOnly<old.ZookeeperClientConstructor>, TypeOnly<current.ZookeeperClientConstructor>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ZookeeperClientConstructor": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ZookeeperClientConstructor = requireAssignableTo<TypeOnly<current.ZookeeperClientConstructor>, TypeOnly<old.ZookeeperClientConstructor>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_BoxcarType": {"backCompat": false}
 */
declare type current_as_old_for_Variable_BoxcarType = requireAssignableTo<TypeOnly<typeof current.BoxcarType>, TypeOnly<typeof old.BoxcarType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_chooseCelaName": {"backCompat": false}
 */
declare type current_as_old_for_Variable_chooseCelaName = requireAssignableTo<TypeOnly<typeof current.chooseCelaName>, TypeOnly<typeof old.chooseCelaName>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_clientConnectivityStorageId": {"backCompat": false}
 */
declare type current_as_old_for_Variable_clientConnectivityStorageId = requireAssignableTo<TypeOnly<typeof current.clientConnectivityStorageId>, TypeOnly<typeof old.clientConnectivityStorageId>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_DefaultServiceConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_Variable_DefaultServiceConfiguration = requireAssignableTo<TypeOnly<typeof current.DefaultServiceConfiguration>, TypeOnly<typeof old.DefaultServiceConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_httpUsageStorageId": {"backCompat": false}
 */
declare type current_as_old_for_Variable_httpUsageStorageId = requireAssignableTo<TypeOnly<typeof current.httpUsageStorageId>, TypeOnly<typeof old.httpUsageStorageId>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_MaxBatchSize": {"backCompat": false}
 */
declare type current_as_old_for_Variable_MaxBatchSize = requireAssignableTo<TypeOnly<typeof current.MaxBatchSize>, TypeOnly<typeof old.MaxBatchSize>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_NackOperationType": {"backCompat": false}
 */
declare type current_as_old_for_Variable_NackOperationType = requireAssignableTo<TypeOnly<typeof current.NackOperationType>, TypeOnly<typeof old.NackOperationType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_RawOperationType": {"backCompat": false}
 */
declare type current_as_old_for_Variable_RawOperationType = requireAssignableTo<TypeOnly<typeof current.RawOperationType>, TypeOnly<typeof old.RawOperationType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_SequencedOperationType": {"backCompat": false}
 */
declare type current_as_old_for_Variable_SequencedOperationType = requireAssignableTo<TypeOnly<typeof current.SequencedOperationType>, TypeOnly<typeof old.SequencedOperationType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_SignalOperationType": {"backCompat": false}
 */
declare type current_as_old_for_Variable_SignalOperationType = requireAssignableTo<TypeOnly<typeof current.SignalOperationType>, TypeOnly<typeof old.SignalOperationType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_signalUsageStorageId": {"backCompat": false}
 */
declare type current_as_old_for_Variable_signalUsageStorageId = requireAssignableTo<TypeOnly<typeof current.signalUsageStorageId>, TypeOnly<typeof old.signalUsageStorageId>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_SystemType": {"backCompat": false}
 */
declare type current_as_old_for_Variable_SystemType = requireAssignableTo<TypeOnly<typeof current.SystemType>, TypeOnly<typeof old.SystemType>>
