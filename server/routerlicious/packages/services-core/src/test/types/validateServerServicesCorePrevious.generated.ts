/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-test-generator in @fluidframework/build-tools.
 */

import type * as old from "@fluidframework/server-services-core-previous";
import type * as current from "../../index.js";


// See 'build-tools/src/type-test-generator/compatibility.ts' for more information.
type TypeOnly<T> = T extends number
	? number
	: T extends string
	? string
	: T extends boolean | bigint | symbol
	? T
	: {
			[P in keyof T]: TypeOnly<T[P]>;
	  };

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_BoxcarType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_BoxcarType():
    TypeOnly<typeof old.BoxcarType>;
declare function use_current_VariableDeclaration_BoxcarType(
    use: TypeOnly<typeof current.BoxcarType>): void;
use_current_VariableDeclaration_BoxcarType(
    get_old_VariableDeclaration_BoxcarType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_BoxcarType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_BoxcarType():
    TypeOnly<typeof current.BoxcarType>;
declare function use_old_VariableDeclaration_BoxcarType(
    use: TypeOnly<typeof old.BoxcarType>): void;
use_old_VariableDeclaration_BoxcarType(
    get_current_VariableDeclaration_BoxcarType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_CheckpointService": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_CheckpointService():
    TypeOnly<old.CheckpointService>;
declare function use_current_ClassDeclaration_CheckpointService(
    use: TypeOnly<current.CheckpointService>): void;
use_current_ClassDeclaration_CheckpointService(
    get_old_ClassDeclaration_CheckpointService());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_CheckpointService": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_CheckpointService():
    TypeOnly<current.CheckpointService>;
declare function use_old_ClassDeclaration_CheckpointService(
    use: TypeOnly<old.CheckpointService>): void;
use_old_ClassDeclaration_CheckpointService(
    get_current_ClassDeclaration_CheckpointService());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_CombinedContext": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_CombinedContext():
    TypeOnly<old.CombinedContext>;
declare function use_current_ClassDeclaration_CombinedContext(
    use: TypeOnly<current.CombinedContext>): void;
use_current_ClassDeclaration_CombinedContext(
    get_old_ClassDeclaration_CombinedContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_CombinedContext": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_CombinedContext():
    TypeOnly<current.CombinedContext>;
declare function use_old_ClassDeclaration_CombinedContext(
    use: TypeOnly<old.CombinedContext>): void;
use_old_ClassDeclaration_CombinedContext(
    get_current_ClassDeclaration_CombinedContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_CombinedLambda": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_CombinedLambda():
    TypeOnly<old.CombinedLambda>;
declare function use_current_ClassDeclaration_CombinedLambda(
    use: TypeOnly<current.CombinedLambda>): void;
use_current_ClassDeclaration_CombinedLambda(
    get_old_ClassDeclaration_CombinedLambda());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_CombinedLambda": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_CombinedLambda():
    TypeOnly<current.CombinedLambda>;
declare function use_old_ClassDeclaration_CombinedLambda(
    use: TypeOnly<old.CombinedLambda>): void;
use_old_ClassDeclaration_CombinedLambda(
    get_current_ClassDeclaration_CombinedLambda());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_CombinedProducer": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_CombinedProducer():
    TypeOnly<old.CombinedProducer>;
declare function use_current_ClassDeclaration_CombinedProducer(
    use: TypeOnly<current.CombinedProducer>): void;
use_current_ClassDeclaration_CombinedProducer(
    // @ts-expect-error compatibility expected to be broken
    get_old_ClassDeclaration_CombinedProducer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_CombinedProducer": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_CombinedProducer():
    TypeOnly<current.CombinedProducer>;
declare function use_old_ClassDeclaration_CombinedProducer(
    use: TypeOnly<old.CombinedProducer>): void;
use_old_ClassDeclaration_CombinedProducer(
    get_current_ClassDeclaration_CombinedProducer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_ControlMessageType": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_ControlMessageType():
    TypeOnly<old.ControlMessageType>;
declare function use_current_EnumDeclaration_ControlMessageType(
    use: TypeOnly<current.ControlMessageType>): void;
use_current_EnumDeclaration_ControlMessageType(
    get_old_EnumDeclaration_ControlMessageType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_ControlMessageType": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_ControlMessageType():
    TypeOnly<current.ControlMessageType>;
declare function use_old_EnumDeclaration_ControlMessageType(
    use: TypeOnly<old.ControlMessageType>): void;
use_old_EnumDeclaration_ControlMessageType(
    get_current_EnumDeclaration_ControlMessageType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DefaultMetricClient": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_DefaultMetricClient():
    TypeOnly<old.DefaultMetricClient>;
declare function use_current_ClassDeclaration_DefaultMetricClient(
    use: TypeOnly<current.DefaultMetricClient>): void;
use_current_ClassDeclaration_DefaultMetricClient(
    get_old_ClassDeclaration_DefaultMetricClient());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DefaultMetricClient": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_DefaultMetricClient():
    TypeOnly<current.DefaultMetricClient>;
declare function use_old_ClassDeclaration_DefaultMetricClient(
    use: TypeOnly<old.DefaultMetricClient>): void;
use_old_ClassDeclaration_DefaultMetricClient(
    get_current_ClassDeclaration_DefaultMetricClient());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DefaultServiceConfiguration": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_DefaultServiceConfiguration():
    TypeOnly<typeof old.DefaultServiceConfiguration>;
declare function use_current_VariableDeclaration_DefaultServiceConfiguration(
    use: TypeOnly<typeof current.DefaultServiceConfiguration>): void;
use_current_VariableDeclaration_DefaultServiceConfiguration(
    get_old_VariableDeclaration_DefaultServiceConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DefaultServiceConfiguration": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_DefaultServiceConfiguration():
    TypeOnly<typeof current.DefaultServiceConfiguration>;
declare function use_old_VariableDeclaration_DefaultServiceConfiguration(
    use: TypeOnly<typeof old.DefaultServiceConfiguration>): void;
use_old_VariableDeclaration_DefaultServiceConfiguration(
    get_current_VariableDeclaration_DefaultServiceConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_EmptyTaskMessageSender": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_EmptyTaskMessageSender():
    TypeOnly<old.EmptyTaskMessageSender>;
declare function use_current_ClassDeclaration_EmptyTaskMessageSender(
    use: TypeOnly<current.EmptyTaskMessageSender>): void;
use_current_ClassDeclaration_EmptyTaskMessageSender(
    get_old_ClassDeclaration_EmptyTaskMessageSender());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_EmptyTaskMessageSender": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_EmptyTaskMessageSender():
    TypeOnly<current.EmptyTaskMessageSender>;
declare function use_old_ClassDeclaration_EmptyTaskMessageSender(
    use: TypeOnly<old.EmptyTaskMessageSender>): void;
use_old_ClassDeclaration_EmptyTaskMessageSender(
    get_current_ClassDeclaration_EmptyTaskMessageSender());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_EncryptionKeyVersion": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_EncryptionKeyVersion():
    TypeOnly<old.EncryptionKeyVersion>;
declare function use_current_EnumDeclaration_EncryptionKeyVersion(
    use: TypeOnly<current.EncryptionKeyVersion>): void;
use_current_EnumDeclaration_EncryptionKeyVersion(
    get_old_EnumDeclaration_EncryptionKeyVersion());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_EncryptionKeyVersion": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_EncryptionKeyVersion():
    TypeOnly<current.EncryptionKeyVersion>;
declare function use_old_EnumDeclaration_EncryptionKeyVersion(
    use: TypeOnly<old.EncryptionKeyVersion>): void;
use_old_EnumDeclaration_EncryptionKeyVersion(
    get_current_EnumDeclaration_EncryptionKeyVersion());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAgent": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IAgent():
    TypeOnly<old.IAgent>;
declare function use_current_InterfaceDeclaration_IAgent(
    use: TypeOnly<current.IAgent>): void;
use_current_InterfaceDeclaration_IAgent(
    get_old_InterfaceDeclaration_IAgent());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAgent": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IAgent():
    TypeOnly<current.IAgent>;
declare function use_old_InterfaceDeclaration_IAgent(
    use: TypeOnly<old.IAgent>): void;
use_old_InterfaceDeclaration_IAgent(
    get_current_InterfaceDeclaration_IAgent());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAgentUploader": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IAgentUploader():
    TypeOnly<old.IAgentUploader>;
declare function use_current_InterfaceDeclaration_IAgentUploader(
    use: TypeOnly<current.IAgentUploader>): void;
use_current_InterfaceDeclaration_IAgentUploader(
    get_old_InterfaceDeclaration_IAgentUploader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAgentUploader": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IAgentUploader():
    TypeOnly<current.IAgentUploader>;
declare function use_old_InterfaceDeclaration_IAgentUploader(
    use: TypeOnly<old.IAgentUploader>): void;
use_old_InterfaceDeclaration_IAgentUploader(
    get_current_InterfaceDeclaration_IAgentUploader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBoxcarMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IBoxcarMessage():
    TypeOnly<old.IBoxcarMessage>;
declare function use_current_InterfaceDeclaration_IBoxcarMessage(
    use: TypeOnly<current.IBoxcarMessage>): void;
use_current_InterfaceDeclaration_IBoxcarMessage(
    get_old_InterfaceDeclaration_IBoxcarMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBoxcarMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IBoxcarMessage():
    TypeOnly<current.IBoxcarMessage>;
declare function use_old_InterfaceDeclaration_IBoxcarMessage(
    use: TypeOnly<old.IBoxcarMessage>): void;
use_old_InterfaceDeclaration_IBoxcarMessage(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IBoxcarMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBroadcasterServerConfiguration": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IBroadcasterServerConfiguration():
    TypeOnly<old.IBroadcasterServerConfiguration>;
declare function use_current_InterfaceDeclaration_IBroadcasterServerConfiguration(
    use: TypeOnly<current.IBroadcasterServerConfiguration>): void;
use_current_InterfaceDeclaration_IBroadcasterServerConfiguration(
    get_old_InterfaceDeclaration_IBroadcasterServerConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBroadcasterServerConfiguration": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IBroadcasterServerConfiguration():
    TypeOnly<current.IBroadcasterServerConfiguration>;
declare function use_old_InterfaceDeclaration_IBroadcasterServerConfiguration(
    use: TypeOnly<old.IBroadcasterServerConfiguration>): void;
use_old_InterfaceDeclaration_IBroadcasterServerConfiguration(
    get_current_InterfaceDeclaration_IBroadcasterServerConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICache": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICache():
    TypeOnly<old.ICache>;
declare function use_current_InterfaceDeclaration_ICache(
    use: TypeOnly<current.ICache>): void;
use_current_InterfaceDeclaration_ICache(
    get_old_InterfaceDeclaration_ICache());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICache": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICache():
    TypeOnly<current.ICache>;
declare function use_old_InterfaceDeclaration_ICache(
    use: TypeOnly<old.ICache>): void;
use_old_InterfaceDeclaration_ICache(
    get_current_InterfaceDeclaration_ICache());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICheckpoint": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICheckpoint():
    TypeOnly<old.ICheckpoint>;
declare function use_current_InterfaceDeclaration_ICheckpoint(
    use: TypeOnly<current.ICheckpoint>): void;
use_current_InterfaceDeclaration_ICheckpoint(
    get_old_InterfaceDeclaration_ICheckpoint());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICheckpoint": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICheckpoint():
    TypeOnly<current.ICheckpoint>;
declare function use_old_InterfaceDeclaration_ICheckpoint(
    use: TypeOnly<old.ICheckpoint>): void;
use_old_InterfaceDeclaration_ICheckpoint(
    get_current_InterfaceDeclaration_ICheckpoint());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICheckpointHeuristicsServerConfiguration": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICheckpointHeuristicsServerConfiguration():
    TypeOnly<old.ICheckpointHeuristicsServerConfiguration>;
declare function use_current_InterfaceDeclaration_ICheckpointHeuristicsServerConfiguration(
    use: TypeOnly<current.ICheckpointHeuristicsServerConfiguration>): void;
use_current_InterfaceDeclaration_ICheckpointHeuristicsServerConfiguration(
    get_old_InterfaceDeclaration_ICheckpointHeuristicsServerConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICheckpointHeuristicsServerConfiguration": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICheckpointHeuristicsServerConfiguration():
    TypeOnly<current.ICheckpointHeuristicsServerConfiguration>;
declare function use_old_InterfaceDeclaration_ICheckpointHeuristicsServerConfiguration(
    use: TypeOnly<old.ICheckpointHeuristicsServerConfiguration>): void;
use_old_InterfaceDeclaration_ICheckpointHeuristicsServerConfiguration(
    get_current_InterfaceDeclaration_ICheckpointHeuristicsServerConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICheckpointRepository": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICheckpointRepository():
    TypeOnly<old.ICheckpointRepository>;
declare function use_current_InterfaceDeclaration_ICheckpointRepository(
    use: TypeOnly<current.ICheckpointRepository>): void;
use_current_InterfaceDeclaration_ICheckpointRepository(
    get_old_InterfaceDeclaration_ICheckpointRepository());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICheckpointRepository": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICheckpointRepository():
    TypeOnly<current.ICheckpointRepository>;
declare function use_old_InterfaceDeclaration_ICheckpointRepository(
    use: TypeOnly<old.ICheckpointRepository>): void;
use_old_InterfaceDeclaration_ICheckpointRepository(
    get_current_InterfaceDeclaration_ICheckpointRepository());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICheckpointService": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICheckpointService():
    TypeOnly<old.ICheckpointService>;
declare function use_current_InterfaceDeclaration_ICheckpointService(
    use: TypeOnly<current.ICheckpointService>): void;
use_current_InterfaceDeclaration_ICheckpointService(
    get_old_InterfaceDeclaration_ICheckpointService());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICheckpointService": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICheckpointService():
    TypeOnly<current.ICheckpointService>;
declare function use_old_InterfaceDeclaration_ICheckpointService(
    use: TypeOnly<old.ICheckpointService>): void;
use_old_InterfaceDeclaration_ICheckpointService(
    get_current_InterfaceDeclaration_ICheckpointService());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IClientManager": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IClientManager():
    TypeOnly<old.IClientManager>;
declare function use_current_InterfaceDeclaration_IClientManager(
    use: TypeOnly<current.IClientManager>): void;
use_current_InterfaceDeclaration_IClientManager(
    get_old_InterfaceDeclaration_IClientManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IClientManager": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IClientManager():
    TypeOnly<current.IClientManager>;
declare function use_old_InterfaceDeclaration_IClientManager(
    use: TypeOnly<old.IClientManager>): void;
use_old_InterfaceDeclaration_IClientManager(
    get_current_InterfaceDeclaration_IClientManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IClientSequenceNumber": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IClientSequenceNumber():
    TypeOnly<old.IClientSequenceNumber>;
declare function use_current_InterfaceDeclaration_IClientSequenceNumber(
    use: TypeOnly<current.IClientSequenceNumber>): void;
use_current_InterfaceDeclaration_IClientSequenceNumber(
    get_old_InterfaceDeclaration_IClientSequenceNumber());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IClientSequenceNumber": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IClientSequenceNumber():
    TypeOnly<current.IClientSequenceNumber>;
declare function use_old_InterfaceDeclaration_IClientSequenceNumber(
    use: TypeOnly<old.IClientSequenceNumber>): void;
use_old_InterfaceDeclaration_IClientSequenceNumber(
    get_current_InterfaceDeclaration_IClientSequenceNumber());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IClusterDrainingChecker": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IClusterDrainingChecker():
    TypeOnly<old.IClusterDrainingChecker>;
declare function use_current_InterfaceDeclaration_IClusterDrainingChecker(
    use: TypeOnly<current.IClusterDrainingChecker>): void;
use_current_InterfaceDeclaration_IClusterDrainingChecker(
    get_old_InterfaceDeclaration_IClusterDrainingChecker());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IClusterDrainingChecker": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IClusterDrainingChecker():
    TypeOnly<current.IClusterDrainingChecker>;
declare function use_old_InterfaceDeclaration_IClusterDrainingChecker(
    use: TypeOnly<old.IClusterDrainingChecker>): void;
use_old_InterfaceDeclaration_IClusterDrainingChecker(
    get_current_InterfaceDeclaration_IClusterDrainingChecker());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICollection": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICollection():
    TypeOnly<old.ICollection<any>>;
declare function use_current_InterfaceDeclaration_ICollection(
    use: TypeOnly<current.ICollection<any>>): void;
use_current_InterfaceDeclaration_ICollection(
    get_old_InterfaceDeclaration_ICollection());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICollection": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICollection():
    TypeOnly<current.ICollection<any>>;
declare function use_old_InterfaceDeclaration_ICollection(
    use: TypeOnly<old.ICollection<any>>): void;
use_old_InterfaceDeclaration_ICollection(
    get_current_InterfaceDeclaration_ICollection());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConsumer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IConsumer():
    TypeOnly<old.IConsumer>;
declare function use_current_InterfaceDeclaration_IConsumer(
    use: TypeOnly<current.IConsumer>): void;
use_current_InterfaceDeclaration_IConsumer(
    get_old_InterfaceDeclaration_IConsumer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IConsumer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IConsumer():
    TypeOnly<current.IConsumer>;
declare function use_old_InterfaceDeclaration_IConsumer(
    use: TypeOnly<old.IConsumer>): void;
use_old_InterfaceDeclaration_IConsumer(
    get_current_InterfaceDeclaration_IConsumer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContext": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IContext():
    TypeOnly<old.IContext>;
declare function use_current_InterfaceDeclaration_IContext(
    use: TypeOnly<current.IContext>): void;
use_current_InterfaceDeclaration_IContext(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_IContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContext": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IContext():
    TypeOnly<current.IContext>;
declare function use_old_InterfaceDeclaration_IContext(
    use: TypeOnly<old.IContext>): void;
use_old_InterfaceDeclaration_IContext(
    get_current_InterfaceDeclaration_IContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContextErrorData": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IContextErrorData():
    TypeOnly<old.IContextErrorData>;
declare function use_current_InterfaceDeclaration_IContextErrorData(
    use: TypeOnly<current.IContextErrorData>): void;
use_current_InterfaceDeclaration_IContextErrorData(
    get_old_InterfaceDeclaration_IContextErrorData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IContextErrorData": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IContextErrorData():
    TypeOnly<current.IContextErrorData>;
declare function use_old_InterfaceDeclaration_IContextErrorData(
    use: TypeOnly<old.IContextErrorData>): void;
use_old_InterfaceDeclaration_IContextErrorData(
    get_current_InterfaceDeclaration_IContextErrorData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IControlMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IControlMessage():
    TypeOnly<old.IControlMessage>;
declare function use_current_InterfaceDeclaration_IControlMessage(
    use: TypeOnly<current.IControlMessage>): void;
use_current_InterfaceDeclaration_IControlMessage(
    get_old_InterfaceDeclaration_IControlMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IControlMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IControlMessage():
    TypeOnly<current.IControlMessage>;
declare function use_old_InterfaceDeclaration_IControlMessage(
    use: TypeOnly<old.IControlMessage>): void;
use_old_InterfaceDeclaration_IControlMessage(
    get_current_InterfaceDeclaration_IControlMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDatabaseManager": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDatabaseManager():
    TypeOnly<old.IDatabaseManager>;
declare function use_current_InterfaceDeclaration_IDatabaseManager(
    use: TypeOnly<current.IDatabaseManager>): void;
use_current_InterfaceDeclaration_IDatabaseManager(
    get_old_InterfaceDeclaration_IDatabaseManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDatabaseManager": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDatabaseManager():
    TypeOnly<current.IDatabaseManager>;
declare function use_old_InterfaceDeclaration_IDatabaseManager(
    use: TypeOnly<old.IDatabaseManager>): void;
use_old_InterfaceDeclaration_IDatabaseManager(
    get_current_InterfaceDeclaration_IDatabaseManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDb": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDb():
    TypeOnly<old.IDb>;
declare function use_current_InterfaceDeclaration_IDb(
    use: TypeOnly<current.IDb>): void;
use_current_InterfaceDeclaration_IDb(
    get_old_InterfaceDeclaration_IDb());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDb": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDb():
    TypeOnly<current.IDb>;
declare function use_old_InterfaceDeclaration_IDb(
    use: TypeOnly<old.IDb>): void;
use_old_InterfaceDeclaration_IDb(
    get_current_InterfaceDeclaration_IDb());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IDbEvents": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IDbEvents():
    TypeOnly<old.IDbEvents>;
declare function use_current_TypeAliasDeclaration_IDbEvents(
    use: TypeOnly<current.IDbEvents>): void;
use_current_TypeAliasDeclaration_IDbEvents(
    get_old_TypeAliasDeclaration_IDbEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IDbEvents": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IDbEvents():
    TypeOnly<current.IDbEvents>;
declare function use_old_TypeAliasDeclaration_IDbEvents(
    use: TypeOnly<old.IDbEvents>): void;
use_old_TypeAliasDeclaration_IDbEvents(
    get_current_TypeAliasDeclaration_IDbEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDbFactory": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDbFactory():
    TypeOnly<old.IDbFactory>;
declare function use_current_InterfaceDeclaration_IDbFactory(
    use: TypeOnly<current.IDbFactory>): void;
use_current_InterfaceDeclaration_IDbFactory(
    get_old_InterfaceDeclaration_IDbFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDbFactory": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDbFactory():
    TypeOnly<current.IDbFactory>;
declare function use_old_InterfaceDeclaration_IDbFactory(
    use: TypeOnly<old.IDbFactory>): void;
use_old_InterfaceDeclaration_IDbFactory(
    get_current_InterfaceDeclaration_IDbFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeliOpEventServerConfiguration": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDeliOpEventServerConfiguration():
    TypeOnly<old.IDeliOpEventServerConfiguration>;
declare function use_current_InterfaceDeclaration_IDeliOpEventServerConfiguration(
    use: TypeOnly<current.IDeliOpEventServerConfiguration>): void;
use_current_InterfaceDeclaration_IDeliOpEventServerConfiguration(
    get_old_InterfaceDeclaration_IDeliOpEventServerConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeliOpEventServerConfiguration": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDeliOpEventServerConfiguration():
    TypeOnly<current.IDeliOpEventServerConfiguration>;
declare function use_old_InterfaceDeclaration_IDeliOpEventServerConfiguration(
    use: TypeOnly<old.IDeliOpEventServerConfiguration>): void;
use_old_InterfaceDeclaration_IDeliOpEventServerConfiguration(
    get_current_InterfaceDeclaration_IDeliOpEventServerConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeliServerConfiguration": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDeliServerConfiguration():
    TypeOnly<old.IDeliServerConfiguration>;
declare function use_current_InterfaceDeclaration_IDeliServerConfiguration(
    use: TypeOnly<current.IDeliServerConfiguration>): void;
use_current_InterfaceDeclaration_IDeliServerConfiguration(
    get_old_InterfaceDeclaration_IDeliServerConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeliServerConfiguration": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDeliServerConfiguration():
    TypeOnly<current.IDeliServerConfiguration>;
declare function use_old_InterfaceDeclaration_IDeliServerConfiguration(
    use: TypeOnly<old.IDeliServerConfiguration>): void;
use_old_InterfaceDeclaration_IDeliServerConfiguration(
    get_current_InterfaceDeclaration_IDeliServerConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeliState": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDeliState():
    TypeOnly<old.IDeliState>;
declare function use_current_InterfaceDeclaration_IDeliState(
    use: TypeOnly<current.IDeliState>): void;
use_current_InterfaceDeclaration_IDeliState(
    get_old_InterfaceDeclaration_IDeliState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeliState": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDeliState():
    TypeOnly<current.IDeliState>;
declare function use_old_InterfaceDeclaration_IDeliState(
    use: TypeOnly<old.IDeliState>): void;
use_old_InterfaceDeclaration_IDeliState(
    get_current_InterfaceDeclaration_IDeliState());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeliSummaryNackMessagesServerConfiguration": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDeliSummaryNackMessagesServerConfiguration():
    TypeOnly<old.IDeliSummaryNackMessagesServerConfiguration>;
declare function use_current_InterfaceDeclaration_IDeliSummaryNackMessagesServerConfiguration(
    use: TypeOnly<current.IDeliSummaryNackMessagesServerConfiguration>): void;
use_current_InterfaceDeclaration_IDeliSummaryNackMessagesServerConfiguration(
    get_old_InterfaceDeclaration_IDeliSummaryNackMessagesServerConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeliSummaryNackMessagesServerConfiguration": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDeliSummaryNackMessagesServerConfiguration():
    TypeOnly<current.IDeliSummaryNackMessagesServerConfiguration>;
declare function use_old_InterfaceDeclaration_IDeliSummaryNackMessagesServerConfiguration(
    use: TypeOnly<old.IDeliSummaryNackMessagesServerConfiguration>): void;
use_old_InterfaceDeclaration_IDeliSummaryNackMessagesServerConfiguration(
    get_current_InterfaceDeclaration_IDeliSummaryNackMessagesServerConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaService": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDeltaService():
    TypeOnly<old.IDeltaService>;
declare function use_current_InterfaceDeclaration_IDeltaService(
    use: TypeOnly<current.IDeltaService>): void;
use_current_InterfaceDeclaration_IDeltaService(
    get_old_InterfaceDeclaration_IDeltaService());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeltaService": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDeltaService():
    TypeOnly<current.IDeltaService>;
declare function use_old_InterfaceDeclaration_IDeltaService(
    use: TypeOnly<old.IDeltaService>): void;
use_old_InterfaceDeclaration_IDeltaService(
    get_current_InterfaceDeclaration_IDeltaService());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDisableNackMessagesControlMessageContents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDisableNackMessagesControlMessageContents():
    TypeOnly<old.IDisableNackMessagesControlMessageContents>;
declare function use_current_InterfaceDeclaration_IDisableNackMessagesControlMessageContents(
    use: TypeOnly<current.IDisableNackMessagesControlMessageContents>): void;
use_current_InterfaceDeclaration_IDisableNackMessagesControlMessageContents(
    get_old_InterfaceDeclaration_IDisableNackMessagesControlMessageContents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDisableNackMessagesControlMessageContents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDisableNackMessagesControlMessageContents():
    TypeOnly<current.IDisableNackMessagesControlMessageContents>;
declare function use_old_InterfaceDeclaration_IDisableNackMessagesControlMessageContents(
    use: TypeOnly<old.IDisableNackMessagesControlMessageContents>): void;
use_old_InterfaceDeclaration_IDisableNackMessagesControlMessageContents(
    get_current_InterfaceDeclaration_IDisableNackMessagesControlMessageContents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDocument": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDocument():
    TypeOnly<old.IDocument>;
declare function use_current_InterfaceDeclaration_IDocument(
    use: TypeOnly<current.IDocument>): void;
use_current_InterfaceDeclaration_IDocument(
    get_old_InterfaceDeclaration_IDocument());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDocument": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDocument():
    TypeOnly<current.IDocument>;
declare function use_old_InterfaceDeclaration_IDocument(
    use: TypeOnly<old.IDocument>): void;
use_old_InterfaceDeclaration_IDocument(
    get_current_InterfaceDeclaration_IDocument());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDocumentDetails": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDocumentDetails():
    TypeOnly<old.IDocumentDetails>;
declare function use_current_InterfaceDeclaration_IDocumentDetails(
    use: TypeOnly<current.IDocumentDetails>): void;
use_current_InterfaceDeclaration_IDocumentDetails(
    get_old_InterfaceDeclaration_IDocumentDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDocumentDetails": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDocumentDetails():
    TypeOnly<current.IDocumentDetails>;
declare function use_old_InterfaceDeclaration_IDocumentDetails(
    use: TypeOnly<old.IDocumentDetails>): void;
use_old_InterfaceDeclaration_IDocumentDetails(
    get_current_InterfaceDeclaration_IDocumentDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDocumentLambdaServerConfiguration": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDocumentLambdaServerConfiguration():
    TypeOnly<old.IDocumentLambdaServerConfiguration>;
declare function use_current_InterfaceDeclaration_IDocumentLambdaServerConfiguration(
    use: TypeOnly<current.IDocumentLambdaServerConfiguration>): void;
use_current_InterfaceDeclaration_IDocumentLambdaServerConfiguration(
    get_old_InterfaceDeclaration_IDocumentLambdaServerConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDocumentLambdaServerConfiguration": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDocumentLambdaServerConfiguration():
    TypeOnly<current.IDocumentLambdaServerConfiguration>;
declare function use_old_InterfaceDeclaration_IDocumentLambdaServerConfiguration(
    use: TypeOnly<old.IDocumentLambdaServerConfiguration>): void;
use_old_InterfaceDeclaration_IDocumentLambdaServerConfiguration(
    get_current_InterfaceDeclaration_IDocumentLambdaServerConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDocumentManager": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDocumentManager():
    TypeOnly<old.IDocumentManager>;
declare function use_current_InterfaceDeclaration_IDocumentManager(
    use: TypeOnly<current.IDocumentManager>): void;
use_current_InterfaceDeclaration_IDocumentManager(
    get_old_InterfaceDeclaration_IDocumentManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDocumentManager": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDocumentManager():
    TypeOnly<current.IDocumentManager>;
declare function use_old_InterfaceDeclaration_IDocumentManager(
    use: TypeOnly<old.IDocumentManager>): void;
use_old_InterfaceDeclaration_IDocumentManager(
    get_current_InterfaceDeclaration_IDocumentManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDocumentRepository": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDocumentRepository():
    TypeOnly<old.IDocumentRepository>;
declare function use_current_InterfaceDeclaration_IDocumentRepository(
    use: TypeOnly<current.IDocumentRepository>): void;
use_current_InterfaceDeclaration_IDocumentRepository(
    get_old_InterfaceDeclaration_IDocumentRepository());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDocumentRepository": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDocumentRepository():
    TypeOnly<current.IDocumentRepository>;
declare function use_old_InterfaceDeclaration_IDocumentRepository(
    use: TypeOnly<old.IDocumentRepository>): void;
use_old_InterfaceDeclaration_IDocumentRepository(
    get_current_InterfaceDeclaration_IDocumentRepository());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDocumentStaticProperties": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDocumentStaticProperties():
    TypeOnly<old.IDocumentStaticProperties>;
declare function use_current_InterfaceDeclaration_IDocumentStaticProperties(
    use: TypeOnly<current.IDocumentStaticProperties>): void;
use_current_InterfaceDeclaration_IDocumentStaticProperties(
    get_old_InterfaceDeclaration_IDocumentStaticProperties());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDocumentStaticProperties": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDocumentStaticProperties():
    TypeOnly<current.IDocumentStaticProperties>;
declare function use_old_InterfaceDeclaration_IDocumentStaticProperties(
    use: TypeOnly<old.IDocumentStaticProperties>): void;
use_old_InterfaceDeclaration_IDocumentStaticProperties(
    get_current_InterfaceDeclaration_IDocumentStaticProperties());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDocumentStorage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDocumentStorage():
    TypeOnly<old.IDocumentStorage>;
declare function use_current_InterfaceDeclaration_IDocumentStorage(
    use: TypeOnly<current.IDocumentStorage>): void;
use_current_InterfaceDeclaration_IDocumentStorage(
    get_old_InterfaceDeclaration_IDocumentStorage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDocumentStorage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDocumentStorage():
    TypeOnly<current.IDocumentStorage>;
declare function use_old_InterfaceDeclaration_IDocumentStorage(
    use: TypeOnly<old.IDocumentStorage>): void;
use_old_InterfaceDeclaration_IDocumentStorage(
    get_current_InterfaceDeclaration_IDocumentStorage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEncryptedTenantKeys": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IEncryptedTenantKeys():
    TypeOnly<old.IEncryptedTenantKeys>;
declare function use_current_InterfaceDeclaration_IEncryptedTenantKeys(
    use: TypeOnly<current.IEncryptedTenantKeys>): void;
use_current_InterfaceDeclaration_IEncryptedTenantKeys(
    get_old_InterfaceDeclaration_IEncryptedTenantKeys());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEncryptedTenantKeys": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IEncryptedTenantKeys():
    TypeOnly<current.IEncryptedTenantKeys>;
declare function use_old_InterfaceDeclaration_IEncryptedTenantKeys(
    use: TypeOnly<old.IEncryptedTenantKeys>): void;
use_old_InterfaceDeclaration_IEncryptedTenantKeys(
    get_current_InterfaceDeclaration_IEncryptedTenantKeys());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IExtendClientControlMessageContents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IExtendClientControlMessageContents():
    TypeOnly<old.IExtendClientControlMessageContents>;
declare function use_current_InterfaceDeclaration_IExtendClientControlMessageContents(
    use: TypeOnly<current.IExtendClientControlMessageContents>): void;
use_current_InterfaceDeclaration_IExtendClientControlMessageContents(
    get_old_InterfaceDeclaration_IExtendClientControlMessageContents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IExtendClientControlMessageContents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IExtendClientControlMessageContents():
    TypeOnly<current.IExtendClientControlMessageContents>;
declare function use_old_InterfaceDeclaration_IExtendClientControlMessageContents(
    use: TypeOnly<old.IExtendClientControlMessageContents>): void;
use_old_InterfaceDeclaration_IExtendClientControlMessageContents(
    get_current_InterfaceDeclaration_IExtendClientControlMessageContents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IHttpServer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IHttpServer():
    TypeOnly<old.IHttpServer>;
declare function use_current_InterfaceDeclaration_IHttpServer(
    use: TypeOnly<current.IHttpServer>): void;
use_current_InterfaceDeclaration_IHttpServer(
    get_old_InterfaceDeclaration_IHttpServer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IHttpServer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IHttpServer():
    TypeOnly<current.IHttpServer>;
declare function use_old_InterfaceDeclaration_IHttpServer(
    use: TypeOnly<old.IHttpServer>): void;
use_old_InterfaceDeclaration_IHttpServer(
    get_current_InterfaceDeclaration_IHttpServer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ILambdaStartControlMessageContents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ILambdaStartControlMessageContents():
    TypeOnly<old.ILambdaStartControlMessageContents>;
declare function use_current_InterfaceDeclaration_ILambdaStartControlMessageContents(
    use: TypeOnly<current.ILambdaStartControlMessageContents>): void;
use_current_InterfaceDeclaration_ILambdaStartControlMessageContents(
    get_old_InterfaceDeclaration_ILambdaStartControlMessageContents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ILambdaStartControlMessageContents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ILambdaStartControlMessageContents():
    TypeOnly<current.ILambdaStartControlMessageContents>;
declare function use_old_InterfaceDeclaration_ILambdaStartControlMessageContents(
    use: TypeOnly<old.ILambdaStartControlMessageContents>): void;
use_old_InterfaceDeclaration_ILambdaStartControlMessageContents(
    get_current_InterfaceDeclaration_ILambdaStartControlMessageContents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ILogger": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ILogger():
    TypeOnly<old.ILogger>;
declare function use_current_InterfaceDeclaration_ILogger(
    use: TypeOnly<current.ILogger>): void;
use_current_InterfaceDeclaration_ILogger(
    get_old_InterfaceDeclaration_ILogger());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ILogger": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ILogger():
    TypeOnly<current.ILogger>;
declare function use_old_InterfaceDeclaration_ILogger(
    use: TypeOnly<old.ILogger>): void;
use_old_InterfaceDeclaration_ILogger(
    get_current_InterfaceDeclaration_ILogger());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IMessage():
    TypeOnly<old.IMessage>;
declare function use_current_InterfaceDeclaration_IMessage(
    use: TypeOnly<current.IMessage>): void;
use_current_InterfaceDeclaration_IMessage(
    get_old_InterfaceDeclaration_IMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IMessage():
    TypeOnly<current.IMessage>;
declare function use_old_InterfaceDeclaration_IMessage(
    use: TypeOnly<old.IMessage>): void;
use_old_InterfaceDeclaration_IMessage(
    get_current_InterfaceDeclaration_IMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMessageBatch": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IMessageBatch():
    TypeOnly<old.IMessageBatch<any>>;
declare function use_current_InterfaceDeclaration_IMessageBatch(
    use: TypeOnly<current.IMessageBatch<any>>): void;
use_current_InterfaceDeclaration_IMessageBatch(
    get_old_InterfaceDeclaration_IMessageBatch());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMessageBatch": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IMessageBatch():
    TypeOnly<current.IMessageBatch<any>>;
declare function use_old_InterfaceDeclaration_IMessageBatch(
    use: TypeOnly<old.IMessageBatch<any>>): void;
use_old_InterfaceDeclaration_IMessageBatch(
    get_current_InterfaceDeclaration_IMessageBatch());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMetricClient": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IMetricClient():
    TypeOnly<old.IMetricClient>;
declare function use_current_InterfaceDeclaration_IMetricClient(
    use: TypeOnly<current.IMetricClient>): void;
use_current_InterfaceDeclaration_IMetricClient(
    get_old_InterfaceDeclaration_IMetricClient());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMetricClient": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IMetricClient():
    TypeOnly<current.IMetricClient>;
declare function use_old_InterfaceDeclaration_IMetricClient(
    use: TypeOnly<old.IMetricClient>): void;
use_old_InterfaceDeclaration_IMetricClient(
    get_current_InterfaceDeclaration_IMetricClient());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMoiraServerConfiguration": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IMoiraServerConfiguration():
    TypeOnly<old.IMoiraServerConfiguration>;
declare function use_current_InterfaceDeclaration_IMoiraServerConfiguration(
    use: TypeOnly<current.IMoiraServerConfiguration>): void;
use_current_InterfaceDeclaration_IMoiraServerConfiguration(
    get_old_InterfaceDeclaration_IMoiraServerConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IMoiraServerConfiguration": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IMoiraServerConfiguration():
    TypeOnly<current.IMoiraServerConfiguration>;
declare function use_old_InterfaceDeclaration_IMoiraServerConfiguration(
    use: TypeOnly<old.IMoiraServerConfiguration>): void;
use_old_InterfaceDeclaration_IMoiraServerConfiguration(
    get_current_InterfaceDeclaration_IMoiraServerConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_INackMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_INackMessage():
    TypeOnly<old.INackMessage>;
declare function use_current_InterfaceDeclaration_INackMessage(
    use: TypeOnly<current.INackMessage>): void;
use_current_InterfaceDeclaration_INackMessage(
    get_old_InterfaceDeclaration_INackMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_INackMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_INackMessage():
    TypeOnly<current.INackMessage>;
declare function use_old_InterfaceDeclaration_INackMessage(
    use: TypeOnly<old.INackMessage>): void;
use_old_InterfaceDeclaration_INackMessage(
    get_current_InterfaceDeclaration_INackMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_INackMessagesControlMessageContents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_INackMessagesControlMessageContents():
    TypeOnly<old.INackMessagesControlMessageContents>;
declare function use_current_InterfaceDeclaration_INackMessagesControlMessageContents(
    use: TypeOnly<current.INackMessagesControlMessageContents>): void;
use_current_InterfaceDeclaration_INackMessagesControlMessageContents(
    get_old_InterfaceDeclaration_INackMessagesControlMessageContents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_INackMessagesControlMessageContents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_INackMessagesControlMessageContents():
    TypeOnly<current.INackMessagesControlMessageContents>;
declare function use_old_InterfaceDeclaration_INackMessagesControlMessageContents(
    use: TypeOnly<old.INackMessagesControlMessageContents>): void;
use_old_InterfaceDeclaration_INackMessagesControlMessageContents(
    get_current_InterfaceDeclaration_INackMessagesControlMessageContents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_INode": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_INode():
    TypeOnly<old.INode>;
declare function use_current_InterfaceDeclaration_INode(
    use: TypeOnly<current.INode>): void;
use_current_InterfaceDeclaration_INode(
    get_old_InterfaceDeclaration_INode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_INode": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_INode():
    TypeOnly<current.INode>;
declare function use_old_InterfaceDeclaration_INode(
    use: TypeOnly<old.INode>): void;
use_old_InterfaceDeclaration_INode(
    get_current_InterfaceDeclaration_INode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IObjectMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IObjectMessage():
    TypeOnly<old.IObjectMessage>;
declare function use_current_InterfaceDeclaration_IObjectMessage(
    use: TypeOnly<current.IObjectMessage>): void;
use_current_InterfaceDeclaration_IObjectMessage(
    get_old_InterfaceDeclaration_IObjectMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IObjectMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IObjectMessage():
    TypeOnly<current.IObjectMessage>;
declare function use_old_InterfaceDeclaration_IObjectMessage(
    use: TypeOnly<old.IObjectMessage>): void;
use_old_InterfaceDeclaration_IObjectMessage(
    get_current_InterfaceDeclaration_IObjectMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOrderer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IOrderer():
    TypeOnly<old.IOrderer>;
declare function use_current_InterfaceDeclaration_IOrderer(
    use: TypeOnly<current.IOrderer>): void;
use_current_InterfaceDeclaration_IOrderer(
    get_old_InterfaceDeclaration_IOrderer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOrderer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IOrderer():
    TypeOnly<current.IOrderer>;
declare function use_old_InterfaceDeclaration_IOrderer(
    use: TypeOnly<old.IOrderer>): void;
use_old_InterfaceDeclaration_IOrderer(
    get_current_InterfaceDeclaration_IOrderer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOrdererConnection": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IOrdererConnection():
    TypeOnly<old.IOrdererConnection>;
declare function use_current_InterfaceDeclaration_IOrdererConnection(
    use: TypeOnly<current.IOrdererConnection>): void;
use_current_InterfaceDeclaration_IOrdererConnection(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_IOrdererConnection());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOrdererConnection": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IOrdererConnection():
    TypeOnly<current.IOrdererConnection>;
declare function use_old_InterfaceDeclaration_IOrdererConnection(
    use: TypeOnly<old.IOrdererConnection>): void;
use_old_InterfaceDeclaration_IOrdererConnection(
    get_current_InterfaceDeclaration_IOrdererConnection());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOrdererManager": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IOrdererManager():
    TypeOnly<old.IOrdererManager>;
declare function use_current_InterfaceDeclaration_IOrdererManager(
    use: TypeOnly<current.IOrdererManager>): void;
use_current_InterfaceDeclaration_IOrdererManager(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_IOrdererManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOrdererManager": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IOrdererManager():
    TypeOnly<current.IOrdererManager>;
declare function use_old_InterfaceDeclaration_IOrdererManager(
    use: TypeOnly<old.IOrdererManager>): void;
use_old_InterfaceDeclaration_IOrdererManager(
    get_current_InterfaceDeclaration_IOrdererManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOrdererSocket": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IOrdererSocket():
    TypeOnly<old.IOrdererSocket>;
declare function use_current_InterfaceDeclaration_IOrdererSocket(
    use: TypeOnly<current.IOrdererSocket>): void;
use_current_InterfaceDeclaration_IOrdererSocket(
    get_old_InterfaceDeclaration_IOrdererSocket());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IOrdererSocket": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IOrdererSocket():
    TypeOnly<current.IOrdererSocket>;
declare function use_old_InterfaceDeclaration_IOrdererSocket(
    use: TypeOnly<old.IOrdererSocket>): void;
use_old_InterfaceDeclaration_IOrdererSocket(
    get_current_InterfaceDeclaration_IOrdererSocket());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPartition": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPartition():
    TypeOnly<old.IPartition>;
declare function use_current_InterfaceDeclaration_IPartition(
    use: TypeOnly<current.IPartition>): void;
use_current_InterfaceDeclaration_IPartition(
    get_old_InterfaceDeclaration_IPartition());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPartition": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPartition():
    TypeOnly<current.IPartition>;
declare function use_old_InterfaceDeclaration_IPartition(
    use: TypeOnly<old.IPartition>): void;
use_old_InterfaceDeclaration_IPartition(
    get_current_InterfaceDeclaration_IPartition());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPartitionLambda": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPartitionLambda():
    TypeOnly<old.IPartitionLambda>;
declare function use_current_InterfaceDeclaration_IPartitionLambda(
    use: TypeOnly<current.IPartitionLambda>): void;
use_current_InterfaceDeclaration_IPartitionLambda(
    get_old_InterfaceDeclaration_IPartitionLambda());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPartitionLambda": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPartitionLambda():
    TypeOnly<current.IPartitionLambda>;
declare function use_old_InterfaceDeclaration_IPartitionLambda(
    use: TypeOnly<old.IPartitionLambda>): void;
use_old_InterfaceDeclaration_IPartitionLambda(
    get_current_InterfaceDeclaration_IPartitionLambda());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPartitionLambdaConfig": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPartitionLambdaConfig():
    TypeOnly<old.IPartitionLambdaConfig>;
declare function use_current_InterfaceDeclaration_IPartitionLambdaConfig(
    use: TypeOnly<current.IPartitionLambdaConfig>): void;
use_current_InterfaceDeclaration_IPartitionLambdaConfig(
    get_old_InterfaceDeclaration_IPartitionLambdaConfig());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPartitionLambdaConfig": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPartitionLambdaConfig():
    TypeOnly<current.IPartitionLambdaConfig>;
declare function use_old_InterfaceDeclaration_IPartitionLambdaConfig(
    use: TypeOnly<old.IPartitionLambdaConfig>): void;
use_old_InterfaceDeclaration_IPartitionLambdaConfig(
    get_current_InterfaceDeclaration_IPartitionLambdaConfig());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPartitionLambdaFactory": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPartitionLambdaFactory():
    TypeOnly<old.IPartitionLambdaFactory>;
declare function use_current_InterfaceDeclaration_IPartitionLambdaFactory(
    use: TypeOnly<current.IPartitionLambdaFactory>): void;
use_current_InterfaceDeclaration_IPartitionLambdaFactory(
    get_old_InterfaceDeclaration_IPartitionLambdaFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPartitionLambdaFactory": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPartitionLambdaFactory():
    TypeOnly<current.IPartitionLambdaFactory>;
declare function use_old_InterfaceDeclaration_IPartitionLambdaFactory(
    use: TypeOnly<old.IPartitionLambdaFactory>): void;
use_old_InterfaceDeclaration_IPartitionLambdaFactory(
    get_current_InterfaceDeclaration_IPartitionLambdaFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPartitionLambdaPlugin": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPartitionLambdaPlugin():
    TypeOnly<old.IPartitionLambdaPlugin>;
declare function use_current_InterfaceDeclaration_IPartitionLambdaPlugin(
    use: TypeOnly<current.IPartitionLambdaPlugin>): void;
use_current_InterfaceDeclaration_IPartitionLambdaPlugin(
    get_old_InterfaceDeclaration_IPartitionLambdaPlugin());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPartitionLambdaPlugin": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPartitionLambdaPlugin():
    TypeOnly<current.IPartitionLambdaPlugin>;
declare function use_old_InterfaceDeclaration_IPartitionLambdaPlugin(
    use: TypeOnly<old.IPartitionLambdaPlugin>): void;
use_old_InterfaceDeclaration_IPartitionLambdaPlugin(
    get_current_InterfaceDeclaration_IPartitionLambdaPlugin());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPendingBoxcar": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPendingBoxcar():
    TypeOnly<old.IPendingBoxcar>;
declare function use_current_InterfaceDeclaration_IPendingBoxcar(
    use: TypeOnly<current.IPendingBoxcar>): void;
use_current_InterfaceDeclaration_IPendingBoxcar(
    get_old_InterfaceDeclaration_IPendingBoxcar());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPendingBoxcar": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPendingBoxcar():
    TypeOnly<current.IPendingBoxcar>;
declare function use_old_InterfaceDeclaration_IPendingBoxcar(
    use: TypeOnly<old.IPendingBoxcar>): void;
use_old_InterfaceDeclaration_IPendingBoxcar(
    get_current_InterfaceDeclaration_IPendingBoxcar());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPendingMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPendingMessage():
    TypeOnly<old.IPendingMessage>;
declare function use_current_InterfaceDeclaration_IPendingMessage(
    use: TypeOnly<current.IPendingMessage>): void;
use_current_InterfaceDeclaration_IPendingMessage(
    get_old_InterfaceDeclaration_IPendingMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPendingMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPendingMessage():
    TypeOnly<current.IPendingMessage>;
declare function use_old_InterfaceDeclaration_IPendingMessage(
    use: TypeOnly<old.IPendingMessage>): void;
use_old_InterfaceDeclaration_IPendingMessage(
    get_current_InterfaceDeclaration_IPendingMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProducer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IProducer():
    TypeOnly<old.IProducer>;
declare function use_current_InterfaceDeclaration_IProducer(
    use: TypeOnly<current.IProducer>): void;
use_current_InterfaceDeclaration_IProducer(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_IProducer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IProducer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IProducer():
    TypeOnly<current.IProducer>;
declare function use_old_InterfaceDeclaration_IProducer(
    use: TypeOnly<old.IProducer>): void;
use_old_InterfaceDeclaration_IProducer(
    get_current_InterfaceDeclaration_IProducer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPublisher": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPublisher():
    TypeOnly<old.IPublisher>;
declare function use_current_InterfaceDeclaration_IPublisher(
    use: TypeOnly<current.IPublisher>): void;
use_current_InterfaceDeclaration_IPublisher(
    get_old_InterfaceDeclaration_IPublisher());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPublisher": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPublisher():
    TypeOnly<current.IPublisher>;
declare function use_old_InterfaceDeclaration_IPublisher(
    use: TypeOnly<old.IPublisher>): void;
use_old_InterfaceDeclaration_IPublisher(
    get_current_InterfaceDeclaration_IPublisher());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IQueuedMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IQueuedMessage():
    TypeOnly<old.IQueuedMessage>;
declare function use_current_InterfaceDeclaration_IQueuedMessage(
    use: TypeOnly<current.IQueuedMessage>): void;
use_current_InterfaceDeclaration_IQueuedMessage(
    get_old_InterfaceDeclaration_IQueuedMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IQueuedMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IQueuedMessage():
    TypeOnly<current.IQueuedMessage>;
declare function use_old_InterfaceDeclaration_IQueuedMessage(
    use: TypeOnly<old.IQueuedMessage>): void;
use_old_InterfaceDeclaration_IQueuedMessage(
    get_current_InterfaceDeclaration_IQueuedMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRawOperationMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRawOperationMessage():
    TypeOnly<old.IRawOperationMessage>;
declare function use_current_InterfaceDeclaration_IRawOperationMessage(
    use: TypeOnly<current.IRawOperationMessage>): void;
use_current_InterfaceDeclaration_IRawOperationMessage(
    get_old_InterfaceDeclaration_IRawOperationMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRawOperationMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRawOperationMessage():
    TypeOnly<current.IRawOperationMessage>;
declare function use_old_InterfaceDeclaration_IRawOperationMessage(
    use: TypeOnly<old.IRawOperationMessage>): void;
use_old_InterfaceDeclaration_IRawOperationMessage(
    get_current_InterfaceDeclaration_IRawOperationMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRawOperationMessageBatch": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRawOperationMessageBatch():
    TypeOnly<old.IRawOperationMessageBatch>;
declare function use_current_InterfaceDeclaration_IRawOperationMessageBatch(
    use: TypeOnly<current.IRawOperationMessageBatch>): void;
use_current_InterfaceDeclaration_IRawOperationMessageBatch(
    get_old_InterfaceDeclaration_IRawOperationMessageBatch());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRawOperationMessageBatch": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRawOperationMessageBatch():
    TypeOnly<current.IRawOperationMessageBatch>;
declare function use_old_InterfaceDeclaration_IRawOperationMessageBatch(
    use: TypeOnly<old.IRawOperationMessageBatch>): void;
use_old_InterfaceDeclaration_IRawOperationMessageBatch(
    get_current_InterfaceDeclaration_IRawOperationMessageBatch());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IResources": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IResources():
    TypeOnly<old.IResources>;
declare function use_current_InterfaceDeclaration_IResources(
    use: TypeOnly<current.IResources>): void;
use_current_InterfaceDeclaration_IResources(
    get_old_InterfaceDeclaration_IResources());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IResources": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IResources():
    TypeOnly<current.IResources>;
declare function use_old_InterfaceDeclaration_IResources(
    use: TypeOnly<old.IResources>): void;
use_old_InterfaceDeclaration_IResources(
    get_current_InterfaceDeclaration_IResources());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IResourcesFactory": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IResourcesFactory():
    TypeOnly<old.IResourcesFactory<any>>;
declare function use_current_InterfaceDeclaration_IResourcesFactory(
    use: TypeOnly<current.IResourcesFactory<any>>): void;
use_current_InterfaceDeclaration_IResourcesFactory(
    get_old_InterfaceDeclaration_IResourcesFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IResourcesFactory": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IResourcesFactory():
    TypeOnly<current.IResourcesFactory<any>>;
declare function use_old_InterfaceDeclaration_IResourcesFactory(
    use: TypeOnly<old.IResourcesFactory<any>>): void;
use_old_InterfaceDeclaration_IResourcesFactory(
    get_current_InterfaceDeclaration_IResourcesFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRetryable": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRetryable():
    TypeOnly<old.IRetryable>;
declare function use_current_InterfaceDeclaration_IRetryable(
    use: TypeOnly<current.IRetryable>): void;
use_current_InterfaceDeclaration_IRetryable(
    get_old_InterfaceDeclaration_IRetryable());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRetryable": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRetryable():
    TypeOnly<current.IRetryable>;
declare function use_old_InterfaceDeclaration_IRetryable(
    use: TypeOnly<old.IRetryable>): void;
use_old_InterfaceDeclaration_IRetryable(
    get_current_InterfaceDeclaration_IRetryable());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRevokeTokenOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRevokeTokenOptions():
    TypeOnly<old.IRevokeTokenOptions>;
declare function use_current_InterfaceDeclaration_IRevokeTokenOptions(
    use: TypeOnly<current.IRevokeTokenOptions>): void;
use_current_InterfaceDeclaration_IRevokeTokenOptions(
    get_old_InterfaceDeclaration_IRevokeTokenOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRevokeTokenOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRevokeTokenOptions():
    TypeOnly<current.IRevokeTokenOptions>;
declare function use_old_InterfaceDeclaration_IRevokeTokenOptions(
    use: TypeOnly<old.IRevokeTokenOptions>): void;
use_old_InterfaceDeclaration_IRevokeTokenOptions(
    get_current_InterfaceDeclaration_IRevokeTokenOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRevokedTokenChecker": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRevokedTokenChecker():
    TypeOnly<old.IRevokedTokenChecker>;
declare function use_current_InterfaceDeclaration_IRevokedTokenChecker(
    use: TypeOnly<current.IRevokedTokenChecker>): void;
use_current_InterfaceDeclaration_IRevokedTokenChecker(
    get_old_InterfaceDeclaration_IRevokedTokenChecker());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRevokedTokenChecker": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRevokedTokenChecker():
    TypeOnly<current.IRevokedTokenChecker>;
declare function use_old_InterfaceDeclaration_IRevokedTokenChecker(
    use: TypeOnly<old.IRevokedTokenChecker>): void;
use_old_InterfaceDeclaration_IRevokedTokenChecker(
    get_current_InterfaceDeclaration_IRevokedTokenChecker());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRoutingKey": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRoutingKey():
    TypeOnly<old.IRoutingKey>;
declare function use_current_InterfaceDeclaration_IRoutingKey(
    use: TypeOnly<current.IRoutingKey>): void;
use_current_InterfaceDeclaration_IRoutingKey(
    get_old_InterfaceDeclaration_IRoutingKey());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRoutingKey": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRoutingKey():
    TypeOnly<current.IRoutingKey>;
declare function use_old_InterfaceDeclaration_IRoutingKey(
    use: TypeOnly<old.IRoutingKey>): void;
use_old_InterfaceDeclaration_IRoutingKey(
    get_current_InterfaceDeclaration_IRoutingKey());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRunner": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRunner():
    TypeOnly<old.IRunner>;
declare function use_current_InterfaceDeclaration_IRunner(
    use: TypeOnly<current.IRunner>): void;
use_current_InterfaceDeclaration_IRunner(
    get_old_InterfaceDeclaration_IRunner());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRunner": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRunner():
    TypeOnly<current.IRunner>;
declare function use_old_InterfaceDeclaration_IRunner(
    use: TypeOnly<old.IRunner>): void;
use_old_InterfaceDeclaration_IRunner(
    get_current_InterfaceDeclaration_IRunner());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRunnerFactory": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRunnerFactory():
    TypeOnly<old.IRunnerFactory<any>>;
declare function use_current_InterfaceDeclaration_IRunnerFactory(
    use: TypeOnly<current.IRunnerFactory<any>>): void;
use_current_InterfaceDeclaration_IRunnerFactory(
    get_old_InterfaceDeclaration_IRunnerFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRunnerFactory": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRunnerFactory():
    TypeOnly<current.IRunnerFactory<any>>;
declare function use_old_InterfaceDeclaration_IRunnerFactory(
    use: TypeOnly<old.IRunnerFactory<any>>): void;
use_old_InterfaceDeclaration_IRunnerFactory(
    get_current_InterfaceDeclaration_IRunnerFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IScribe": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IScribe():
    TypeOnly<old.IScribe>;
declare function use_current_InterfaceDeclaration_IScribe(
    use: TypeOnly<current.IScribe>): void;
use_current_InterfaceDeclaration_IScribe(
    get_old_InterfaceDeclaration_IScribe());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IScribe": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IScribe():
    TypeOnly<current.IScribe>;
declare function use_old_InterfaceDeclaration_IScribe(
    use: TypeOnly<old.IScribe>): void;
use_old_InterfaceDeclaration_IScribe(
    get_current_InterfaceDeclaration_IScribe());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IScribeServerConfiguration": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IScribeServerConfiguration():
    TypeOnly<old.IScribeServerConfiguration>;
declare function use_current_InterfaceDeclaration_IScribeServerConfiguration(
    use: TypeOnly<current.IScribeServerConfiguration>): void;
use_current_InterfaceDeclaration_IScribeServerConfiguration(
    get_old_InterfaceDeclaration_IScribeServerConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IScribeServerConfiguration": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IScribeServerConfiguration():
    TypeOnly<current.IScribeServerConfiguration>;
declare function use_old_InterfaceDeclaration_IScribeServerConfiguration(
    use: TypeOnly<old.IScribeServerConfiguration>): void;
use_old_InterfaceDeclaration_IScribeServerConfiguration(
    get_current_InterfaceDeclaration_IScribeServerConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISecretManager": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISecretManager():
    TypeOnly<old.ISecretManager>;
declare function use_current_InterfaceDeclaration_ISecretManager(
    use: TypeOnly<current.ISecretManager>): void;
use_current_InterfaceDeclaration_ISecretManager(
    get_old_InterfaceDeclaration_ISecretManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISecretManager": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISecretManager():
    TypeOnly<current.ISecretManager>;
declare function use_old_InterfaceDeclaration_ISecretManager(
    use: TypeOnly<old.ISecretManager>): void;
use_old_InterfaceDeclaration_ISecretManager(
    get_current_InterfaceDeclaration_ISecretManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISequencedOperationMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISequencedOperationMessage():
    TypeOnly<old.ISequencedOperationMessage>;
declare function use_current_InterfaceDeclaration_ISequencedOperationMessage(
    use: TypeOnly<current.ISequencedOperationMessage>): void;
use_current_InterfaceDeclaration_ISequencedOperationMessage(
    get_old_InterfaceDeclaration_ISequencedOperationMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISequencedOperationMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISequencedOperationMessage():
    TypeOnly<current.ISequencedOperationMessage>;
declare function use_old_InterfaceDeclaration_ISequencedOperationMessage(
    use: TypeOnly<old.ISequencedOperationMessage>): void;
use_old_InterfaceDeclaration_ISequencedOperationMessage(
    get_current_InterfaceDeclaration_ISequencedOperationMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISequencedSignalClient": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISequencedSignalClient():
    TypeOnly<old.ISequencedSignalClient>;
declare function use_current_InterfaceDeclaration_ISequencedSignalClient(
    use: TypeOnly<current.ISequencedSignalClient>): void;
use_current_InterfaceDeclaration_ISequencedSignalClient(
    get_old_InterfaceDeclaration_ISequencedSignalClient());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISequencedSignalClient": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISequencedSignalClient():
    TypeOnly<current.ISequencedSignalClient>;
declare function use_old_InterfaceDeclaration_ISequencedSignalClient(
    use: TypeOnly<old.ISequencedSignalClient>): void;
use_old_InterfaceDeclaration_ISequencedSignalClient(
    get_current_InterfaceDeclaration_ISequencedSignalClient());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IServerConfiguration": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IServerConfiguration():
    TypeOnly<old.IServerConfiguration>;
declare function use_current_InterfaceDeclaration_IServerConfiguration(
    use: TypeOnly<current.IServerConfiguration>): void;
use_current_InterfaceDeclaration_IServerConfiguration(
    get_old_InterfaceDeclaration_IServerConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IServerConfiguration": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IServerConfiguration():
    TypeOnly<current.IServerConfiguration>;
declare function use_old_InterfaceDeclaration_IServerConfiguration(
    use: TypeOnly<old.IServerConfiguration>): void;
use_old_InterfaceDeclaration_IServerConfiguration(
    get_current_InterfaceDeclaration_IServerConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IServiceConfiguration": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IServiceConfiguration():
    TypeOnly<old.IServiceConfiguration>;
declare function use_current_InterfaceDeclaration_IServiceConfiguration(
    use: TypeOnly<current.IServiceConfiguration>): void;
use_current_InterfaceDeclaration_IServiceConfiguration(
    get_old_InterfaceDeclaration_IServiceConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IServiceConfiguration": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IServiceConfiguration():
    TypeOnly<current.IServiceConfiguration>;
declare function use_old_InterfaceDeclaration_IServiceConfiguration(
    use: TypeOnly<old.IServiceConfiguration>): void;
use_old_InterfaceDeclaration_IServiceConfiguration(
    get_current_InterfaceDeclaration_IServiceConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IServiceMessageResourceManager": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IServiceMessageResourceManager():
    TypeOnly<old.IServiceMessageResourceManager>;
declare function use_current_InterfaceDeclaration_IServiceMessageResourceManager(
    use: TypeOnly<current.IServiceMessageResourceManager>): void;
use_current_InterfaceDeclaration_IServiceMessageResourceManager(
    get_old_InterfaceDeclaration_IServiceMessageResourceManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IServiceMessageResourceManager": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IServiceMessageResourceManager():
    TypeOnly<current.IServiceMessageResourceManager>;
declare function use_old_InterfaceDeclaration_IServiceMessageResourceManager(
    use: TypeOnly<old.IServiceMessageResourceManager>): void;
use_old_InterfaceDeclaration_IServiceMessageResourceManager(
    get_current_InterfaceDeclaration_IServiceMessageResourceManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IStorageNameAllocator": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IStorageNameAllocator():
    TypeOnly<old.IStorageNameAllocator>;
declare function use_current_InterfaceDeclaration_IStorageNameAllocator(
    use: TypeOnly<current.IStorageNameAllocator>): void;
use_current_InterfaceDeclaration_IStorageNameAllocator(
    get_old_InterfaceDeclaration_IStorageNameAllocator());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IStorageNameAllocator": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IStorageNameAllocator():
    TypeOnly<current.IStorageNameAllocator>;
declare function use_old_InterfaceDeclaration_IStorageNameAllocator(
    use: TypeOnly<old.IStorageNameAllocator>): void;
use_old_InterfaceDeclaration_IStorageNameAllocator(
    get_current_InterfaceDeclaration_IStorageNameAllocator());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IStorageNameRetriever": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IStorageNameRetriever():
    TypeOnly<old.IStorageNameRetriever>;
declare function use_current_InterfaceDeclaration_IStorageNameRetriever(
    use: TypeOnly<current.IStorageNameRetriever>): void;
use_current_InterfaceDeclaration_IStorageNameRetriever(
    get_old_InterfaceDeclaration_IStorageNameRetriever());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IStorageNameRetriever": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IStorageNameRetriever():
    TypeOnly<current.IStorageNameRetriever>;
declare function use_old_InterfaceDeclaration_IStorageNameRetriever(
    use: TypeOnly<old.IStorageNameRetriever>): void;
use_old_InterfaceDeclaration_IStorageNameRetriever(
    get_current_InterfaceDeclaration_IStorageNameRetriever());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISystemMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISystemMessage():
    TypeOnly<old.ISystemMessage>;
declare function use_current_InterfaceDeclaration_ISystemMessage(
    use: TypeOnly<current.ISystemMessage>): void;
use_current_InterfaceDeclaration_ISystemMessage(
    get_old_InterfaceDeclaration_ISystemMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISystemMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISystemMessage():
    TypeOnly<current.ISystemMessage>;
declare function use_old_InterfaceDeclaration_ISystemMessage(
    use: TypeOnly<old.ISystemMessage>): void;
use_old_InterfaceDeclaration_ISystemMessage(
    get_current_InterfaceDeclaration_ISystemMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITaskMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITaskMessage():
    TypeOnly<old.ITaskMessage>;
declare function use_current_InterfaceDeclaration_ITaskMessage(
    use: TypeOnly<current.ITaskMessage>): void;
use_current_InterfaceDeclaration_ITaskMessage(
    get_old_InterfaceDeclaration_ITaskMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITaskMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITaskMessage():
    TypeOnly<current.ITaskMessage>;
declare function use_old_InterfaceDeclaration_ITaskMessage(
    use: TypeOnly<old.ITaskMessage>): void;
use_old_InterfaceDeclaration_ITaskMessage(
    get_current_InterfaceDeclaration_ITaskMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITaskMessageReceiver": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITaskMessageReceiver():
    TypeOnly<old.ITaskMessageReceiver>;
declare function use_current_InterfaceDeclaration_ITaskMessageReceiver(
    use: TypeOnly<current.ITaskMessageReceiver>): void;
use_current_InterfaceDeclaration_ITaskMessageReceiver(
    get_old_InterfaceDeclaration_ITaskMessageReceiver());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITaskMessageReceiver": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITaskMessageReceiver():
    TypeOnly<current.ITaskMessageReceiver>;
declare function use_old_InterfaceDeclaration_ITaskMessageReceiver(
    use: TypeOnly<old.ITaskMessageReceiver>): void;
use_old_InterfaceDeclaration_ITaskMessageReceiver(
    get_current_InterfaceDeclaration_ITaskMessageReceiver());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITaskMessageSender": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITaskMessageSender():
    TypeOnly<old.ITaskMessageSender>;
declare function use_current_InterfaceDeclaration_ITaskMessageSender(
    use: TypeOnly<current.ITaskMessageSender>): void;
use_current_InterfaceDeclaration_ITaskMessageSender(
    get_old_InterfaceDeclaration_ITaskMessageSender());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITaskMessageSender": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITaskMessageSender():
    TypeOnly<current.ITaskMessageSender>;
declare function use_old_InterfaceDeclaration_ITaskMessageSender(
    use: TypeOnly<old.ITaskMessageSender>): void;
use_old_InterfaceDeclaration_ITaskMessageSender(
    get_current_InterfaceDeclaration_ITaskMessageSender());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITenant": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITenant():
    TypeOnly<old.ITenant>;
declare function use_current_InterfaceDeclaration_ITenant(
    use: TypeOnly<current.ITenant>): void;
use_current_InterfaceDeclaration_ITenant(
    get_old_InterfaceDeclaration_ITenant());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITenant": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITenant():
    TypeOnly<current.ITenant>;
declare function use_old_InterfaceDeclaration_ITenant(
    use: TypeOnly<old.ITenant>): void;
use_old_InterfaceDeclaration_ITenant(
    get_current_InterfaceDeclaration_ITenant());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITenantConfig": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITenantConfig():
    TypeOnly<old.ITenantConfig>;
declare function use_current_InterfaceDeclaration_ITenantConfig(
    use: TypeOnly<current.ITenantConfig>): void;
use_current_InterfaceDeclaration_ITenantConfig(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_ITenantConfig());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITenantConfig": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITenantConfig():
    TypeOnly<current.ITenantConfig>;
declare function use_old_InterfaceDeclaration_ITenantConfig(
    use: TypeOnly<old.ITenantConfig>): void;
use_old_InterfaceDeclaration_ITenantConfig(
    get_current_InterfaceDeclaration_ITenantConfig());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITenantConfigManager": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITenantConfigManager():
    TypeOnly<old.ITenantConfigManager>;
declare function use_current_InterfaceDeclaration_ITenantConfigManager(
    use: TypeOnly<current.ITenantConfigManager>): void;
use_current_InterfaceDeclaration_ITenantConfigManager(
    get_old_InterfaceDeclaration_ITenantConfigManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITenantConfigManager": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITenantConfigManager():
    TypeOnly<current.ITenantConfigManager>;
declare function use_old_InterfaceDeclaration_ITenantConfigManager(
    use: TypeOnly<old.ITenantConfigManager>): void;
use_old_InterfaceDeclaration_ITenantConfigManager(
    get_current_InterfaceDeclaration_ITenantConfigManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITenantCustomData": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITenantCustomData():
    TypeOnly<old.ITenantCustomData>;
declare function use_current_InterfaceDeclaration_ITenantCustomData(
    use: TypeOnly<current.ITenantCustomData>): void;
use_current_InterfaceDeclaration_ITenantCustomData(
    get_old_InterfaceDeclaration_ITenantCustomData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITenantCustomData": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITenantCustomData():
    TypeOnly<current.ITenantCustomData>;
declare function use_old_InterfaceDeclaration_ITenantCustomData(
    use: TypeOnly<old.ITenantCustomData>): void;
use_old_InterfaceDeclaration_ITenantCustomData(
    get_current_InterfaceDeclaration_ITenantCustomData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITenantKeys": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITenantKeys():
    TypeOnly<old.ITenantKeys>;
declare function use_current_InterfaceDeclaration_ITenantKeys(
    use: TypeOnly<current.ITenantKeys>): void;
use_current_InterfaceDeclaration_ITenantKeys(
    get_old_InterfaceDeclaration_ITenantKeys());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITenantKeys": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITenantKeys():
    TypeOnly<current.ITenantKeys>;
declare function use_old_InterfaceDeclaration_ITenantKeys(
    use: TypeOnly<old.ITenantKeys>): void;
use_old_InterfaceDeclaration_ITenantKeys(
    get_current_InterfaceDeclaration_ITenantKeys());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITenantManager": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITenantManager():
    TypeOnly<old.ITenantManager>;
declare function use_current_InterfaceDeclaration_ITenantManager(
    use: TypeOnly<current.ITenantManager>): void;
use_current_InterfaceDeclaration_ITenantManager(
    // @ts-expect-error compatibility expected to be broken
    get_old_InterfaceDeclaration_ITenantManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITenantManager": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITenantManager():
    TypeOnly<current.ITenantManager>;
declare function use_old_InterfaceDeclaration_ITenantManager(
    use: TypeOnly<old.ITenantManager>): void;
use_old_InterfaceDeclaration_ITenantManager(
    get_current_InterfaceDeclaration_ITenantManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITenantOrderer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITenantOrderer():
    TypeOnly<old.ITenantOrderer>;
declare function use_current_InterfaceDeclaration_ITenantOrderer(
    use: TypeOnly<current.ITenantOrderer>): void;
use_current_InterfaceDeclaration_ITenantOrderer(
    get_old_InterfaceDeclaration_ITenantOrderer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITenantOrderer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITenantOrderer():
    TypeOnly<current.ITenantOrderer>;
declare function use_old_InterfaceDeclaration_ITenantOrderer(
    use: TypeOnly<old.ITenantOrderer>): void;
use_old_InterfaceDeclaration_ITenantOrderer(
    get_current_InterfaceDeclaration_ITenantOrderer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITenantStorage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITenantStorage():
    TypeOnly<old.ITenantStorage>;
declare function use_current_InterfaceDeclaration_ITenantStorage(
    use: TypeOnly<current.ITenantStorage>): void;
use_current_InterfaceDeclaration_ITenantStorage(
    get_old_InterfaceDeclaration_ITenantStorage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITenantStorage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITenantStorage():
    TypeOnly<current.ITenantStorage>;
declare function use_old_InterfaceDeclaration_ITenantStorage(
    use: TypeOnly<old.ITenantStorage>): void;
use_old_InterfaceDeclaration_ITenantStorage(
    get_current_InterfaceDeclaration_ITenantStorage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottleAndUsageStorageManager": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IThrottleAndUsageStorageManager():
    TypeOnly<old.IThrottleAndUsageStorageManager>;
declare function use_current_InterfaceDeclaration_IThrottleAndUsageStorageManager(
    use: TypeOnly<current.IThrottleAndUsageStorageManager>): void;
use_current_InterfaceDeclaration_IThrottleAndUsageStorageManager(
    get_old_InterfaceDeclaration_IThrottleAndUsageStorageManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottleAndUsageStorageManager": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IThrottleAndUsageStorageManager():
    TypeOnly<current.IThrottleAndUsageStorageManager>;
declare function use_old_InterfaceDeclaration_IThrottleAndUsageStorageManager(
    use: TypeOnly<old.IThrottleAndUsageStorageManager>): void;
use_old_InterfaceDeclaration_IThrottleAndUsageStorageManager(
    get_current_InterfaceDeclaration_IThrottleAndUsageStorageManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottler": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IThrottler():
    TypeOnly<old.IThrottler>;
declare function use_current_InterfaceDeclaration_IThrottler(
    use: TypeOnly<current.IThrottler>): void;
use_current_InterfaceDeclaration_IThrottler(
    get_old_InterfaceDeclaration_IThrottler());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottler": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IThrottler():
    TypeOnly<current.IThrottler>;
declare function use_old_InterfaceDeclaration_IThrottler(
    use: TypeOnly<old.IThrottler>): void;
use_old_InterfaceDeclaration_IThrottler(
    get_current_InterfaceDeclaration_IThrottler());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottlerHelper": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IThrottlerHelper():
    TypeOnly<old.IThrottlerHelper>;
declare function use_current_InterfaceDeclaration_IThrottlerHelper(
    use: TypeOnly<current.IThrottlerHelper>): void;
use_current_InterfaceDeclaration_IThrottlerHelper(
    get_old_InterfaceDeclaration_IThrottlerHelper());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottlerHelper": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IThrottlerHelper():
    TypeOnly<current.IThrottlerHelper>;
declare function use_old_InterfaceDeclaration_IThrottlerHelper(
    use: TypeOnly<old.IThrottlerHelper>): void;
use_old_InterfaceDeclaration_IThrottlerHelper(
    get_current_InterfaceDeclaration_IThrottlerHelper());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottlerResponse": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IThrottlerResponse():
    TypeOnly<old.IThrottlerResponse>;
declare function use_current_InterfaceDeclaration_IThrottlerResponse(
    use: TypeOnly<current.IThrottlerResponse>): void;
use_current_InterfaceDeclaration_IThrottlerResponse(
    get_old_InterfaceDeclaration_IThrottlerResponse());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottlerResponse": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IThrottlerResponse():
    TypeOnly<current.IThrottlerResponse>;
declare function use_old_InterfaceDeclaration_IThrottlerResponse(
    use: TypeOnly<old.IThrottlerResponse>): void;
use_old_InterfaceDeclaration_IThrottlerResponse(
    get_current_InterfaceDeclaration_IThrottlerResponse());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottlingMetrics": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IThrottlingMetrics():
    TypeOnly<old.IThrottlingMetrics>;
declare function use_current_InterfaceDeclaration_IThrottlingMetrics(
    use: TypeOnly<current.IThrottlingMetrics>): void;
use_current_InterfaceDeclaration_IThrottlingMetrics(
    get_old_InterfaceDeclaration_IThrottlingMetrics());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottlingMetrics": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IThrottlingMetrics():
    TypeOnly<current.IThrottlingMetrics>;
declare function use_old_InterfaceDeclaration_IThrottlingMetrics(
    use: TypeOnly<old.IThrottlingMetrics>): void;
use_old_InterfaceDeclaration_IThrottlingMetrics(
    get_current_InterfaceDeclaration_IThrottlingMetrics());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITicketedMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITicketedMessage():
    TypeOnly<old.ITicketedMessage>;
declare function use_current_InterfaceDeclaration_ITicketedMessage(
    use: TypeOnly<current.ITicketedMessage>): void;
use_current_InterfaceDeclaration_ITicketedMessage(
    get_old_InterfaceDeclaration_ITicketedMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITicketedMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITicketedMessage():
    TypeOnly<current.ITicketedMessage>;
declare function use_old_InterfaceDeclaration_ITicketedMessage(
    use: TypeOnly<old.ITicketedMessage>): void;
use_old_InterfaceDeclaration_ITicketedMessage(
    get_current_InterfaceDeclaration_ITicketedMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITicketedSignalMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITicketedSignalMessage():
    TypeOnly<old.ITicketedSignalMessage>;
declare function use_current_InterfaceDeclaration_ITicketedSignalMessage(
    use: TypeOnly<current.ITicketedSignalMessage>): void;
use_current_InterfaceDeclaration_ITicketedSignalMessage(
    get_old_InterfaceDeclaration_ITicketedSignalMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITicketedSignalMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITicketedSignalMessage():
    TypeOnly<current.ITicketedSignalMessage>;
declare function use_old_InterfaceDeclaration_ITicketedSignalMessage(
    use: TypeOnly<old.ITicketedSignalMessage>): void;
use_old_InterfaceDeclaration_ITicketedSignalMessage(
    get_current_InterfaceDeclaration_ITicketedSignalMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITokenRevocationManager": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITokenRevocationManager():
    TypeOnly<old.ITokenRevocationManager>;
declare function use_current_InterfaceDeclaration_ITokenRevocationManager(
    use: TypeOnly<current.ITokenRevocationManager>): void;
use_current_InterfaceDeclaration_ITokenRevocationManager(
    get_old_InterfaceDeclaration_ITokenRevocationManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITokenRevocationManager": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITokenRevocationManager():
    TypeOnly<current.ITokenRevocationManager>;
declare function use_old_InterfaceDeclaration_ITokenRevocationManager(
    use: TypeOnly<old.ITokenRevocationManager>): void;
use_old_InterfaceDeclaration_ITokenRevocationManager(
    get_current_InterfaceDeclaration_ITokenRevocationManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITokenRevocationResponse": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITokenRevocationResponse():
    TypeOnly<old.ITokenRevocationResponse>;
declare function use_current_InterfaceDeclaration_ITokenRevocationResponse(
    use: TypeOnly<current.ITokenRevocationResponse>): void;
use_current_InterfaceDeclaration_ITokenRevocationResponse(
    get_old_InterfaceDeclaration_ITokenRevocationResponse());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITokenRevocationResponse": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITokenRevocationResponse():
    TypeOnly<current.ITokenRevocationResponse>;
declare function use_old_InterfaceDeclaration_ITokenRevocationResponse(
    use: TypeOnly<old.ITokenRevocationResponse>): void;
use_old_InterfaceDeclaration_ITokenRevocationResponse(
    get_current_InterfaceDeclaration_ITokenRevocationResponse());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITopic": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITopic():
    TypeOnly<old.ITopic>;
declare function use_current_InterfaceDeclaration_ITopic(
    use: TypeOnly<current.ITopic>): void;
use_current_InterfaceDeclaration_ITopic(
    get_old_InterfaceDeclaration_ITopic());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITopic": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITopic():
    TypeOnly<current.ITopic>;
declare function use_old_InterfaceDeclaration_ITopic(
    use: TypeOnly<old.ITopic>): void;
use_old_InterfaceDeclaration_ITopic(
    get_current_InterfaceDeclaration_ITopic());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUpdateDSNControlMessageContents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IUpdateDSNControlMessageContents():
    TypeOnly<old.IUpdateDSNControlMessageContents>;
declare function use_current_InterfaceDeclaration_IUpdateDSNControlMessageContents(
    use: TypeOnly<current.IUpdateDSNControlMessageContents>): void;
use_current_InterfaceDeclaration_IUpdateDSNControlMessageContents(
    get_old_InterfaceDeclaration_IUpdateDSNControlMessageContents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUpdateDSNControlMessageContents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IUpdateDSNControlMessageContents():
    TypeOnly<current.IUpdateDSNControlMessageContents>;
declare function use_old_InterfaceDeclaration_IUpdateDSNControlMessageContents(
    use: TypeOnly<old.IUpdateDSNControlMessageContents>): void;
use_old_InterfaceDeclaration_IUpdateDSNControlMessageContents(
    get_current_InterfaceDeclaration_IUpdateDSNControlMessageContents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUpdateReferenceSequenceNumberMessage": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IUpdateReferenceSequenceNumberMessage():
    TypeOnly<old.IUpdateReferenceSequenceNumberMessage>;
declare function use_current_InterfaceDeclaration_IUpdateReferenceSequenceNumberMessage(
    use: TypeOnly<current.IUpdateReferenceSequenceNumberMessage>): void;
use_current_InterfaceDeclaration_IUpdateReferenceSequenceNumberMessage(
    get_old_InterfaceDeclaration_IUpdateReferenceSequenceNumberMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUpdateReferenceSequenceNumberMessage": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IUpdateReferenceSequenceNumberMessage():
    TypeOnly<current.IUpdateReferenceSequenceNumberMessage>;
declare function use_old_InterfaceDeclaration_IUpdateReferenceSequenceNumberMessage(
    use: TypeOnly<old.IUpdateReferenceSequenceNumberMessage>): void;
use_old_InterfaceDeclaration_IUpdateReferenceSequenceNumberMessage(
    get_current_InterfaceDeclaration_IUpdateReferenceSequenceNumberMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUsageData": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IUsageData():
    TypeOnly<old.IUsageData>;
declare function use_current_InterfaceDeclaration_IUsageData(
    use: TypeOnly<current.IUsageData>): void;
use_current_InterfaceDeclaration_IUsageData(
    get_old_InterfaceDeclaration_IUsageData());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IUsageData": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IUsageData():
    TypeOnly<current.IUsageData>;
declare function use_old_InterfaceDeclaration_IUsageData(
    use: TypeOnly<old.IUsageData>): void;
use_old_InterfaceDeclaration_IUsageData(
    get_current_InterfaceDeclaration_IUsageData());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWebServer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IWebServer():
    TypeOnly<old.IWebServer>;
declare function use_current_InterfaceDeclaration_IWebServer(
    use: TypeOnly<current.IWebServer>): void;
use_current_InterfaceDeclaration_IWebServer(
    get_old_InterfaceDeclaration_IWebServer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWebServer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IWebServer():
    TypeOnly<current.IWebServer>;
declare function use_old_InterfaceDeclaration_IWebServer(
    use: TypeOnly<old.IWebServer>): void;
use_old_InterfaceDeclaration_IWebServer(
    get_current_InterfaceDeclaration_IWebServer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWebServerFactory": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IWebServerFactory():
    TypeOnly<old.IWebServerFactory>;
declare function use_current_InterfaceDeclaration_IWebServerFactory(
    use: TypeOnly<current.IWebServerFactory>): void;
use_current_InterfaceDeclaration_IWebServerFactory(
    get_old_InterfaceDeclaration_IWebServerFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWebServerFactory": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IWebServerFactory():
    TypeOnly<current.IWebServerFactory>;
declare function use_old_InterfaceDeclaration_IWebServerFactory(
    use: TypeOnly<old.IWebServerFactory>): void;
use_old_InterfaceDeclaration_IWebServerFactory(
    get_current_InterfaceDeclaration_IWebServerFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWebSocket": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IWebSocket():
    TypeOnly<old.IWebSocket>;
declare function use_current_InterfaceDeclaration_IWebSocket(
    use: TypeOnly<current.IWebSocket>): void;
use_current_InterfaceDeclaration_IWebSocket(
    get_old_InterfaceDeclaration_IWebSocket());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWebSocket": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IWebSocket():
    TypeOnly<current.IWebSocket>;
declare function use_old_InterfaceDeclaration_IWebSocket(
    use: TypeOnly<old.IWebSocket>): void;
use_old_InterfaceDeclaration_IWebSocket(
    get_current_InterfaceDeclaration_IWebSocket());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWebSocketServer": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IWebSocketServer():
    TypeOnly<old.IWebSocketServer>;
declare function use_current_InterfaceDeclaration_IWebSocketServer(
    use: TypeOnly<current.IWebSocketServer>): void;
use_current_InterfaceDeclaration_IWebSocketServer(
    get_old_InterfaceDeclaration_IWebSocketServer());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWebSocketServer": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IWebSocketServer():
    TypeOnly<current.IWebSocketServer>;
declare function use_old_InterfaceDeclaration_IWebSocketServer(
    use: TypeOnly<old.IWebSocketServer>): void;
use_old_InterfaceDeclaration_IWebSocketServer(
    get_current_InterfaceDeclaration_IWebSocketServer());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWebSocketTracker": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IWebSocketTracker():
    TypeOnly<old.IWebSocketTracker>;
declare function use_current_InterfaceDeclaration_IWebSocketTracker(
    use: TypeOnly<current.IWebSocketTracker>): void;
use_current_InterfaceDeclaration_IWebSocketTracker(
    get_old_InterfaceDeclaration_IWebSocketTracker());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWebSocketTracker": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IWebSocketTracker():
    TypeOnly<current.IWebSocketTracker>;
declare function use_old_InterfaceDeclaration_IWebSocketTracker(
    use: TypeOnly<old.IWebSocketTracker>): void;
use_old_InterfaceDeclaration_IWebSocketTracker(
    get_current_InterfaceDeclaration_IWebSocketTracker());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IZookeeperClient": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IZookeeperClient():
    TypeOnly<old.IZookeeperClient>;
declare function use_current_InterfaceDeclaration_IZookeeperClient(
    use: TypeOnly<current.IZookeeperClient>): void;
use_current_InterfaceDeclaration_IZookeeperClient(
    get_old_InterfaceDeclaration_IZookeeperClient());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IZookeeperClient": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IZookeeperClient():
    TypeOnly<current.IZookeeperClient>;
declare function use_old_InterfaceDeclaration_IZookeeperClient(
    use: TypeOnly<old.IZookeeperClient>): void;
use_old_InterfaceDeclaration_IZookeeperClient(
    get_current_InterfaceDeclaration_IZookeeperClient());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_KeyName": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_KeyName():
    TypeOnly<old.KeyName>;
declare function use_current_EnumDeclaration_KeyName(
    use: TypeOnly<current.KeyName>): void;
use_current_EnumDeclaration_KeyName(
    get_old_EnumDeclaration_KeyName());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_KeyName": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_KeyName():
    TypeOnly<current.KeyName>;
declare function use_old_EnumDeclaration_KeyName(
    use: TypeOnly<old.KeyName>): void;
use_old_EnumDeclaration_KeyName(
    get_current_EnumDeclaration_KeyName());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_LambdaCloseType": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_LambdaCloseType():
    TypeOnly<old.LambdaCloseType>;
declare function use_current_EnumDeclaration_LambdaCloseType(
    use: TypeOnly<current.LambdaCloseType>): void;
use_current_EnumDeclaration_LambdaCloseType(
    get_old_EnumDeclaration_LambdaCloseType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_LambdaCloseType": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_LambdaCloseType():
    TypeOnly<current.LambdaCloseType>;
declare function use_old_EnumDeclaration_LambdaCloseType(
    use: TypeOnly<old.LambdaCloseType>): void;
use_old_EnumDeclaration_LambdaCloseType(
    get_current_EnumDeclaration_LambdaCloseType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_LambdaName": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_LambdaName():
    TypeOnly<old.LambdaName>;
declare function use_current_EnumDeclaration_LambdaName(
    use: TypeOnly<current.LambdaName>): void;
use_current_EnumDeclaration_LambdaName(
    get_old_EnumDeclaration_LambdaName());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_LambdaName": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_LambdaName():
    TypeOnly<current.LambdaName>;
declare function use_old_EnumDeclaration_LambdaName(
    use: TypeOnly<old.LambdaName>): void;
use_old_EnumDeclaration_LambdaName(
    get_current_EnumDeclaration_LambdaName());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_MaxBatchSize": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_MaxBatchSize():
    TypeOnly<typeof old.MaxBatchSize>;
declare function use_current_VariableDeclaration_MaxBatchSize(
    use: TypeOnly<typeof current.MaxBatchSize>): void;
use_current_VariableDeclaration_MaxBatchSize(
    get_old_VariableDeclaration_MaxBatchSize());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_MaxBatchSize": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_MaxBatchSize():
    TypeOnly<typeof current.MaxBatchSize>;
declare function use_old_VariableDeclaration_MaxBatchSize(
    use: TypeOnly<typeof old.MaxBatchSize>): void;
use_old_VariableDeclaration_MaxBatchSize(
    get_current_VariableDeclaration_MaxBatchSize());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MongoCheckpointRepository": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_MongoCheckpointRepository():
    TypeOnly<old.MongoCheckpointRepository>;
declare function use_current_ClassDeclaration_MongoCheckpointRepository(
    use: TypeOnly<current.MongoCheckpointRepository>): void;
use_current_ClassDeclaration_MongoCheckpointRepository(
    get_old_ClassDeclaration_MongoCheckpointRepository());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MongoCheckpointRepository": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_MongoCheckpointRepository():
    TypeOnly<current.MongoCheckpointRepository>;
declare function use_old_ClassDeclaration_MongoCheckpointRepository(
    use: TypeOnly<old.MongoCheckpointRepository>): void;
use_old_ClassDeclaration_MongoCheckpointRepository(
    get_current_ClassDeclaration_MongoCheckpointRepository());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MongoDatabaseManager": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_MongoDatabaseManager():
    TypeOnly<old.MongoDatabaseManager>;
declare function use_current_ClassDeclaration_MongoDatabaseManager(
    use: TypeOnly<current.MongoDatabaseManager>): void;
use_current_ClassDeclaration_MongoDatabaseManager(
    get_old_ClassDeclaration_MongoDatabaseManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MongoDatabaseManager": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_MongoDatabaseManager():
    TypeOnly<current.MongoDatabaseManager>;
declare function use_old_ClassDeclaration_MongoDatabaseManager(
    use: TypeOnly<old.MongoDatabaseManager>): void;
use_old_ClassDeclaration_MongoDatabaseManager(
    get_current_ClassDeclaration_MongoDatabaseManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MongoDocumentRepository": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_MongoDocumentRepository():
    TypeOnly<old.MongoDocumentRepository>;
declare function use_current_ClassDeclaration_MongoDocumentRepository(
    use: TypeOnly<current.MongoDocumentRepository>): void;
use_current_ClassDeclaration_MongoDocumentRepository(
    get_old_ClassDeclaration_MongoDocumentRepository());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MongoDocumentRepository": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_MongoDocumentRepository():
    TypeOnly<current.MongoDocumentRepository>;
declare function use_old_ClassDeclaration_MongoDocumentRepository(
    use: TypeOnly<old.MongoDocumentRepository>): void;
use_old_ClassDeclaration_MongoDocumentRepository(
    get_current_ClassDeclaration_MongoDocumentRepository());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MongoManager": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_MongoManager():
    TypeOnly<old.MongoManager>;
declare function use_current_ClassDeclaration_MongoManager(
    use: TypeOnly<current.MongoManager>): void;
use_current_ClassDeclaration_MongoManager(
    // @ts-expect-error compatibility expected to be broken
    get_old_ClassDeclaration_MongoManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MongoManager": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_MongoManager():
    TypeOnly<current.MongoManager>;
declare function use_old_ClassDeclaration_MongoManager(
    use: TypeOnly<old.MongoManager>): void;
use_old_ClassDeclaration_MongoManager(
    get_current_ClassDeclaration_MongoManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_NackMessagesType": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_NackMessagesType():
    TypeOnly<old.NackMessagesType>;
declare function use_current_EnumDeclaration_NackMessagesType(
    use: TypeOnly<current.NackMessagesType>): void;
use_current_EnumDeclaration_NackMessagesType(
    get_old_EnumDeclaration_NackMessagesType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_NackMessagesType": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_NackMessagesType():
    TypeOnly<current.NackMessagesType>;
declare function use_old_EnumDeclaration_NackMessagesType(
    use: TypeOnly<old.NackMessagesType>): void;
use_old_EnumDeclaration_NackMessagesType(
    get_current_EnumDeclaration_NackMessagesType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_NackOperationType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_NackOperationType():
    TypeOnly<typeof old.NackOperationType>;
declare function use_current_VariableDeclaration_NackOperationType(
    use: TypeOnly<typeof current.NackOperationType>): void;
use_current_VariableDeclaration_NackOperationType(
    get_old_VariableDeclaration_NackOperationType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_NackOperationType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_NackOperationType():
    TypeOnly<typeof current.NackOperationType>;
declare function use_old_VariableDeclaration_NackOperationType(
    use: TypeOnly<typeof old.NackOperationType>): void;
use_old_VariableDeclaration_NackOperationType(
    get_current_VariableDeclaration_NackOperationType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_PendingBoxcar": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_PendingBoxcar():
    TypeOnly<old.PendingBoxcar>;
declare function use_current_ClassDeclaration_PendingBoxcar(
    use: TypeOnly<current.PendingBoxcar>): void;
use_current_ClassDeclaration_PendingBoxcar(
    get_old_ClassDeclaration_PendingBoxcar());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_PendingBoxcar": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_PendingBoxcar():
    TypeOnly<current.PendingBoxcar>;
declare function use_old_ClassDeclaration_PendingBoxcar(
    use: TypeOnly<old.PendingBoxcar>): void;
use_old_ClassDeclaration_PendingBoxcar(
    get_current_ClassDeclaration_PendingBoxcar());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_RawOperationType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_RawOperationType():
    TypeOnly<typeof old.RawOperationType>;
declare function use_current_VariableDeclaration_RawOperationType(
    use: TypeOnly<typeof current.RawOperationType>): void;
use_current_VariableDeclaration_RawOperationType(
    get_old_VariableDeclaration_RawOperationType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_RawOperationType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_RawOperationType():
    TypeOnly<typeof current.RawOperationType>;
declare function use_old_VariableDeclaration_RawOperationType(
    use: TypeOnly<typeof old.RawOperationType>): void;
use_old_VariableDeclaration_RawOperationType(
    get_current_VariableDeclaration_RawOperationType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_RequestListener": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_RequestListener():
    TypeOnly<old.RequestListener>;
declare function use_current_TypeAliasDeclaration_RequestListener(
    use: TypeOnly<current.RequestListener>): void;
use_current_TypeAliasDeclaration_RequestListener(
    get_old_TypeAliasDeclaration_RequestListener());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_RequestListener": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_RequestListener():
    TypeOnly<current.RequestListener>;
declare function use_old_TypeAliasDeclaration_RequestListener(
    use: TypeOnly<old.RequestListener>): void;
use_old_TypeAliasDeclaration_RequestListener(
    get_current_TypeAliasDeclaration_RequestListener());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_SequencedOperationType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_SequencedOperationType():
    TypeOnly<typeof old.SequencedOperationType>;
declare function use_current_VariableDeclaration_SequencedOperationType(
    use: TypeOnly<typeof current.SequencedOperationType>): void;
use_current_VariableDeclaration_SequencedOperationType(
    get_old_VariableDeclaration_SequencedOperationType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_SequencedOperationType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_SequencedOperationType():
    TypeOnly<typeof current.SequencedOperationType>;
declare function use_old_VariableDeclaration_SequencedOperationType(
    use: TypeOnly<typeof old.SequencedOperationType>): void;
use_old_VariableDeclaration_SequencedOperationType(
    get_current_VariableDeclaration_SequencedOperationType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_SignalOperationType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_SignalOperationType():
    TypeOnly<typeof old.SignalOperationType>;
declare function use_current_VariableDeclaration_SignalOperationType(
    use: TypeOnly<typeof current.SignalOperationType>): void;
use_current_VariableDeclaration_SignalOperationType(
    get_old_VariableDeclaration_SignalOperationType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_SignalOperationType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_SignalOperationType():
    TypeOnly<typeof current.SignalOperationType>;
declare function use_old_VariableDeclaration_SignalOperationType(
    use: TypeOnly<typeof old.SignalOperationType>): void;
use_old_VariableDeclaration_SignalOperationType(
    get_current_VariableDeclaration_SignalOperationType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_SystemOperations": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_SystemOperations():
    TypeOnly<old.SystemOperations>;
declare function use_current_EnumDeclaration_SystemOperations(
    use: TypeOnly<current.SystemOperations>): void;
use_current_EnumDeclaration_SystemOperations(
    get_old_EnumDeclaration_SystemOperations());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_SystemOperations": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_SystemOperations():
    TypeOnly<current.SystemOperations>;
declare function use_old_EnumDeclaration_SystemOperations(
    use: TypeOnly<old.SystemOperations>): void;
use_old_EnumDeclaration_SystemOperations(
    get_current_EnumDeclaration_SystemOperations());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_SystemType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_SystemType():
    TypeOnly<typeof old.SystemType>;
declare function use_current_VariableDeclaration_SystemType(
    use: TypeOnly<typeof current.SystemType>): void;
use_current_VariableDeclaration_SystemType(
    get_old_VariableDeclaration_SystemType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_SystemType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_SystemType():
    TypeOnly<typeof current.SystemType>;
declare function use_old_VariableDeclaration_SystemType(
    use: TypeOnly<typeof old.SystemType>): void;
use_old_VariableDeclaration_SystemType(
    get_current_VariableDeclaration_SystemType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ThrottlingError": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ThrottlingError():
    TypeOnly<old.ThrottlingError>;
declare function use_current_ClassDeclaration_ThrottlingError(
    use: TypeOnly<current.ThrottlingError>): void;
use_current_ClassDeclaration_ThrottlingError(
    get_old_ClassDeclaration_ThrottlingError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ThrottlingError": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ThrottlingError():
    TypeOnly<current.ThrottlingError>;
declare function use_old_ClassDeclaration_ThrottlingError(
    use: TypeOnly<old.ThrottlingError>): void;
use_old_ClassDeclaration_ThrottlingError(
    get_current_ClassDeclaration_ThrottlingError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TokenGenerator": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_TokenGenerator():
    TypeOnly<old.TokenGenerator>;
declare function use_current_TypeAliasDeclaration_TokenGenerator(
    use: TypeOnly<current.TokenGenerator>): void;
use_current_TypeAliasDeclaration_TokenGenerator(
    get_old_TypeAliasDeclaration_TokenGenerator());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_TokenGenerator": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_TokenGenerator():
    TypeOnly<current.TokenGenerator>;
declare function use_old_TypeAliasDeclaration_TokenGenerator(
    use: TypeOnly<old.TokenGenerator>): void;
use_old_TypeAliasDeclaration_TokenGenerator(
    get_current_TypeAliasDeclaration_TokenGenerator());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TokenRevocationError": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_TokenRevocationError():
    TypeOnly<old.TokenRevocationError>;
declare function use_current_ClassDeclaration_TokenRevocationError(
    use: TypeOnly<current.TokenRevocationError>): void;
use_current_ClassDeclaration_TokenRevocationError(
    get_old_ClassDeclaration_TokenRevocationError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TokenRevocationError": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_TokenRevocationError():
    TypeOnly<current.TokenRevocationError>;
declare function use_old_ClassDeclaration_TokenRevocationError(
    use: TypeOnly<old.TokenRevocationError>): void;
use_old_ClassDeclaration_TokenRevocationError(
    // @ts-expect-error compatibility expected to be broken
    get_current_ClassDeclaration_TokenRevocationError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TokenRevokedError": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_TokenRevokedError():
    TypeOnly<old.TokenRevokedError>;
declare function use_current_ClassDeclaration_TokenRevokedError(
    use: TypeOnly<current.TokenRevokedError>): void;
use_current_ClassDeclaration_TokenRevokedError(
    get_old_ClassDeclaration_TokenRevokedError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TokenRevokedError": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_TokenRevokedError():
    TypeOnly<current.TokenRevokedError>;
declare function use_old_ClassDeclaration_TokenRevokedError(
    use: TypeOnly<old.TokenRevokedError>): void;
use_old_ClassDeclaration_TokenRevokedError(
    // @ts-expect-error compatibility expected to be broken
    get_current_ClassDeclaration_TokenRevokedError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ZookeeperClientConstructor": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ZookeeperClientConstructor():
    TypeOnly<old.ZookeeperClientConstructor>;
declare function use_current_TypeAliasDeclaration_ZookeeperClientConstructor(
    use: TypeOnly<current.ZookeeperClientConstructor>): void;
use_current_TypeAliasDeclaration_ZookeeperClientConstructor(
    get_old_TypeAliasDeclaration_ZookeeperClientConstructor());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ZookeeperClientConstructor": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ZookeeperClientConstructor():
    TypeOnly<current.ZookeeperClientConstructor>;
declare function use_old_TypeAliasDeclaration_ZookeeperClientConstructor(
    use: TypeOnly<old.ZookeeperClientConstructor>): void;
use_old_TypeAliasDeclaration_ZookeeperClientConstructor(
    get_current_TypeAliasDeclaration_ZookeeperClientConstructor());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_calculateRetryIntervalForNetworkError": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_calculateRetryIntervalForNetworkError():
    TypeOnly<typeof old.calculateRetryIntervalForNetworkError>;
declare function use_current_FunctionDeclaration_calculateRetryIntervalForNetworkError(
    use: TypeOnly<typeof current.calculateRetryIntervalForNetworkError>): void;
use_current_FunctionDeclaration_calculateRetryIntervalForNetworkError(
    get_old_FunctionDeclaration_calculateRetryIntervalForNetworkError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_calculateRetryIntervalForNetworkError": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_calculateRetryIntervalForNetworkError():
    TypeOnly<typeof current.calculateRetryIntervalForNetworkError>;
declare function use_old_FunctionDeclaration_calculateRetryIntervalForNetworkError(
    use: TypeOnly<typeof old.calculateRetryIntervalForNetworkError>): void;
use_old_FunctionDeclaration_calculateRetryIntervalForNetworkError(
    get_current_FunctionDeclaration_calculateRetryIntervalForNetworkError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_chooseCelaName": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_chooseCelaName():
    TypeOnly<typeof old.chooseCelaName>;
declare function use_current_VariableDeclaration_chooseCelaName(
    use: TypeOnly<typeof current.chooseCelaName>): void;
use_current_VariableDeclaration_chooseCelaName(
    get_old_VariableDeclaration_chooseCelaName());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_chooseCelaName": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_chooseCelaName():
    TypeOnly<typeof current.chooseCelaName>;
declare function use_old_VariableDeclaration_chooseCelaName(
    use: TypeOnly<typeof old.chooseCelaName>): void;
use_old_VariableDeclaration_chooseCelaName(
    get_current_VariableDeclaration_chooseCelaName());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_clientConnectivityStorageId": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_clientConnectivityStorageId():
    TypeOnly<typeof old.clientConnectivityStorageId>;
declare function use_current_VariableDeclaration_clientConnectivityStorageId(
    use: TypeOnly<typeof current.clientConnectivityStorageId>): void;
use_current_VariableDeclaration_clientConnectivityStorageId(
    get_old_VariableDeclaration_clientConnectivityStorageId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_clientConnectivityStorageId": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_clientConnectivityStorageId():
    TypeOnly<typeof current.clientConnectivityStorageId>;
declare function use_old_VariableDeclaration_clientConnectivityStorageId(
    use: TypeOnly<typeof old.clientConnectivityStorageId>): void;
use_old_VariableDeclaration_clientConnectivityStorageId(
    get_current_VariableDeclaration_clientConnectivityStorageId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createCompositeTokenId": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createCompositeTokenId():
    TypeOnly<typeof old.createCompositeTokenId>;
declare function use_current_FunctionDeclaration_createCompositeTokenId(
    use: TypeOnly<typeof current.createCompositeTokenId>): void;
use_current_FunctionDeclaration_createCompositeTokenId(
    get_old_FunctionDeclaration_createCompositeTokenId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createCompositeTokenId": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createCompositeTokenId():
    TypeOnly<typeof current.createCompositeTokenId>;
declare function use_old_FunctionDeclaration_createCompositeTokenId(
    use: TypeOnly<typeof old.createCompositeTokenId>): void;
use_old_FunctionDeclaration_createCompositeTokenId(
    get_current_FunctionDeclaration_createCompositeTokenId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_extractBoxcar": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_extractBoxcar():
    TypeOnly<typeof old.extractBoxcar>;
declare function use_current_FunctionDeclaration_extractBoxcar(
    use: TypeOnly<typeof current.extractBoxcar>): void;
use_current_FunctionDeclaration_extractBoxcar(
    get_old_FunctionDeclaration_extractBoxcar());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_extractBoxcar": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_extractBoxcar():
    TypeOnly<typeof current.extractBoxcar>;
declare function use_old_FunctionDeclaration_extractBoxcar(
    use: TypeOnly<typeof old.extractBoxcar>): void;
use_old_FunctionDeclaration_extractBoxcar(
    get_current_FunctionDeclaration_extractBoxcar());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_httpUsageStorageId": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_httpUsageStorageId():
    TypeOnly<typeof old.httpUsageStorageId>;
declare function use_current_VariableDeclaration_httpUsageStorageId(
    use: TypeOnly<typeof current.httpUsageStorageId>): void;
use_current_VariableDeclaration_httpUsageStorageId(
    get_old_VariableDeclaration_httpUsageStorageId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_httpUsageStorageId": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_httpUsageStorageId():
    TypeOnly<typeof current.httpUsageStorageId>;
declare function use_old_VariableDeclaration_httpUsageStorageId(
    use: TypeOnly<typeof old.httpUsageStorageId>): void;
use_old_VariableDeclaration_httpUsageStorageId(
    get_current_VariableDeclaration_httpUsageStorageId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isRetryEnabled": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isRetryEnabled():
    TypeOnly<typeof old.isRetryEnabled>;
declare function use_current_FunctionDeclaration_isRetryEnabled(
    use: TypeOnly<typeof current.isRetryEnabled>): void;
use_current_FunctionDeclaration_isRetryEnabled(
    get_old_FunctionDeclaration_isRetryEnabled());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isRetryEnabled": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isRetryEnabled():
    TypeOnly<typeof current.isRetryEnabled>;
declare function use_old_FunctionDeclaration_isRetryEnabled(
    use: TypeOnly<typeof old.isRetryEnabled>): void;
use_old_FunctionDeclaration_isRetryEnabled(
    get_current_FunctionDeclaration_isRetryEnabled());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_requestWithRetry": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_requestWithRetry():
    TypeOnly<typeof old.requestWithRetry>;
declare function use_current_FunctionDeclaration_requestWithRetry(
    use: TypeOnly<typeof current.requestWithRetry>): void;
use_current_FunctionDeclaration_requestWithRetry(
    get_old_FunctionDeclaration_requestWithRetry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_requestWithRetry": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_requestWithRetry():
    TypeOnly<typeof current.requestWithRetry>;
declare function use_old_FunctionDeclaration_requestWithRetry(
    use: TypeOnly<typeof old.requestWithRetry>): void;
use_old_FunctionDeclaration_requestWithRetry(
    get_current_FunctionDeclaration_requestWithRetry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_runWithRetry": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_runWithRetry():
    TypeOnly<typeof old.runWithRetry>;
declare function use_current_FunctionDeclaration_runWithRetry(
    use: TypeOnly<typeof current.runWithRetry>): void;
use_current_FunctionDeclaration_runWithRetry(
    get_old_FunctionDeclaration_runWithRetry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_runWithRetry": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_runWithRetry():
    TypeOnly<typeof current.runWithRetry>;
declare function use_old_FunctionDeclaration_runWithRetry(
    use: TypeOnly<typeof old.runWithRetry>): void;
use_old_FunctionDeclaration_runWithRetry(
    get_current_FunctionDeclaration_runWithRetry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_shouldRetryNetworkError": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_shouldRetryNetworkError():
    TypeOnly<typeof old.shouldRetryNetworkError>;
declare function use_current_FunctionDeclaration_shouldRetryNetworkError(
    use: TypeOnly<typeof current.shouldRetryNetworkError>): void;
use_current_FunctionDeclaration_shouldRetryNetworkError(
    get_old_FunctionDeclaration_shouldRetryNetworkError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_shouldRetryNetworkError": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_shouldRetryNetworkError():
    TypeOnly<typeof current.shouldRetryNetworkError>;
declare function use_old_FunctionDeclaration_shouldRetryNetworkError(
    use: TypeOnly<typeof old.shouldRetryNetworkError>): void;
use_old_FunctionDeclaration_shouldRetryNetworkError(
    get_current_FunctionDeclaration_shouldRetryNetworkError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_signalUsageStorageId": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_signalUsageStorageId():
    TypeOnly<typeof old.signalUsageStorageId>;
declare function use_current_VariableDeclaration_signalUsageStorageId(
    use: TypeOnly<typeof current.signalUsageStorageId>): void;
use_current_VariableDeclaration_signalUsageStorageId(
    get_old_VariableDeclaration_signalUsageStorageId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_signalUsageStorageId": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_signalUsageStorageId():
    TypeOnly<typeof current.signalUsageStorageId>;
declare function use_old_VariableDeclaration_signalUsageStorageId(
    use: TypeOnly<typeof old.signalUsageStorageId>): void;
use_old_VariableDeclaration_signalUsageStorageId(
    get_current_VariableDeclaration_signalUsageStorageId());
