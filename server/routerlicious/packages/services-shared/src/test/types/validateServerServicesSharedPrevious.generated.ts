/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/server-services-shared-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_BasicWebServerFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_BasicWebServerFactory = requireAssignableTo<TypeOnly<old.BasicWebServerFactory>, TypeOnly<current.BasicWebServerFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_BasicWebServerFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_BasicWebServerFactory = requireAssignableTo<TypeOnly<current.BasicWebServerFactory>, TypeOnly<old.BasicWebServerFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ConfigDumper": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_ConfigDumper = requireAssignableTo<TypeOnly<old.ConfigDumper>, TypeOnly<current.ConfigDumper>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ConfigDumper": {"backCompat": false}
 */
declare type current_as_old_for_Class_ConfigDumper = requireAssignableTo<TypeOnly<current.ConfigDumper>, TypeOnly<old.ConfigDumper>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DocumentStorage": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_DocumentStorage = requireAssignableTo<TypeOnly<old.DocumentStorage>, TypeOnly<current.DocumentStorage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DocumentStorage": {"backCompat": false}
 */
declare type current_as_old_for_Class_DocumentStorage = requireAssignableTo<TypeOnly<current.DocumentStorage>, TypeOnly<old.DocumentStorage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_HttpServer": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_HttpServer = requireAssignableTo<TypeOnly<old.HttpServer>, TypeOnly<current.HttpServer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_HttpServer": {"backCompat": false}
 */
declare type current_as_old_for_Class_HttpServer = requireAssignableTo<TypeOnly<current.HttpServer>, TypeOnly<old.HttpServer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_NodeClusterWebServerFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_NodeClusterWebServerFactory = requireAssignableTo<TypeOnly<old.NodeClusterWebServerFactory>, TypeOnly<current.NodeClusterWebServerFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_NodeClusterWebServerFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_NodeClusterWebServerFactory = requireAssignableTo<TypeOnly<current.NodeClusterWebServerFactory>, TypeOnly<old.NodeClusterWebServerFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RedisSocketIoAdapter": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_RedisSocketIoAdapter = requireAssignableTo<TypeOnly<old.RedisSocketIoAdapter>, TypeOnly<current.RedisSocketIoAdapter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RedisSocketIoAdapter": {"backCompat": false}
 */
declare type current_as_old_for_Class_RedisSocketIoAdapter = requireAssignableTo<TypeOnly<current.RedisSocketIoAdapter>, TypeOnly<old.RedisSocketIoAdapter>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RestLessServer": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_RestLessServer = requireAssignableTo<TypeOnly<old.RestLessServer>, TypeOnly<current.RestLessServer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RestLessServer": {"backCompat": false}
 */
declare type current_as_old_for_Class_RestLessServer = requireAssignableTo<TypeOnly<current.RestLessServer>, TypeOnly<old.RestLessServer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SocketIoNodeClusterWebServerFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SocketIoNodeClusterWebServerFactory = requireAssignableTo<TypeOnly<old.SocketIoNodeClusterWebServerFactory>, TypeOnly<current.SocketIoNodeClusterWebServerFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SocketIoNodeClusterWebServerFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_SocketIoNodeClusterWebServerFactory = requireAssignableTo<TypeOnly<current.SocketIoNodeClusterWebServerFactory>, TypeOnly<old.SocketIoNodeClusterWebServerFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SocketIoWebServerFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SocketIoWebServerFactory = requireAssignableTo<TypeOnly<old.SocketIoWebServerFactory>, TypeOnly<current.SocketIoWebServerFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SocketIoWebServerFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_SocketIoWebServerFactory = requireAssignableTo<TypeOnly<current.SocketIoWebServerFactory>, TypeOnly<old.SocketIoWebServerFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_WebServer": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_WebServer = requireAssignableTo<TypeOnly<old.WebServer>, TypeOnly<current.WebServer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_WebServer": {"backCompat": false}
 */
declare type current_as_old_for_Class_WebServer = requireAssignableTo<TypeOnly<current.WebServer>, TypeOnly<old.WebServer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_WholeSummaryReadGitManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_WholeSummaryReadGitManager = requireAssignableTo<TypeOnly<old.WholeSummaryReadGitManager>, TypeOnly<current.WholeSummaryReadGitManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_WholeSummaryReadGitManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_WholeSummaryReadGitManager = requireAssignableTo<TypeOnly<current.WholeSummaryReadGitManager>, TypeOnly<old.WholeSummaryReadGitManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_WholeSummaryWriteGitManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_WholeSummaryWriteGitManager = requireAssignableTo<TypeOnly<old.WholeSummaryWriteGitManager>, TypeOnly<current.WholeSummaryWriteGitManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_WholeSummaryWriteGitManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_WholeSummaryWriteGitManager = requireAssignableTo<TypeOnly<current.WholeSummaryWriteGitManager>, TypeOnly<old.WholeSummaryWriteGitManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_BasicWebServerFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_BasicWebServerFactory = requireAssignableTo<TypeOnly<typeof current.BasicWebServerFactory>, TypeOnly<typeof old.BasicWebServerFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ConfigDumper": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ConfigDumper = requireAssignableTo<TypeOnly<typeof current.ConfigDumper>, TypeOnly<typeof old.ConfigDumper>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DocumentStorage": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DocumentStorage = requireAssignableTo<TypeOnly<typeof current.DocumentStorage>, TypeOnly<typeof old.DocumentStorage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_HttpServer": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_HttpServer = requireAssignableTo<TypeOnly<typeof current.HttpServer>, TypeOnly<typeof old.HttpServer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_NodeClusterWebServerFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_NodeClusterWebServerFactory = requireAssignableTo<TypeOnly<typeof current.NodeClusterWebServerFactory>, TypeOnly<typeof old.NodeClusterWebServerFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_RedisSocketIoAdapter": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_RedisSocketIoAdapter = requireAssignableTo<TypeOnly<typeof current.RedisSocketIoAdapter>, TypeOnly<typeof old.RedisSocketIoAdapter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_RestLessServer": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_RestLessServer = requireAssignableTo<TypeOnly<typeof current.RestLessServer>, TypeOnly<typeof old.RestLessServer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SocketIoNodeClusterWebServerFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SocketIoNodeClusterWebServerFactory = requireAssignableTo<TypeOnly<typeof current.SocketIoNodeClusterWebServerFactory>, TypeOnly<typeof old.SocketIoNodeClusterWebServerFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SocketIoWebServerFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SocketIoWebServerFactory = requireAssignableTo<TypeOnly<typeof current.SocketIoWebServerFactory>, TypeOnly<typeof old.SocketIoWebServerFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_WebServer": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_WebServer = requireAssignableTo<TypeOnly<typeof current.WebServer>, TypeOnly<typeof old.WebServer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_WholeSummaryReadGitManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_WholeSummaryReadGitManager = requireAssignableTo<TypeOnly<typeof current.WholeSummaryReadGitManager>, TypeOnly<typeof old.WholeSummaryReadGitManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_WholeSummaryWriteGitManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_WholeSummaryWriteGitManager = requireAssignableTo<TypeOnly<typeof current.WholeSummaryWriteGitManager>, TypeOnly<typeof old.WholeSummaryWriteGitManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_containsPathTraversal": {"backCompat": false}
 */
declare type current_as_old_for_Function_containsPathTraversal = requireAssignableTo<TypeOnly<typeof current.containsPathTraversal>, TypeOnly<typeof old.containsPathTraversal>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_getBooleanParam": {"backCompat": false}
 */
declare type current_as_old_for_Function_getBooleanParam = requireAssignableTo<TypeOnly<typeof current.getBooleanParam>, TypeOnly<typeof old.getBooleanParam>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_handleResponse": {"backCompat": false}
 */
declare type current_as_old_for_Function_handleResponse = requireAssignableTo<TypeOnly<typeof current.handleResponse>, TypeOnly<typeof old.handleResponse>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_run": {"backCompat": false}
 */
declare type current_as_old_for_Function_run = requireAssignableTo<TypeOnly<typeof current.run>, TypeOnly<typeof old.run>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_runnerHttpServerStop": {"backCompat": false}
 */
declare type current_as_old_for_Function_runnerHttpServerStop = requireAssignableTo<TypeOnly<typeof current.runnerHttpServerStop>, TypeOnly<typeof old.runnerHttpServerStop>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_runService": {"backCompat": false}
 */
declare type current_as_old_for_Function_runService = requireAssignableTo<TypeOnly<typeof current.runService>, TypeOnly<typeof old.runService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_validateRequestParams": {"backCompat": false}
 */
declare type current_as_old_for_Function_validateRequestParams = requireAssignableTo<TypeOnly<typeof current.validateRequestParams>, TypeOnly<typeof old.validateRequestParams>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IHttpServerConfig": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IHttpServerConfig = requireAssignableTo<TypeOnly<old.IHttpServerConfig>, TypeOnly<current.IHttpServerConfig>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IHttpServerConfig": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IHttpServerConfig = requireAssignableTo<TypeOnly<current.IHttpServerConfig>, TypeOnly<old.IHttpServerConfig>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INodeClusterConfig": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_INodeClusterConfig = requireAssignableTo<TypeOnly<old.INodeClusterConfig>, TypeOnly<current.INodeClusterConfig>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INodeClusterConfig": {"backCompat": false}
 */
declare type current_as_old_for_Interface_INodeClusterConfig = requireAssignableTo<TypeOnly<current.INodeClusterConfig>, TypeOnly<old.INodeClusterConfig>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISocketIoRedisConnection": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISocketIoRedisConnection = requireAssignableTo<TypeOnly<old.ISocketIoRedisConnection>, TypeOnly<current.ISocketIoRedisConnection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISocketIoRedisConnection": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISocketIoRedisConnection = requireAssignableTo<TypeOnly<current.ISocketIoRedisConnection>, TypeOnly<old.ISocketIoRedisConnection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISocketIoRedisOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISocketIoRedisOptions = requireAssignableTo<TypeOnly<old.ISocketIoRedisOptions>, TypeOnly<current.ISocketIoRedisOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISocketIoRedisOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISocketIoRedisOptions = requireAssignableTo<TypeOnly<current.ISocketIoRedisOptions>, TypeOnly<old.ISocketIoRedisOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISocketIoRedisSubscriptionConnection": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISocketIoRedisSubscriptionConnection = requireAssignableTo<TypeOnly<old.ISocketIoRedisSubscriptionConnection>, TypeOnly<current.ISocketIoRedisSubscriptionConnection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISocketIoRedisSubscriptionConnection": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISocketIoRedisSubscriptionConnection = requireAssignableTo<TypeOnly<current.ISocketIoRedisSubscriptionConnection>, TypeOnly<old.ISocketIoRedisSubscriptionConnection>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_RequestListener": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_RequestListener = requireAssignableTo<TypeOnly<old.RequestListener>, TypeOnly<current.RequestListener>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_RequestListener": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_RequestListener = requireAssignableTo<TypeOnly<current.RequestListener>, TypeOnly<old.RequestListener>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SocketIoAdapterCreator": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_SocketIoAdapterCreator = requireAssignableTo<TypeOnly<old.SocketIoAdapterCreator>, TypeOnly<current.SocketIoAdapterCreator>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_SocketIoAdapterCreator": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_SocketIoAdapterCreator = requireAssignableTo<TypeOnly<current.SocketIoAdapterCreator>, TypeOnly<old.SocketIoAdapterCreator>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_decodeHeader": {"backCompat": false}
 */
declare type current_as_old_for_Variable_decodeHeader = requireAssignableTo<TypeOnly<typeof current.decodeHeader>, TypeOnly<typeof old.decodeHeader>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_defaultErrorMessage": {"backCompat": false}
 */
declare type current_as_old_for_Variable_defaultErrorMessage = requireAssignableTo<TypeOnly<typeof current.defaultErrorMessage>, TypeOnly<typeof old.defaultErrorMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_IsEphemeralContainer": {"backCompat": false}
 */
declare type current_as_old_for_Variable_IsEphemeralContainer = requireAssignableTo<TypeOnly<typeof current.IsEphemeralContainer>, TypeOnly<typeof old.IsEphemeralContainer>>
