/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/server-lambdas-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_BroadcasterLambda": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_BroadcasterLambda = requireAssignableTo<TypeOnly<old.BroadcasterLambda>, TypeOnly<current.BroadcasterLambda>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_BroadcasterLambda": {"backCompat": false}
 */
declare type current_as_old_for_Class_BroadcasterLambda = requireAssignableTo<TypeOnly<current.BroadcasterLambda>, TypeOnly<old.BroadcasterLambda>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_BroadcasterLambdaFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_BroadcasterLambdaFactory = requireAssignableTo<TypeOnly<old.BroadcasterLambdaFactory>, TypeOnly<current.BroadcasterLambdaFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_BroadcasterLambdaFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_BroadcasterLambdaFactory = requireAssignableTo<TypeOnly<current.BroadcasterLambdaFactory>, TypeOnly<old.BroadcasterLambdaFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_CheckpointManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_CheckpointManager = requireAssignableTo<TypeOnly<old.CheckpointManager>, TypeOnly<current.CheckpointManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_CheckpointManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_CheckpointManager = requireAssignableTo<TypeOnly<current.CheckpointManager>, TypeOnly<old.CheckpointManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_CopierLambda": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_CopierLambda = requireAssignableTo<TypeOnly<old.CopierLambda>, TypeOnly<current.CopierLambda>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_CopierLambda": {"backCompat": false}
 */
declare type current_as_old_for_Class_CopierLambda = requireAssignableTo<TypeOnly<current.CopierLambda>, TypeOnly<old.CopierLambda>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_CopierLambdaFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_CopierLambdaFactory = requireAssignableTo<TypeOnly<old.CopierLambdaFactory>, TypeOnly<current.CopierLambdaFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_CopierLambdaFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_CopierLambdaFactory = requireAssignableTo<TypeOnly<current.CopierLambdaFactory>, TypeOnly<old.CopierLambdaFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DeliLambda": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_DeliLambda = requireAssignableTo<TypeOnly<old.DeliLambda>, TypeOnly<current.DeliLambda>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DeliLambda": {"backCompat": false}
 */
declare type current_as_old_for_Class_DeliLambda = requireAssignableTo<TypeOnly<current.DeliLambda>, TypeOnly<old.DeliLambda>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DeliLambdaFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_DeliLambdaFactory = requireAssignableTo<TypeOnly<old.DeliLambdaFactory>, TypeOnly<current.DeliLambdaFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DeliLambdaFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_DeliLambdaFactory = requireAssignableTo<TypeOnly<current.DeliLambdaFactory>, TypeOnly<old.DeliLambdaFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DocumentCheckpointManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_DocumentCheckpointManager = requireAssignableTo<TypeOnly<old.DocumentCheckpointManager>, TypeOnly<current.DocumentCheckpointManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DocumentCheckpointManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_DocumentCheckpointManager = requireAssignableTo<TypeOnly<current.DocumentCheckpointManager>, TypeOnly<old.DocumentCheckpointManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MoiraLambda": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_MoiraLambda = requireAssignableTo<TypeOnly<old.MoiraLambda>, TypeOnly<current.MoiraLambda>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MoiraLambda": {"backCompat": false}
 */
declare type current_as_old_for_Class_MoiraLambda = requireAssignableTo<TypeOnly<current.MoiraLambda>, TypeOnly<old.MoiraLambda>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MoiraLambdaFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_MoiraLambdaFactory = requireAssignableTo<TypeOnly<old.MoiraLambdaFactory>, TypeOnly<current.MoiraLambdaFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_MoiraLambdaFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_MoiraLambdaFactory = requireAssignableTo<TypeOnly<current.MoiraLambdaFactory>, TypeOnly<old.MoiraLambdaFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_NoOpLambda": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_NoOpLambda = requireAssignableTo<TypeOnly<old.NoOpLambda>, TypeOnly<current.NoOpLambda>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_NoOpLambda": {"backCompat": false}
 */
declare type current_as_old_for_Class_NoOpLambda = requireAssignableTo<TypeOnly<current.NoOpLambda>, TypeOnly<old.NoOpLambda>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ScribeLambda": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_ScribeLambda = requireAssignableTo<TypeOnly<old.ScribeLambda>, TypeOnly<current.ScribeLambda>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ScribeLambda": {"backCompat": false}
 */
declare type current_as_old_for_Class_ScribeLambda = requireAssignableTo<TypeOnly<current.ScribeLambda>, TypeOnly<old.ScribeLambda>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ScribeLambdaFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_ScribeLambdaFactory = requireAssignableTo<TypeOnly<old.ScribeLambdaFactory>, TypeOnly<current.ScribeLambdaFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ScribeLambdaFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_ScribeLambdaFactory = requireAssignableTo<TypeOnly<current.ScribeLambdaFactory>, TypeOnly<old.ScribeLambdaFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ScriptoriumLambda": {"forwardCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type old_as_current_for_Class_ScriptoriumLambda = requireAssignableTo<TypeOnly<old.ScriptoriumLambda>, TypeOnly<current.ScriptoriumLambda>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ScriptoriumLambda": {"backCompat": false}
 */
declare type current_as_old_for_Class_ScriptoriumLambda = requireAssignableTo<TypeOnly<current.ScriptoriumLambda>, TypeOnly<old.ScriptoriumLambda>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ScriptoriumLambdaFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_ScriptoriumLambdaFactory = requireAssignableTo<TypeOnly<old.ScriptoriumLambdaFactory>, TypeOnly<current.ScriptoriumLambdaFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ScriptoriumLambdaFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_ScriptoriumLambdaFactory = requireAssignableTo<TypeOnly<current.ScriptoriumLambdaFactory>, TypeOnly<old.ScriptoriumLambdaFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SummaryReader": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SummaryReader = requireAssignableTo<TypeOnly<old.SummaryReader>, TypeOnly<current.SummaryReader>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SummaryReader": {"backCompat": false}
 */
declare type current_as_old_for_Class_SummaryReader = requireAssignableTo<TypeOnly<current.SummaryReader>, TypeOnly<old.SummaryReader>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SummaryWriter": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SummaryWriter = requireAssignableTo<TypeOnly<old.SummaryWriter>, TypeOnly<current.SummaryWriter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SummaryWriter": {"backCompat": false}
 */
declare type current_as_old_for_Class_SummaryWriter = requireAssignableTo<TypeOnly<current.SummaryWriter>, TypeOnly<old.SummaryWriter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_BroadcasterLambda": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_BroadcasterLambda = requireAssignableTo<TypeOnly<typeof current.BroadcasterLambda>, TypeOnly<typeof old.BroadcasterLambda>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_BroadcasterLambdaFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_BroadcasterLambdaFactory = requireAssignableTo<TypeOnly<typeof current.BroadcasterLambdaFactory>, TypeOnly<typeof old.BroadcasterLambdaFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_CheckpointManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_CheckpointManager = requireAssignableTo<TypeOnly<typeof current.CheckpointManager>, TypeOnly<typeof old.CheckpointManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_CopierLambda": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_CopierLambda = requireAssignableTo<TypeOnly<typeof current.CopierLambda>, TypeOnly<typeof old.CopierLambda>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_CopierLambdaFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_CopierLambdaFactory = requireAssignableTo<TypeOnly<typeof current.CopierLambdaFactory>, TypeOnly<typeof old.CopierLambdaFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DeliLambda": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DeliLambda = requireAssignableTo<TypeOnly<typeof current.DeliLambda>, TypeOnly<typeof old.DeliLambda>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DeliLambdaFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DeliLambdaFactory = requireAssignableTo<TypeOnly<typeof current.DeliLambdaFactory>, TypeOnly<typeof old.DeliLambdaFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DocumentCheckpointManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DocumentCheckpointManager = requireAssignableTo<TypeOnly<typeof current.DocumentCheckpointManager>, TypeOnly<typeof old.DocumentCheckpointManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_MoiraLambda": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_MoiraLambda = requireAssignableTo<TypeOnly<typeof current.MoiraLambda>, TypeOnly<typeof old.MoiraLambda>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_MoiraLambdaFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_MoiraLambdaFactory = requireAssignableTo<TypeOnly<typeof current.MoiraLambdaFactory>, TypeOnly<typeof old.MoiraLambdaFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_NoOpLambda": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_NoOpLambda = requireAssignableTo<TypeOnly<typeof current.NoOpLambda>, TypeOnly<typeof old.NoOpLambda>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ScribeLambda": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ScribeLambda = requireAssignableTo<TypeOnly<typeof current.ScribeLambda>, TypeOnly<typeof old.ScribeLambda>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ScribeLambdaFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ScribeLambdaFactory = requireAssignableTo<TypeOnly<typeof current.ScribeLambdaFactory>, TypeOnly<typeof old.ScribeLambdaFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ScriptoriumLambda": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ScriptoriumLambda = requireAssignableTo<TypeOnly<typeof current.ScriptoriumLambda>, TypeOnly<typeof old.ScriptoriumLambda>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ScriptoriumLambdaFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ScriptoriumLambdaFactory = requireAssignableTo<TypeOnly<typeof current.ScriptoriumLambdaFactory>, TypeOnly<typeof old.ScriptoriumLambdaFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SummaryReader": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SummaryReader = requireAssignableTo<TypeOnly<typeof current.SummaryReader>, TypeOnly<typeof old.SummaryReader>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SummaryWriter": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SummaryWriter = requireAssignableTo<TypeOnly<typeof current.SummaryWriter>, TypeOnly<typeof old.SummaryWriter>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_OpEventType": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_OpEventType = requireAssignableTo<TypeOnly<old.OpEventType>, TypeOnly<current.OpEventType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_OpEventType": {"backCompat": false}
 */
declare type current_as_old_for_Enum_OpEventType = requireAssignableTo<TypeOnly<current.OpEventType>, TypeOnly<old.OpEventType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_configureWebSocketServices": {"backCompat": false}
 */
declare type current_as_old_for_Function_configureWebSocketServices = requireAssignableTo<TypeOnly<typeof current.configureWebSocketServices>, TypeOnly<typeof old.configureWebSocketServices>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createDeliCheckpointManagerFromCollection": {"backCompat": false}
 */
declare type current_as_old_for_Function_createDeliCheckpointManagerFromCollection = requireAssignableTo<TypeOnly<typeof current.createDeliCheckpointManagerFromCollection>, TypeOnly<typeof old.createDeliCheckpointManagerFromCollection>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createRoomJoinMessage": {"backCompat": false}
 */
declare type current_as_old_for_Function_createRoomJoinMessage = requireAssignableTo<TypeOnly<typeof current.createRoomJoinMessage>, TypeOnly<typeof old.createRoomJoinMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_isDocumentSessionValid": {"backCompat": false}
 */
declare type current_as_old_for_Function_isDocumentSessionValid = requireAssignableTo<TypeOnly<typeof current.isDocumentSessionValid>, TypeOnly<typeof old.isDocumentSessionValid>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_isDocumentValid": {"backCompat": false}
 */
declare type current_as_old_for_Function_isDocumentValid = requireAssignableTo<TypeOnly<typeof current.isDocumentValid>, TypeOnly<typeof old.isDocumentValid>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IBroadcastSignalEventPayload": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IBroadcastSignalEventPayload = requireAssignableTo<TypeOnly<old.IBroadcastSignalEventPayload>, TypeOnly<current.IBroadcastSignalEventPayload>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IBroadcastSignalEventPayload": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IBroadcastSignalEventPayload = requireAssignableTo<TypeOnly<current.IBroadcastSignalEventPayload>, TypeOnly<old.IBroadcastSignalEventPayload>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICheckpointManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ICheckpointManager = requireAssignableTo<TypeOnly<old.ICheckpointManager>, TypeOnly<current.ICheckpointManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICheckpointManager": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ICheckpointManager = requireAssignableTo<TypeOnly<current.ICheckpointManager>, TypeOnly<old.ICheckpointManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICheckpointParams": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ICheckpointParams = requireAssignableTo<TypeOnly<old.ICheckpointParams>, TypeOnly<current.ICheckpointParams>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICheckpointParams": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ICheckpointParams = requireAssignableTo<TypeOnly<current.ICheckpointParams>, TypeOnly<old.ICheckpointParams>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICollaborationSessionEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ICollaborationSessionEvents = requireAssignableTo<TypeOnly<old.ICollaborationSessionEvents>, TypeOnly<current.ICollaborationSessionEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICollaborationSessionEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ICollaborationSessionEvents = requireAssignableTo<TypeOnly<current.ICollaborationSessionEvents>, TypeOnly<old.ICollaborationSessionEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDeliCheckpointManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDeliCheckpointManager = requireAssignableTo<TypeOnly<old.IDeliCheckpointManager>, TypeOnly<current.IDeliCheckpointManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDeliCheckpointManager": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDeliCheckpointManager = requireAssignableTo<TypeOnly<current.IDeliCheckpointManager>, TypeOnly<old.IDeliCheckpointManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDeliLambdaEvents": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IDeliLambdaEvents = requireAssignableTo<TypeOnly<old.IDeliLambdaEvents>, TypeOnly<current.IDeliLambdaEvents>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IDeliLambdaEvents": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IDeliLambdaEvents = requireAssignableTo<TypeOnly<current.IDeliLambdaEvents>, TypeOnly<old.IDeliLambdaEvents>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILatestSummaryState": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ILatestSummaryState = requireAssignableTo<TypeOnly<old.ILatestSummaryState>, TypeOnly<current.ILatestSummaryState>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILatestSummaryState": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ILatestSummaryState = requireAssignableTo<TypeOnly<current.ILatestSummaryState>, TypeOnly<old.ILatestSummaryState>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPendingMessageReader": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IPendingMessageReader = requireAssignableTo<TypeOnly<old.IPendingMessageReader>, TypeOnly<current.IPendingMessageReader>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPendingMessageReader": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IPendingMessageReader = requireAssignableTo<TypeOnly<current.IPendingMessageReader>, TypeOnly<old.IPendingMessageReader>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRoom": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRoom = requireAssignableTo<TypeOnly<old.IRoom>, TypeOnly<current.IRoom>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRoom": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRoom = requireAssignableTo<TypeOnly<current.IRoom>, TypeOnly<old.IRoom>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRuntimeSignalEnvelope": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRuntimeSignalEnvelope = requireAssignableTo<TypeOnly<old.IRuntimeSignalEnvelope>, TypeOnly<current.IRuntimeSignalEnvelope>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRuntimeSignalEnvelope": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRuntimeSignalEnvelope = requireAssignableTo<TypeOnly<current.IRuntimeSignalEnvelope>, TypeOnly<old.IRuntimeSignalEnvelope>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryReader": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryReader = requireAssignableTo<TypeOnly<old.ISummaryReader>, TypeOnly<current.ISummaryReader>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryReader": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryReader = requireAssignableTo<TypeOnly<current.ISummaryReader>, TypeOnly<old.ISummaryReader>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryWriter": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryWriter = requireAssignableTo<TypeOnly<old.ISummaryWriter>, TypeOnly<current.ISummaryWriter>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryWriter": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryWriter = requireAssignableTo<TypeOnly<current.ISummaryWriter>, TypeOnly<old.ISummaryWriter>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryWriteResponse": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryWriteResponse = requireAssignableTo<TypeOnly<old.ISummaryWriteResponse>, TypeOnly<current.ISummaryWriteResponse>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryWriteResponse": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryWriteResponse = requireAssignableTo<TypeOnly<current.ISummaryWriteResponse>, TypeOnly<old.ISummaryWriteResponse>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_NoOpLambdaCheckpointConfiguration": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_NoOpLambdaCheckpointConfiguration = requireAssignableTo<TypeOnly<old.NoOpLambdaCheckpointConfiguration>, TypeOnly<current.NoOpLambdaCheckpointConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_NoOpLambdaCheckpointConfiguration": {"backCompat": false}
 */
declare type current_as_old_for_Interface_NoOpLambdaCheckpointConfiguration = requireAssignableTo<TypeOnly<current.NoOpLambdaCheckpointConfiguration>, TypeOnly<old.NoOpLambdaCheckpointConfiguration>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_createNackMessage": {"backCompat": false}
 */
declare type current_as_old_for_Variable_createNackMessage = requireAssignableTo<TypeOnly<typeof current.createNackMessage>, TypeOnly<typeof old.createNackMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_createRoomLeaveMessage": {"backCompat": false}
 */
declare type current_as_old_for_Variable_createRoomLeaveMessage = requireAssignableTo<TypeOnly<typeof current.createRoomLeaveMessage>, TypeOnly<typeof old.createRoomLeaveMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_createSessionMetric": {"backCompat": false}
 */
declare type current_as_old_for_Variable_createSessionMetric = requireAssignableTo<TypeOnly<typeof current.createSessionMetric>, TypeOnly<typeof old.createSessionMetric>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_generateClientId": {"backCompat": false}
 */
declare type current_as_old_for_Variable_generateClientId = requireAssignableTo<TypeOnly<typeof current.generateClientId>, TypeOnly<typeof old.generateClientId>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_logCommonSessionEndMetrics": {"backCompat": false}
 */
declare type current_as_old_for_Variable_logCommonSessionEndMetrics = requireAssignableTo<TypeOnly<typeof current.logCommonSessionEndMetrics>, TypeOnly<typeof old.logCommonSessionEndMetrics>>
