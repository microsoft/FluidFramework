/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-test-generator in @fluidframework/build-tools.
 */

import type * as old from "@fluidframework/server-lambdas-previous";
import type * as current from "../../index.js";


// See 'build-tools/src/type-test-generator/compatibility.ts' for more information.
type TypeOnly<T> = T extends number
	? number
	: T extends string
	? string
	: T extends boolean | bigint | symbol
	? T
	: {
			[P in keyof T]: TypeOnly<T[P]>;
	  };

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BroadcasterLambda": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_BroadcasterLambda():
    TypeOnly<old.BroadcasterLambda>;
declare function use_current_ClassDeclaration_BroadcasterLambda(
    use: TypeOnly<current.BroadcasterLambda>): void;
use_current_ClassDeclaration_BroadcasterLambda(
    get_old_ClassDeclaration_BroadcasterLambda());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BroadcasterLambda": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_BroadcasterLambda():
    TypeOnly<current.BroadcasterLambda>;
declare function use_old_ClassDeclaration_BroadcasterLambda(
    use: TypeOnly<old.BroadcasterLambda>): void;
use_old_ClassDeclaration_BroadcasterLambda(
    get_current_ClassDeclaration_BroadcasterLambda());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BroadcasterLambdaFactory": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_BroadcasterLambdaFactory():
    TypeOnly<old.BroadcasterLambdaFactory>;
declare function use_current_ClassDeclaration_BroadcasterLambdaFactory(
    use: TypeOnly<current.BroadcasterLambdaFactory>): void;
use_current_ClassDeclaration_BroadcasterLambdaFactory(
    get_old_ClassDeclaration_BroadcasterLambdaFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BroadcasterLambdaFactory": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_BroadcasterLambdaFactory():
    TypeOnly<current.BroadcasterLambdaFactory>;
declare function use_old_ClassDeclaration_BroadcasterLambdaFactory(
    use: TypeOnly<old.BroadcasterLambdaFactory>): void;
use_old_ClassDeclaration_BroadcasterLambdaFactory(
    get_current_ClassDeclaration_BroadcasterLambdaFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_CheckpointManager": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_CheckpointManager():
    TypeOnly<old.CheckpointManager>;
declare function use_current_ClassDeclaration_CheckpointManager(
    use: TypeOnly<current.CheckpointManager>): void;
use_current_ClassDeclaration_CheckpointManager(
    get_old_ClassDeclaration_CheckpointManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_CheckpointManager": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_CheckpointManager():
    TypeOnly<current.CheckpointManager>;
declare function use_old_ClassDeclaration_CheckpointManager(
    use: TypeOnly<old.CheckpointManager>): void;
use_old_ClassDeclaration_CheckpointManager(
    get_current_ClassDeclaration_CheckpointManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_CopierLambda": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_CopierLambda():
    TypeOnly<old.CopierLambda>;
declare function use_current_ClassDeclaration_CopierLambda(
    use: TypeOnly<current.CopierLambda>): void;
use_current_ClassDeclaration_CopierLambda(
    get_old_ClassDeclaration_CopierLambda());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_CopierLambda": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_CopierLambda():
    TypeOnly<current.CopierLambda>;
declare function use_old_ClassDeclaration_CopierLambda(
    use: TypeOnly<old.CopierLambda>): void;
use_old_ClassDeclaration_CopierLambda(
    get_current_ClassDeclaration_CopierLambda());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_CopierLambdaFactory": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_CopierLambdaFactory():
    TypeOnly<old.CopierLambdaFactory>;
declare function use_current_ClassDeclaration_CopierLambdaFactory(
    use: TypeOnly<current.CopierLambdaFactory>): void;
use_current_ClassDeclaration_CopierLambdaFactory(
    get_old_ClassDeclaration_CopierLambdaFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_CopierLambdaFactory": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_CopierLambdaFactory():
    TypeOnly<current.CopierLambdaFactory>;
declare function use_old_ClassDeclaration_CopierLambdaFactory(
    use: TypeOnly<old.CopierLambdaFactory>): void;
use_old_ClassDeclaration_CopierLambdaFactory(
    get_current_ClassDeclaration_CopierLambdaFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DeliLambda": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_DeliLambda():
    TypeOnly<old.DeliLambda>;
declare function use_current_ClassDeclaration_DeliLambda(
    use: TypeOnly<current.DeliLambda>): void;
use_current_ClassDeclaration_DeliLambda(
    get_old_ClassDeclaration_DeliLambda());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DeliLambda": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_DeliLambda():
    TypeOnly<current.DeliLambda>;
declare function use_old_ClassDeclaration_DeliLambda(
    use: TypeOnly<old.DeliLambda>): void;
use_old_ClassDeclaration_DeliLambda(
    get_current_ClassDeclaration_DeliLambda());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DeliLambdaFactory": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_DeliLambdaFactory():
    TypeOnly<old.DeliLambdaFactory>;
declare function use_current_ClassDeclaration_DeliLambdaFactory(
    use: TypeOnly<current.DeliLambdaFactory>): void;
use_current_ClassDeclaration_DeliLambdaFactory(
    get_old_ClassDeclaration_DeliLambdaFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DeliLambdaFactory": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_DeliLambdaFactory():
    TypeOnly<current.DeliLambdaFactory>;
declare function use_old_ClassDeclaration_DeliLambdaFactory(
    use: TypeOnly<old.DeliLambdaFactory>): void;
use_old_ClassDeclaration_DeliLambdaFactory(
    get_current_ClassDeclaration_DeliLambdaFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DocumentCheckpointManager": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_DocumentCheckpointManager():
    TypeOnly<old.DocumentCheckpointManager>;
declare function use_current_ClassDeclaration_DocumentCheckpointManager(
    use: TypeOnly<current.DocumentCheckpointManager>): void;
use_current_ClassDeclaration_DocumentCheckpointManager(
    get_old_ClassDeclaration_DocumentCheckpointManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DocumentCheckpointManager": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_DocumentCheckpointManager():
    TypeOnly<current.DocumentCheckpointManager>;
declare function use_old_ClassDeclaration_DocumentCheckpointManager(
    use: TypeOnly<old.DocumentCheckpointManager>): void;
use_old_ClassDeclaration_DocumentCheckpointManager(
    get_current_ClassDeclaration_DocumentCheckpointManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBroadcastSignalEventPayload": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IBroadcastSignalEventPayload():
    TypeOnly<old.IBroadcastSignalEventPayload>;
declare function use_current_InterfaceDeclaration_IBroadcastSignalEventPayload(
    use: TypeOnly<current.IBroadcastSignalEventPayload>): void;
use_current_InterfaceDeclaration_IBroadcastSignalEventPayload(
    get_old_InterfaceDeclaration_IBroadcastSignalEventPayload());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IBroadcastSignalEventPayload": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IBroadcastSignalEventPayload():
    TypeOnly<current.IBroadcastSignalEventPayload>;
declare function use_old_InterfaceDeclaration_IBroadcastSignalEventPayload(
    use: TypeOnly<old.IBroadcastSignalEventPayload>): void;
use_old_InterfaceDeclaration_IBroadcastSignalEventPayload(
    get_current_InterfaceDeclaration_IBroadcastSignalEventPayload());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICheckpointManager": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICheckpointManager():
    TypeOnly<old.ICheckpointManager>;
declare function use_current_InterfaceDeclaration_ICheckpointManager(
    use: TypeOnly<current.ICheckpointManager>): void;
use_current_InterfaceDeclaration_ICheckpointManager(
    get_old_InterfaceDeclaration_ICheckpointManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICheckpointManager": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICheckpointManager():
    TypeOnly<current.ICheckpointManager>;
declare function use_old_InterfaceDeclaration_ICheckpointManager(
    use: TypeOnly<old.ICheckpointManager>): void;
use_old_InterfaceDeclaration_ICheckpointManager(
    get_current_InterfaceDeclaration_ICheckpointManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICheckpointParams": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICheckpointParams():
    TypeOnly<old.ICheckpointParams>;
declare function use_current_InterfaceDeclaration_ICheckpointParams(
    use: TypeOnly<current.ICheckpointParams>): void;
use_current_InterfaceDeclaration_ICheckpointParams(
    get_old_InterfaceDeclaration_ICheckpointParams());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICheckpointParams": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICheckpointParams():
    TypeOnly<current.ICheckpointParams>;
declare function use_old_InterfaceDeclaration_ICheckpointParams(
    use: TypeOnly<old.ICheckpointParams>): void;
use_old_InterfaceDeclaration_ICheckpointParams(
    get_current_InterfaceDeclaration_ICheckpointParams());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICollaborationSessionEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICollaborationSessionEvents():
    TypeOnly<old.ICollaborationSessionEvents>;
declare function use_current_InterfaceDeclaration_ICollaborationSessionEvents(
    use: TypeOnly<current.ICollaborationSessionEvents>): void;
use_current_InterfaceDeclaration_ICollaborationSessionEvents(
    get_old_InterfaceDeclaration_ICollaborationSessionEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICollaborationSessionEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICollaborationSessionEvents():
    TypeOnly<current.ICollaborationSessionEvents>;
declare function use_old_InterfaceDeclaration_ICollaborationSessionEvents(
    use: TypeOnly<old.ICollaborationSessionEvents>): void;
use_old_InterfaceDeclaration_ICollaborationSessionEvents(
    get_current_InterfaceDeclaration_ICollaborationSessionEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeliCheckpointManager": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDeliCheckpointManager():
    TypeOnly<old.IDeliCheckpointManager>;
declare function use_current_InterfaceDeclaration_IDeliCheckpointManager(
    use: TypeOnly<current.IDeliCheckpointManager>): void;
use_current_InterfaceDeclaration_IDeliCheckpointManager(
    get_old_InterfaceDeclaration_IDeliCheckpointManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeliCheckpointManager": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDeliCheckpointManager():
    TypeOnly<current.IDeliCheckpointManager>;
declare function use_old_InterfaceDeclaration_IDeliCheckpointManager(
    use: TypeOnly<old.IDeliCheckpointManager>): void;
use_old_InterfaceDeclaration_IDeliCheckpointManager(
    get_current_InterfaceDeclaration_IDeliCheckpointManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeliLambdaEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDeliLambdaEvents():
    TypeOnly<old.IDeliLambdaEvents>;
declare function use_current_InterfaceDeclaration_IDeliLambdaEvents(
    use: TypeOnly<current.IDeliLambdaEvents>): void;
use_current_InterfaceDeclaration_IDeliLambdaEvents(
    get_old_InterfaceDeclaration_IDeliLambdaEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeliLambdaEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDeliLambdaEvents():
    TypeOnly<current.IDeliLambdaEvents>;
declare function use_old_InterfaceDeclaration_IDeliLambdaEvents(
    use: TypeOnly<old.IDeliLambdaEvents>): void;
use_old_InterfaceDeclaration_IDeliLambdaEvents(
    get_current_InterfaceDeclaration_IDeliLambdaEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ILatestSummaryState": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ILatestSummaryState():
    TypeOnly<old.ILatestSummaryState>;
declare function use_current_InterfaceDeclaration_ILatestSummaryState(
    use: TypeOnly<current.ILatestSummaryState>): void;
use_current_InterfaceDeclaration_ILatestSummaryState(
    get_old_InterfaceDeclaration_ILatestSummaryState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ILatestSummaryState": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ILatestSummaryState():
    TypeOnly<current.ILatestSummaryState>;
declare function use_old_InterfaceDeclaration_ILatestSummaryState(
    use: TypeOnly<old.ILatestSummaryState>): void;
use_old_InterfaceDeclaration_ILatestSummaryState(
    get_current_InterfaceDeclaration_ILatestSummaryState());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPendingMessageReader": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPendingMessageReader():
    TypeOnly<old.IPendingMessageReader>;
declare function use_current_InterfaceDeclaration_IPendingMessageReader(
    use: TypeOnly<current.IPendingMessageReader>): void;
use_current_InterfaceDeclaration_IPendingMessageReader(
    get_old_InterfaceDeclaration_IPendingMessageReader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPendingMessageReader": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPendingMessageReader():
    TypeOnly<current.IPendingMessageReader>;
declare function use_old_InterfaceDeclaration_IPendingMessageReader(
    use: TypeOnly<old.IPendingMessageReader>): void;
use_old_InterfaceDeclaration_IPendingMessageReader(
    get_current_InterfaceDeclaration_IPendingMessageReader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRoom": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRoom():
    TypeOnly<old.IRoom>;
declare function use_current_InterfaceDeclaration_IRoom(
    use: TypeOnly<current.IRoom>): void;
use_current_InterfaceDeclaration_IRoom(
    get_old_InterfaceDeclaration_IRoom());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRoom": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRoom():
    TypeOnly<current.IRoom>;
declare function use_old_InterfaceDeclaration_IRoom(
    use: TypeOnly<old.IRoom>): void;
use_old_InterfaceDeclaration_IRoom(
    get_current_InterfaceDeclaration_IRoom());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRuntimeSignalEnvelope": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRuntimeSignalEnvelope():
    TypeOnly<old.IRuntimeSignalEnvelope>;
declare function use_current_InterfaceDeclaration_IRuntimeSignalEnvelope(
    use: TypeOnly<current.IRuntimeSignalEnvelope>): void;
use_current_InterfaceDeclaration_IRuntimeSignalEnvelope(
    get_old_InterfaceDeclaration_IRuntimeSignalEnvelope());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRuntimeSignalEnvelope": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRuntimeSignalEnvelope():
    TypeOnly<current.IRuntimeSignalEnvelope>;
declare function use_old_InterfaceDeclaration_IRuntimeSignalEnvelope(
    use: TypeOnly<old.IRuntimeSignalEnvelope>): void;
use_old_InterfaceDeclaration_IRuntimeSignalEnvelope(
    get_current_InterfaceDeclaration_IRuntimeSignalEnvelope());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryReader": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryReader():
    TypeOnly<old.ISummaryReader>;
declare function use_current_InterfaceDeclaration_ISummaryReader(
    use: TypeOnly<current.ISummaryReader>): void;
use_current_InterfaceDeclaration_ISummaryReader(
    get_old_InterfaceDeclaration_ISummaryReader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryReader": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryReader():
    TypeOnly<current.ISummaryReader>;
declare function use_old_InterfaceDeclaration_ISummaryReader(
    use: TypeOnly<old.ISummaryReader>): void;
use_old_InterfaceDeclaration_ISummaryReader(
    get_current_InterfaceDeclaration_ISummaryReader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryWriteResponse": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryWriteResponse():
    TypeOnly<old.ISummaryWriteResponse>;
declare function use_current_InterfaceDeclaration_ISummaryWriteResponse(
    use: TypeOnly<current.ISummaryWriteResponse>): void;
use_current_InterfaceDeclaration_ISummaryWriteResponse(
    get_old_InterfaceDeclaration_ISummaryWriteResponse());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryWriteResponse": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryWriteResponse():
    TypeOnly<current.ISummaryWriteResponse>;
declare function use_old_InterfaceDeclaration_ISummaryWriteResponse(
    use: TypeOnly<old.ISummaryWriteResponse>): void;
use_old_InterfaceDeclaration_ISummaryWriteResponse(
    get_current_InterfaceDeclaration_ISummaryWriteResponse());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryWriter": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryWriter():
    TypeOnly<old.ISummaryWriter>;
declare function use_current_InterfaceDeclaration_ISummaryWriter(
    use: TypeOnly<current.ISummaryWriter>): void;
use_current_InterfaceDeclaration_ISummaryWriter(
    get_old_InterfaceDeclaration_ISummaryWriter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryWriter": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryWriter():
    TypeOnly<current.ISummaryWriter>;
declare function use_old_InterfaceDeclaration_ISummaryWriter(
    use: TypeOnly<old.ISummaryWriter>): void;
use_old_InterfaceDeclaration_ISummaryWriter(
    get_current_InterfaceDeclaration_ISummaryWriter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MoiraLambda": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_MoiraLambda():
    TypeOnly<old.MoiraLambda>;
declare function use_current_ClassDeclaration_MoiraLambda(
    use: TypeOnly<current.MoiraLambda>): void;
use_current_ClassDeclaration_MoiraLambda(
    get_old_ClassDeclaration_MoiraLambda());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MoiraLambda": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_MoiraLambda():
    TypeOnly<current.MoiraLambda>;
declare function use_old_ClassDeclaration_MoiraLambda(
    use: TypeOnly<old.MoiraLambda>): void;
use_old_ClassDeclaration_MoiraLambda(
    get_current_ClassDeclaration_MoiraLambda());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MoiraLambdaFactory": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_MoiraLambdaFactory():
    TypeOnly<old.MoiraLambdaFactory>;
declare function use_current_ClassDeclaration_MoiraLambdaFactory(
    use: TypeOnly<current.MoiraLambdaFactory>): void;
use_current_ClassDeclaration_MoiraLambdaFactory(
    get_old_ClassDeclaration_MoiraLambdaFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MoiraLambdaFactory": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_MoiraLambdaFactory():
    TypeOnly<current.MoiraLambdaFactory>;
declare function use_old_ClassDeclaration_MoiraLambdaFactory(
    use: TypeOnly<old.MoiraLambdaFactory>): void;
use_old_ClassDeclaration_MoiraLambdaFactory(
    get_current_ClassDeclaration_MoiraLambdaFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_NoOpLambda": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_NoOpLambda():
    TypeOnly<old.NoOpLambda>;
declare function use_current_ClassDeclaration_NoOpLambda(
    use: TypeOnly<current.NoOpLambda>): void;
use_current_ClassDeclaration_NoOpLambda(
    get_old_ClassDeclaration_NoOpLambda());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_NoOpLambda": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_NoOpLambda():
    TypeOnly<current.NoOpLambda>;
declare function use_old_ClassDeclaration_NoOpLambda(
    use: TypeOnly<old.NoOpLambda>): void;
use_old_ClassDeclaration_NoOpLambda(
    get_current_ClassDeclaration_NoOpLambda());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_NoOpLambdaCheckpointConfiguration": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_NoOpLambdaCheckpointConfiguration():
    TypeOnly<old.NoOpLambdaCheckpointConfiguration>;
declare function use_current_InterfaceDeclaration_NoOpLambdaCheckpointConfiguration(
    use: TypeOnly<current.NoOpLambdaCheckpointConfiguration>): void;
use_current_InterfaceDeclaration_NoOpLambdaCheckpointConfiguration(
    get_old_InterfaceDeclaration_NoOpLambdaCheckpointConfiguration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_NoOpLambdaCheckpointConfiguration": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_NoOpLambdaCheckpointConfiguration():
    TypeOnly<current.NoOpLambdaCheckpointConfiguration>;
declare function use_old_InterfaceDeclaration_NoOpLambdaCheckpointConfiguration(
    use: TypeOnly<old.NoOpLambdaCheckpointConfiguration>): void;
use_old_InterfaceDeclaration_NoOpLambdaCheckpointConfiguration(
    get_current_InterfaceDeclaration_NoOpLambdaCheckpointConfiguration());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_OpEventType": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_OpEventType():
    TypeOnly<old.OpEventType>;
declare function use_current_EnumDeclaration_OpEventType(
    use: TypeOnly<current.OpEventType>): void;
use_current_EnumDeclaration_OpEventType(
    get_old_EnumDeclaration_OpEventType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_OpEventType": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_OpEventType():
    TypeOnly<current.OpEventType>;
declare function use_old_EnumDeclaration_OpEventType(
    use: TypeOnly<old.OpEventType>): void;
use_old_EnumDeclaration_OpEventType(
    get_current_EnumDeclaration_OpEventType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ScribeLambda": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ScribeLambda():
    TypeOnly<old.ScribeLambda>;
declare function use_current_ClassDeclaration_ScribeLambda(
    use: TypeOnly<current.ScribeLambda>): void;
use_current_ClassDeclaration_ScribeLambda(
    get_old_ClassDeclaration_ScribeLambda());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ScribeLambda": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ScribeLambda():
    TypeOnly<current.ScribeLambda>;
declare function use_old_ClassDeclaration_ScribeLambda(
    use: TypeOnly<old.ScribeLambda>): void;
use_old_ClassDeclaration_ScribeLambda(
    get_current_ClassDeclaration_ScribeLambda());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ScribeLambdaFactory": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ScribeLambdaFactory():
    TypeOnly<old.ScribeLambdaFactory>;
declare function use_current_ClassDeclaration_ScribeLambdaFactory(
    use: TypeOnly<current.ScribeLambdaFactory>): void;
use_current_ClassDeclaration_ScribeLambdaFactory(
    get_old_ClassDeclaration_ScribeLambdaFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ScribeLambdaFactory": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ScribeLambdaFactory():
    TypeOnly<current.ScribeLambdaFactory>;
declare function use_old_ClassDeclaration_ScribeLambdaFactory(
    use: TypeOnly<old.ScribeLambdaFactory>): void;
use_old_ClassDeclaration_ScribeLambdaFactory(
    get_current_ClassDeclaration_ScribeLambdaFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ScriptoriumLambda": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ScriptoriumLambda():
    TypeOnly<old.ScriptoriumLambda>;
declare function use_current_ClassDeclaration_ScriptoriumLambda(
    use: TypeOnly<current.ScriptoriumLambda>): void;
use_current_ClassDeclaration_ScriptoriumLambda(
    // @ts-expect-error compatibility expected to be broken
    get_old_ClassDeclaration_ScriptoriumLambda());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ScriptoriumLambda": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ScriptoriumLambda():
    TypeOnly<current.ScriptoriumLambda>;
declare function use_old_ClassDeclaration_ScriptoriumLambda(
    use: TypeOnly<old.ScriptoriumLambda>): void;
use_old_ClassDeclaration_ScriptoriumLambda(
    get_current_ClassDeclaration_ScriptoriumLambda());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ScriptoriumLambdaFactory": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ScriptoriumLambdaFactory():
    TypeOnly<old.ScriptoriumLambdaFactory>;
declare function use_current_ClassDeclaration_ScriptoriumLambdaFactory(
    use: TypeOnly<current.ScriptoriumLambdaFactory>): void;
use_current_ClassDeclaration_ScriptoriumLambdaFactory(
    get_old_ClassDeclaration_ScriptoriumLambdaFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ScriptoriumLambdaFactory": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ScriptoriumLambdaFactory():
    TypeOnly<current.ScriptoriumLambdaFactory>;
declare function use_old_ClassDeclaration_ScriptoriumLambdaFactory(
    use: TypeOnly<old.ScriptoriumLambdaFactory>): void;
use_old_ClassDeclaration_ScriptoriumLambdaFactory(
    get_current_ClassDeclaration_ScriptoriumLambdaFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SummaryReader": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SummaryReader():
    TypeOnly<old.SummaryReader>;
declare function use_current_ClassDeclaration_SummaryReader(
    use: TypeOnly<current.SummaryReader>): void;
use_current_ClassDeclaration_SummaryReader(
    get_old_ClassDeclaration_SummaryReader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SummaryReader": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SummaryReader():
    TypeOnly<current.SummaryReader>;
declare function use_old_ClassDeclaration_SummaryReader(
    use: TypeOnly<old.SummaryReader>): void;
use_old_ClassDeclaration_SummaryReader(
    get_current_ClassDeclaration_SummaryReader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SummaryWriter": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SummaryWriter():
    TypeOnly<old.SummaryWriter>;
declare function use_current_ClassDeclaration_SummaryWriter(
    use: TypeOnly<current.SummaryWriter>): void;
use_current_ClassDeclaration_SummaryWriter(
    get_old_ClassDeclaration_SummaryWriter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SummaryWriter": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SummaryWriter():
    TypeOnly<current.SummaryWriter>;
declare function use_old_ClassDeclaration_SummaryWriter(
    use: TypeOnly<old.SummaryWriter>): void;
use_old_ClassDeclaration_SummaryWriter(
    get_current_ClassDeclaration_SummaryWriter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_configureWebSocketServices": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_configureWebSocketServices():
    TypeOnly<typeof old.configureWebSocketServices>;
declare function use_current_FunctionDeclaration_configureWebSocketServices(
    use: TypeOnly<typeof current.configureWebSocketServices>): void;
use_current_FunctionDeclaration_configureWebSocketServices(
    get_old_FunctionDeclaration_configureWebSocketServices());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_configureWebSocketServices": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_configureWebSocketServices():
    TypeOnly<typeof current.configureWebSocketServices>;
declare function use_old_FunctionDeclaration_configureWebSocketServices(
    use: TypeOnly<typeof old.configureWebSocketServices>): void;
use_old_FunctionDeclaration_configureWebSocketServices(
    get_current_FunctionDeclaration_configureWebSocketServices());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createDeliCheckpointManagerFromCollection": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createDeliCheckpointManagerFromCollection():
    TypeOnly<typeof old.createDeliCheckpointManagerFromCollection>;
declare function use_current_FunctionDeclaration_createDeliCheckpointManagerFromCollection(
    use: TypeOnly<typeof current.createDeliCheckpointManagerFromCollection>): void;
use_current_FunctionDeclaration_createDeliCheckpointManagerFromCollection(
    get_old_FunctionDeclaration_createDeliCheckpointManagerFromCollection());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createDeliCheckpointManagerFromCollection": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createDeliCheckpointManagerFromCollection():
    TypeOnly<typeof current.createDeliCheckpointManagerFromCollection>;
declare function use_old_FunctionDeclaration_createDeliCheckpointManagerFromCollection(
    use: TypeOnly<typeof old.createDeliCheckpointManagerFromCollection>): void;
use_old_FunctionDeclaration_createDeliCheckpointManagerFromCollection(
    get_current_FunctionDeclaration_createDeliCheckpointManagerFromCollection());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_createNackMessage": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_createNackMessage():
    TypeOnly<typeof old.createNackMessage>;
declare function use_current_VariableDeclaration_createNackMessage(
    use: TypeOnly<typeof current.createNackMessage>): void;
use_current_VariableDeclaration_createNackMessage(
    get_old_VariableDeclaration_createNackMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_createNackMessage": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_createNackMessage():
    TypeOnly<typeof current.createNackMessage>;
declare function use_old_VariableDeclaration_createNackMessage(
    use: TypeOnly<typeof old.createNackMessage>): void;
use_old_VariableDeclaration_createNackMessage(
    get_current_VariableDeclaration_createNackMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createRoomJoinMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createRoomJoinMessage():
    TypeOnly<typeof old.createRoomJoinMessage>;
declare function use_current_FunctionDeclaration_createRoomJoinMessage(
    use: TypeOnly<typeof current.createRoomJoinMessage>): void;
use_current_FunctionDeclaration_createRoomJoinMessage(
    get_old_FunctionDeclaration_createRoomJoinMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createRoomJoinMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createRoomJoinMessage():
    TypeOnly<typeof current.createRoomJoinMessage>;
declare function use_old_FunctionDeclaration_createRoomJoinMessage(
    use: TypeOnly<typeof old.createRoomJoinMessage>): void;
use_old_FunctionDeclaration_createRoomJoinMessage(
    get_current_FunctionDeclaration_createRoomJoinMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_createRoomLeaveMessage": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_createRoomLeaveMessage():
    TypeOnly<typeof old.createRoomLeaveMessage>;
declare function use_current_VariableDeclaration_createRoomLeaveMessage(
    use: TypeOnly<typeof current.createRoomLeaveMessage>): void;
use_current_VariableDeclaration_createRoomLeaveMessage(
    get_old_VariableDeclaration_createRoomLeaveMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_createRoomLeaveMessage": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_createRoomLeaveMessage():
    TypeOnly<typeof current.createRoomLeaveMessage>;
declare function use_old_VariableDeclaration_createRoomLeaveMessage(
    use: TypeOnly<typeof old.createRoomLeaveMessage>): void;
use_old_VariableDeclaration_createRoomLeaveMessage(
    get_current_VariableDeclaration_createRoomLeaveMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_createSessionMetric": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_createSessionMetric():
    TypeOnly<typeof old.createSessionMetric>;
declare function use_current_VariableDeclaration_createSessionMetric(
    use: TypeOnly<typeof current.createSessionMetric>): void;
use_current_VariableDeclaration_createSessionMetric(
    get_old_VariableDeclaration_createSessionMetric());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_createSessionMetric": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_createSessionMetric():
    TypeOnly<typeof current.createSessionMetric>;
declare function use_old_VariableDeclaration_createSessionMetric(
    use: TypeOnly<typeof old.createSessionMetric>): void;
use_old_VariableDeclaration_createSessionMetric(
    get_current_VariableDeclaration_createSessionMetric());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_generateClientId": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_generateClientId():
    TypeOnly<typeof old.generateClientId>;
declare function use_current_VariableDeclaration_generateClientId(
    use: TypeOnly<typeof current.generateClientId>): void;
use_current_VariableDeclaration_generateClientId(
    get_old_VariableDeclaration_generateClientId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_generateClientId": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_generateClientId():
    TypeOnly<typeof current.generateClientId>;
declare function use_old_VariableDeclaration_generateClientId(
    use: TypeOnly<typeof old.generateClientId>): void;
use_old_VariableDeclaration_generateClientId(
    get_current_VariableDeclaration_generateClientId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isDocumentSessionValid": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isDocumentSessionValid():
    TypeOnly<typeof old.isDocumentSessionValid>;
declare function use_current_FunctionDeclaration_isDocumentSessionValid(
    use: TypeOnly<typeof current.isDocumentSessionValid>): void;
use_current_FunctionDeclaration_isDocumentSessionValid(
    get_old_FunctionDeclaration_isDocumentSessionValid());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isDocumentSessionValid": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isDocumentSessionValid():
    TypeOnly<typeof current.isDocumentSessionValid>;
declare function use_old_FunctionDeclaration_isDocumentSessionValid(
    use: TypeOnly<typeof old.isDocumentSessionValid>): void;
use_old_FunctionDeclaration_isDocumentSessionValid(
    get_current_FunctionDeclaration_isDocumentSessionValid());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isDocumentValid": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isDocumentValid():
    TypeOnly<typeof old.isDocumentValid>;
declare function use_current_FunctionDeclaration_isDocumentValid(
    use: TypeOnly<typeof current.isDocumentValid>): void;
use_current_FunctionDeclaration_isDocumentValid(
    get_old_FunctionDeclaration_isDocumentValid());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isDocumentValid": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isDocumentValid():
    TypeOnly<typeof current.isDocumentValid>;
declare function use_old_FunctionDeclaration_isDocumentValid(
    use: TypeOnly<typeof old.isDocumentValid>): void;
use_old_FunctionDeclaration_isDocumentValid(
    get_current_FunctionDeclaration_isDocumentValid());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_logCommonSessionEndMetrics": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_logCommonSessionEndMetrics():
    TypeOnly<typeof old.logCommonSessionEndMetrics>;
declare function use_current_VariableDeclaration_logCommonSessionEndMetrics(
    use: TypeOnly<typeof current.logCommonSessionEndMetrics>): void;
use_current_VariableDeclaration_logCommonSessionEndMetrics(
    get_old_VariableDeclaration_logCommonSessionEndMetrics());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_logCommonSessionEndMetrics": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_logCommonSessionEndMetrics():
    TypeOnly<typeof current.logCommonSessionEndMetrics>;
declare function use_old_VariableDeclaration_logCommonSessionEndMetrics(
    use: TypeOnly<typeof old.logCommonSessionEndMetrics>): void;
use_old_VariableDeclaration_logCommonSessionEndMetrics(
    get_current_VariableDeclaration_logCommonSessionEndMetrics());
