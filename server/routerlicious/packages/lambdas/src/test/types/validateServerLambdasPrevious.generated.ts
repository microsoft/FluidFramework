/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-test-generator in @fluidframework/build-tools.
 */
import * as old from "@fluidframework/server-lambdas-previous";
import * as current from "../../index";

type TypeOnly<T> = {
    [P in keyof T]: TypeOnly<T[P]>;
};

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BroadcasterLambda": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_BroadcasterLambda():
    TypeOnly<old.BroadcasterLambda>;
declare function use_current_ClassDeclaration_BroadcasterLambda(
    use: TypeOnly<current.BroadcasterLambda>);
use_current_ClassDeclaration_BroadcasterLambda(
    get_old_ClassDeclaration_BroadcasterLambda());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BroadcasterLambda": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_BroadcasterLambda():
    TypeOnly<current.BroadcasterLambda>;
declare function use_old_ClassDeclaration_BroadcasterLambda(
    use: TypeOnly<old.BroadcasterLambda>);
use_old_ClassDeclaration_BroadcasterLambda(
    get_current_ClassDeclaration_BroadcasterLambda());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BroadcasterLambdaFactory": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_BroadcasterLambdaFactory():
    TypeOnly<old.BroadcasterLambdaFactory>;
declare function use_current_ClassDeclaration_BroadcasterLambdaFactory(
    use: TypeOnly<current.BroadcasterLambdaFactory>);
use_current_ClassDeclaration_BroadcasterLambdaFactory(
    get_old_ClassDeclaration_BroadcasterLambdaFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BroadcasterLambdaFactory": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_BroadcasterLambdaFactory():
    TypeOnly<current.BroadcasterLambdaFactory>;
declare function use_old_ClassDeclaration_BroadcasterLambdaFactory(
    use: TypeOnly<old.BroadcasterLambdaFactory>);
use_old_ClassDeclaration_BroadcasterLambdaFactory(
    get_current_ClassDeclaration_BroadcasterLambdaFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_CheckpointManager": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_CheckpointManager():
    TypeOnly<old.CheckpointManager>;
declare function use_current_ClassDeclaration_CheckpointManager(
    use: TypeOnly<current.CheckpointManager>);
use_current_ClassDeclaration_CheckpointManager(
    get_old_ClassDeclaration_CheckpointManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_CheckpointManager": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_CheckpointManager():
    TypeOnly<current.CheckpointManager>;
declare function use_old_ClassDeclaration_CheckpointManager(
    use: TypeOnly<old.CheckpointManager>);
use_old_ClassDeclaration_CheckpointManager(
    get_current_ClassDeclaration_CheckpointManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_CopierLambda": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_CopierLambda():
    TypeOnly<old.CopierLambda>;
declare function use_current_ClassDeclaration_CopierLambda(
    use: TypeOnly<current.CopierLambda>);
use_current_ClassDeclaration_CopierLambda(
    get_old_ClassDeclaration_CopierLambda());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_CopierLambda": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_CopierLambda():
    TypeOnly<current.CopierLambda>;
declare function use_old_ClassDeclaration_CopierLambda(
    use: TypeOnly<old.CopierLambda>);
use_old_ClassDeclaration_CopierLambda(
    get_current_ClassDeclaration_CopierLambda());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_CopierLambdaFactory": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_CopierLambdaFactory():
    TypeOnly<old.CopierLambdaFactory>;
declare function use_current_ClassDeclaration_CopierLambdaFactory(
    use: TypeOnly<current.CopierLambdaFactory>);
use_current_ClassDeclaration_CopierLambdaFactory(
    get_old_ClassDeclaration_CopierLambdaFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_CopierLambdaFactory": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_CopierLambdaFactory():
    TypeOnly<current.CopierLambdaFactory>;
declare function use_old_ClassDeclaration_CopierLambdaFactory(
    use: TypeOnly<old.CopierLambdaFactory>);
use_old_ClassDeclaration_CopierLambdaFactory(
    get_current_ClassDeclaration_CopierLambdaFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DeliLambda": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_DeliLambda():
    TypeOnly<old.DeliLambda>;
declare function use_current_ClassDeclaration_DeliLambda(
    use: TypeOnly<current.DeliLambda>);
use_current_ClassDeclaration_DeliLambda(
    get_old_ClassDeclaration_DeliLambda());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DeliLambda": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_DeliLambda():
    TypeOnly<current.DeliLambda>;
declare function use_old_ClassDeclaration_DeliLambda(
    use: TypeOnly<old.DeliLambda>);
use_old_ClassDeclaration_DeliLambda(
    // @ts-expect-error compatibility expected to be broken
    get_current_ClassDeclaration_DeliLambda());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DeliLambdaFactory": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_DeliLambdaFactory():
    TypeOnly<old.DeliLambdaFactory>;
declare function use_current_ClassDeclaration_DeliLambdaFactory(
    use: TypeOnly<current.DeliLambdaFactory>);
use_current_ClassDeclaration_DeliLambdaFactory(
    get_old_ClassDeclaration_DeliLambdaFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DeliLambdaFactory": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_DeliLambdaFactory():
    TypeOnly<current.DeliLambdaFactory>;
declare function use_old_ClassDeclaration_DeliLambdaFactory(
    use: TypeOnly<old.DeliLambdaFactory>);
use_old_ClassDeclaration_DeliLambdaFactory(
    get_current_ClassDeclaration_DeliLambdaFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedClassDeclaration_ForemanLambda": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedClassDeclaration_ForemanLambda": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedClassDeclaration_ForemanLambdaFactory": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedClassDeclaration_ForemanLambdaFactory": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICheckpointManager": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICheckpointManager():
    TypeOnly<old.ICheckpointManager>;
declare function use_current_InterfaceDeclaration_ICheckpointManager(
    use: TypeOnly<current.ICheckpointManager>);
use_current_InterfaceDeclaration_ICheckpointManager(
    get_old_InterfaceDeclaration_ICheckpointManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICheckpointManager": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICheckpointManager():
    TypeOnly<current.ICheckpointManager>;
declare function use_old_InterfaceDeclaration_ICheckpointManager(
    use: TypeOnly<old.ICheckpointManager>);
use_old_InterfaceDeclaration_ICheckpointManager(
    get_current_InterfaceDeclaration_ICheckpointManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICheckpointParams": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICheckpointParams():
    TypeOnly<old.ICheckpointParams>;
declare function use_current_InterfaceDeclaration_ICheckpointParams(
    use: TypeOnly<current.ICheckpointParams>);
use_current_InterfaceDeclaration_ICheckpointParams(
    get_old_InterfaceDeclaration_ICheckpointParams());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICheckpointParams": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICheckpointParams():
    TypeOnly<current.ICheckpointParams>;
declare function use_old_InterfaceDeclaration_ICheckpointParams(
    use: TypeOnly<old.ICheckpointParams>);
use_old_InterfaceDeclaration_ICheckpointParams(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_ICheckpointParams());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeliCheckpointManager": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDeliCheckpointManager():
    TypeOnly<old.IDeliCheckpointManager>;
declare function use_current_InterfaceDeclaration_IDeliCheckpointManager(
    use: TypeOnly<current.IDeliCheckpointManager>);
use_current_InterfaceDeclaration_IDeliCheckpointManager(
    get_old_InterfaceDeclaration_IDeliCheckpointManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeliCheckpointManager": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDeliCheckpointManager():
    TypeOnly<current.IDeliCheckpointManager>;
declare function use_old_InterfaceDeclaration_IDeliCheckpointManager(
    use: TypeOnly<old.IDeliCheckpointManager>);
use_old_InterfaceDeclaration_IDeliCheckpointManager(
    get_current_InterfaceDeclaration_IDeliCheckpointManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeliLambdaEvents": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IDeliLambdaEvents():
    TypeOnly<old.IDeliLambdaEvents>;
declare function use_current_InterfaceDeclaration_IDeliLambdaEvents(
    use: TypeOnly<current.IDeliLambdaEvents>);
use_current_InterfaceDeclaration_IDeliLambdaEvents(
    get_old_InterfaceDeclaration_IDeliLambdaEvents());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IDeliLambdaEvents": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IDeliLambdaEvents():
    TypeOnly<current.IDeliLambdaEvents>;
declare function use_old_InterfaceDeclaration_IDeliLambdaEvents(
    use: TypeOnly<old.IDeliLambdaEvents>);
use_old_InterfaceDeclaration_IDeliLambdaEvents(
    get_current_InterfaceDeclaration_IDeliLambdaEvents());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ILatestSummaryState": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ILatestSummaryState():
    TypeOnly<old.ILatestSummaryState>;
declare function use_current_InterfaceDeclaration_ILatestSummaryState(
    use: TypeOnly<current.ILatestSummaryState>);
use_current_InterfaceDeclaration_ILatestSummaryState(
    get_old_InterfaceDeclaration_ILatestSummaryState());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ILatestSummaryState": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ILatestSummaryState():
    TypeOnly<current.ILatestSummaryState>;
declare function use_old_InterfaceDeclaration_ILatestSummaryState(
    use: TypeOnly<old.ILatestSummaryState>);
use_old_InterfaceDeclaration_ILatestSummaryState(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_ILatestSummaryState());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPendingMessageReader": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPendingMessageReader():
    TypeOnly<old.IPendingMessageReader>;
declare function use_current_InterfaceDeclaration_IPendingMessageReader(
    use: TypeOnly<current.IPendingMessageReader>);
use_current_InterfaceDeclaration_IPendingMessageReader(
    get_old_InterfaceDeclaration_IPendingMessageReader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPendingMessageReader": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPendingMessageReader():
    TypeOnly<current.IPendingMessageReader>;
declare function use_old_InterfaceDeclaration_IPendingMessageReader(
    use: TypeOnly<old.IPendingMessageReader>);
use_old_InterfaceDeclaration_IPendingMessageReader(
    get_current_InterfaceDeclaration_IPendingMessageReader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryReader": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryReader():
    TypeOnly<old.ISummaryReader>;
declare function use_current_InterfaceDeclaration_ISummaryReader(
    use: TypeOnly<current.ISummaryReader>);
use_current_InterfaceDeclaration_ISummaryReader(
    get_old_InterfaceDeclaration_ISummaryReader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryReader": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryReader():
    TypeOnly<current.ISummaryReader>;
declare function use_old_InterfaceDeclaration_ISummaryReader(
    use: TypeOnly<old.ISummaryReader>);
use_old_InterfaceDeclaration_ISummaryReader(
    get_current_InterfaceDeclaration_ISummaryReader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryWriteResponse": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryWriteResponse():
    TypeOnly<old.ISummaryWriteResponse>;
declare function use_current_InterfaceDeclaration_ISummaryWriteResponse(
    use: TypeOnly<current.ISummaryWriteResponse>);
use_current_InterfaceDeclaration_ISummaryWriteResponse(
    get_old_InterfaceDeclaration_ISummaryWriteResponse());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryWriteResponse": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryWriteResponse():
    TypeOnly<current.ISummaryWriteResponse>;
declare function use_old_InterfaceDeclaration_ISummaryWriteResponse(
    use: TypeOnly<old.ISummaryWriteResponse>);
use_old_InterfaceDeclaration_ISummaryWriteResponse(
    get_current_InterfaceDeclaration_ISummaryWriteResponse());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryWriter": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryWriter():
    TypeOnly<old.ISummaryWriter>;
declare function use_current_InterfaceDeclaration_ISummaryWriter(
    use: TypeOnly<current.ISummaryWriter>);
use_current_InterfaceDeclaration_ISummaryWriter(
    get_old_InterfaceDeclaration_ISummaryWriter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryWriter": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryWriter():
    TypeOnly<current.ISummaryWriter>;
declare function use_old_InterfaceDeclaration_ISummaryWriter(
    use: TypeOnly<old.ISummaryWriter>);
use_old_InterfaceDeclaration_ISummaryWriter(
    get_current_InterfaceDeclaration_ISummaryWriter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MoiraLambda": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_MoiraLambda():
    TypeOnly<old.MoiraLambda>;
declare function use_current_ClassDeclaration_MoiraLambda(
    use: TypeOnly<current.MoiraLambda>);
use_current_ClassDeclaration_MoiraLambda(
    get_old_ClassDeclaration_MoiraLambda());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MoiraLambda": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_MoiraLambda():
    TypeOnly<current.MoiraLambda>;
declare function use_old_ClassDeclaration_MoiraLambda(
    use: TypeOnly<old.MoiraLambda>);
use_old_ClassDeclaration_MoiraLambda(
    get_current_ClassDeclaration_MoiraLambda());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MoiraLambdaFactory": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_MoiraLambdaFactory():
    TypeOnly<old.MoiraLambdaFactory>;
declare function use_current_ClassDeclaration_MoiraLambdaFactory(
    use: TypeOnly<current.MoiraLambdaFactory>);
use_current_ClassDeclaration_MoiraLambdaFactory(
    get_old_ClassDeclaration_MoiraLambdaFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_MoiraLambdaFactory": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_MoiraLambdaFactory():
    TypeOnly<current.MoiraLambdaFactory>;
declare function use_old_ClassDeclaration_MoiraLambdaFactory(
    use: TypeOnly<old.MoiraLambdaFactory>);
use_old_ClassDeclaration_MoiraLambdaFactory(
    get_current_ClassDeclaration_MoiraLambdaFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_NoOpLambda": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_NoOpLambda():
    TypeOnly<old.NoOpLambda>;
declare function use_current_ClassDeclaration_NoOpLambda(
    use: TypeOnly<current.NoOpLambda>);
use_current_ClassDeclaration_NoOpLambda(
    get_old_ClassDeclaration_NoOpLambda());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_NoOpLambda": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_NoOpLambda():
    TypeOnly<current.NoOpLambda>;
declare function use_old_ClassDeclaration_NoOpLambda(
    use: TypeOnly<old.NoOpLambda>);
use_old_ClassDeclaration_NoOpLambda(
    get_current_ClassDeclaration_NoOpLambda());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_OpEventType": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_OpEventType():
    TypeOnly<old.OpEventType>;
declare function use_current_EnumDeclaration_OpEventType(
    use: TypeOnly<current.OpEventType>);
use_current_EnumDeclaration_OpEventType(
    get_old_EnumDeclaration_OpEventType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_OpEventType": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_OpEventType():
    TypeOnly<current.OpEventType>;
declare function use_old_EnumDeclaration_OpEventType(
    use: TypeOnly<old.OpEventType>);
use_old_EnumDeclaration_OpEventType(
    get_current_EnumDeclaration_OpEventType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ScribeLambda": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ScribeLambda():
    TypeOnly<old.ScribeLambda>;
declare function use_current_ClassDeclaration_ScribeLambda(
    use: TypeOnly<current.ScribeLambda>);
use_current_ClassDeclaration_ScribeLambda(
    get_old_ClassDeclaration_ScribeLambda());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ScribeLambda": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ScribeLambda():
    TypeOnly<current.ScribeLambda>;
declare function use_old_ClassDeclaration_ScribeLambda(
    use: TypeOnly<old.ScribeLambda>);
use_old_ClassDeclaration_ScribeLambda(
    get_current_ClassDeclaration_ScribeLambda());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ScribeLambdaFactory": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ScribeLambdaFactory():
    TypeOnly<old.ScribeLambdaFactory>;
declare function use_current_ClassDeclaration_ScribeLambdaFactory(
    use: TypeOnly<current.ScribeLambdaFactory>);
use_current_ClassDeclaration_ScribeLambdaFactory(
    get_old_ClassDeclaration_ScribeLambdaFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ScribeLambdaFactory": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ScribeLambdaFactory():
    TypeOnly<current.ScribeLambdaFactory>;
declare function use_old_ClassDeclaration_ScribeLambdaFactory(
    use: TypeOnly<old.ScribeLambdaFactory>);
use_old_ClassDeclaration_ScribeLambdaFactory(
    get_current_ClassDeclaration_ScribeLambdaFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ScriptoriumLambda": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ScriptoriumLambda():
    TypeOnly<old.ScriptoriumLambda>;
declare function use_current_ClassDeclaration_ScriptoriumLambda(
    use: TypeOnly<current.ScriptoriumLambda>);
use_current_ClassDeclaration_ScriptoriumLambda(
    get_old_ClassDeclaration_ScriptoriumLambda());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ScriptoriumLambda": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ScriptoriumLambda():
    TypeOnly<current.ScriptoriumLambda>;
declare function use_old_ClassDeclaration_ScriptoriumLambda(
    use: TypeOnly<old.ScriptoriumLambda>);
use_old_ClassDeclaration_ScriptoriumLambda(
    get_current_ClassDeclaration_ScriptoriumLambda());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ScriptoriumLambdaFactory": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ScriptoriumLambdaFactory():
    TypeOnly<old.ScriptoriumLambdaFactory>;
declare function use_current_ClassDeclaration_ScriptoriumLambdaFactory(
    use: TypeOnly<current.ScriptoriumLambdaFactory>);
use_current_ClassDeclaration_ScriptoriumLambdaFactory(
    get_old_ClassDeclaration_ScriptoriumLambdaFactory());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ScriptoriumLambdaFactory": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ScriptoriumLambdaFactory():
    TypeOnly<current.ScriptoriumLambdaFactory>;
declare function use_old_ClassDeclaration_ScriptoriumLambdaFactory(
    use: TypeOnly<old.ScriptoriumLambdaFactory>);
use_old_ClassDeclaration_ScriptoriumLambdaFactory(
    get_current_ClassDeclaration_ScriptoriumLambdaFactory());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SummaryReader": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SummaryReader():
    TypeOnly<old.SummaryReader>;
declare function use_current_ClassDeclaration_SummaryReader(
    use: TypeOnly<current.SummaryReader>);
use_current_ClassDeclaration_SummaryReader(
    get_old_ClassDeclaration_SummaryReader());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SummaryReader": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SummaryReader():
    TypeOnly<current.SummaryReader>;
declare function use_old_ClassDeclaration_SummaryReader(
    use: TypeOnly<old.SummaryReader>);
use_old_ClassDeclaration_SummaryReader(
    get_current_ClassDeclaration_SummaryReader());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SummaryWriter": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SummaryWriter():
    TypeOnly<old.SummaryWriter>;
declare function use_current_ClassDeclaration_SummaryWriter(
    use: TypeOnly<current.SummaryWriter>);
use_current_ClassDeclaration_SummaryWriter(
    get_old_ClassDeclaration_SummaryWriter());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SummaryWriter": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SummaryWriter():
    TypeOnly<current.SummaryWriter>;
declare function use_old_ClassDeclaration_SummaryWriter(
    use: TypeOnly<old.SummaryWriter>);
use_old_ClassDeclaration_SummaryWriter(
    get_current_ClassDeclaration_SummaryWriter());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_configureWebSocketServices": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_configureWebSocketServices():
    TypeOnly<typeof old.configureWebSocketServices>;
declare function use_current_FunctionDeclaration_configureWebSocketServices(
    use: TypeOnly<typeof current.configureWebSocketServices>);
use_current_FunctionDeclaration_configureWebSocketServices(
    get_old_FunctionDeclaration_configureWebSocketServices());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_configureWebSocketServices": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_configureWebSocketServices():
    TypeOnly<typeof current.configureWebSocketServices>;
declare function use_old_FunctionDeclaration_configureWebSocketServices(
    use: TypeOnly<typeof old.configureWebSocketServices>);
use_old_FunctionDeclaration_configureWebSocketServices(
    get_current_FunctionDeclaration_configureWebSocketServices());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createDeliCheckpointManagerFromCollection": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createDeliCheckpointManagerFromCollection():
    TypeOnly<typeof old.createDeliCheckpointManagerFromCollection>;
declare function use_current_FunctionDeclaration_createDeliCheckpointManagerFromCollection(
    use: TypeOnly<typeof current.createDeliCheckpointManagerFromCollection>);
use_current_FunctionDeclaration_createDeliCheckpointManagerFromCollection(
    get_old_FunctionDeclaration_createDeliCheckpointManagerFromCollection());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createDeliCheckpointManagerFromCollection": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createDeliCheckpointManagerFromCollection():
    TypeOnly<typeof current.createDeliCheckpointManagerFromCollection>;
declare function use_old_FunctionDeclaration_createDeliCheckpointManagerFromCollection(
    use: TypeOnly<typeof old.createDeliCheckpointManagerFromCollection>);
use_old_FunctionDeclaration_createDeliCheckpointManagerFromCollection(
    get_current_FunctionDeclaration_createDeliCheckpointManagerFromCollection());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_createNackMessage": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_createNackMessage():
    TypeOnly<typeof old.createNackMessage>;
declare function use_current_VariableDeclaration_createNackMessage(
    use: TypeOnly<typeof current.createNackMessage>);
use_current_VariableDeclaration_createNackMessage(
    get_old_VariableDeclaration_createNackMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_createNackMessage": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_createNackMessage():
    TypeOnly<typeof current.createNackMessage>;
declare function use_old_VariableDeclaration_createNackMessage(
    use: TypeOnly<typeof old.createNackMessage>);
use_old_VariableDeclaration_createNackMessage(
    get_current_VariableDeclaration_createNackMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createRoomJoinMessage": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createRoomJoinMessage():
    TypeOnly<typeof old.createRoomJoinMessage>;
declare function use_current_FunctionDeclaration_createRoomJoinMessage(
    use: TypeOnly<typeof current.createRoomJoinMessage>);
use_current_FunctionDeclaration_createRoomJoinMessage(
    get_old_FunctionDeclaration_createRoomJoinMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createRoomJoinMessage": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createRoomJoinMessage():
    TypeOnly<typeof current.createRoomJoinMessage>;
declare function use_old_FunctionDeclaration_createRoomJoinMessage(
    use: TypeOnly<typeof old.createRoomJoinMessage>);
use_old_FunctionDeclaration_createRoomJoinMessage(
    get_current_FunctionDeclaration_createRoomJoinMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_createRoomLeaveMessage": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_createRoomLeaveMessage():
    TypeOnly<typeof old.createRoomLeaveMessage>;
declare function use_current_VariableDeclaration_createRoomLeaveMessage(
    use: TypeOnly<typeof current.createRoomLeaveMessage>);
use_current_VariableDeclaration_createRoomLeaveMessage(
    get_old_VariableDeclaration_createRoomLeaveMessage());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_createRoomLeaveMessage": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_createRoomLeaveMessage():
    TypeOnly<typeof current.createRoomLeaveMessage>;
declare function use_old_VariableDeclaration_createRoomLeaveMessage(
    use: TypeOnly<typeof old.createRoomLeaveMessage>);
use_old_VariableDeclaration_createRoomLeaveMessage(
    get_current_VariableDeclaration_createRoomLeaveMessage());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_createSessionMetric": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_createSessionMetric():
    TypeOnly<typeof old.createSessionMetric>;
declare function use_current_VariableDeclaration_createSessionMetric(
    use: TypeOnly<typeof current.createSessionMetric>);
use_current_VariableDeclaration_createSessionMetric(
    get_old_VariableDeclaration_createSessionMetric());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_createSessionMetric": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_createSessionMetric():
    TypeOnly<typeof current.createSessionMetric>;
declare function use_old_VariableDeclaration_createSessionMetric(
    use: TypeOnly<typeof old.createSessionMetric>);
use_old_VariableDeclaration_createSessionMetric(
    get_current_VariableDeclaration_createSessionMetric());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_generateClientId": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_generateClientId():
    TypeOnly<typeof old.generateClientId>;
declare function use_current_VariableDeclaration_generateClientId(
    use: TypeOnly<typeof current.generateClientId>);
use_current_VariableDeclaration_generateClientId(
    get_old_VariableDeclaration_generateClientId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_generateClientId": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_generateClientId():
    TypeOnly<typeof current.generateClientId>;
declare function use_old_VariableDeclaration_generateClientId(
    use: TypeOnly<typeof old.generateClientId>);
use_old_VariableDeclaration_generateClientId(
    get_current_VariableDeclaration_generateClientId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isDocumentSessionValid": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isDocumentSessionValid():
    TypeOnly<typeof old.isDocumentSessionValid>;
declare function use_current_FunctionDeclaration_isDocumentSessionValid(
    use: TypeOnly<typeof current.isDocumentSessionValid>);
use_current_FunctionDeclaration_isDocumentSessionValid(
    get_old_FunctionDeclaration_isDocumentSessionValid());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isDocumentSessionValid": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isDocumentSessionValid():
    TypeOnly<typeof current.isDocumentSessionValid>;
declare function use_old_FunctionDeclaration_isDocumentSessionValid(
    use: TypeOnly<typeof old.isDocumentSessionValid>);
use_old_FunctionDeclaration_isDocumentSessionValid(
    get_current_FunctionDeclaration_isDocumentSessionValid());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isDocumentValid": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isDocumentValid():
    TypeOnly<typeof old.isDocumentValid>;
declare function use_current_FunctionDeclaration_isDocumentValid(
    use: TypeOnly<typeof current.isDocumentValid>);
use_current_FunctionDeclaration_isDocumentValid(
    get_old_FunctionDeclaration_isDocumentValid());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isDocumentValid": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isDocumentValid():
    TypeOnly<typeof current.isDocumentValid>;
declare function use_old_FunctionDeclaration_isDocumentValid(
    use: TypeOnly<typeof old.isDocumentValid>);
use_old_FunctionDeclaration_isDocumentValid(
    get_current_FunctionDeclaration_isDocumentValid());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_logCommonSessionEndMetrics": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_logCommonSessionEndMetrics():
    TypeOnly<typeof old.logCommonSessionEndMetrics>;
declare function use_current_VariableDeclaration_logCommonSessionEndMetrics(
    use: TypeOnly<typeof current.logCommonSessionEndMetrics>);
use_current_VariableDeclaration_logCommonSessionEndMetrics(
    get_old_VariableDeclaration_logCommonSessionEndMetrics());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_logCommonSessionEndMetrics": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_logCommonSessionEndMetrics():
    TypeOnly<typeof current.logCommonSessionEndMetrics>;
declare function use_old_VariableDeclaration_logCommonSessionEndMetrics(
    use: TypeOnly<typeof old.logCommonSessionEndMetrics>);
use_old_VariableDeclaration_logCommonSessionEndMetrics(
    get_current_VariableDeclaration_logCommonSessionEndMetrics());
