/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

import { Heap, IComparer, IHeapNode } from "@fluidframework/common-utils";
import { IClientSequenceNumber } from "./checkpointContext";

const SequenceNumberComparer: IComparer<IClientSequenceNumber> = {
    compare: (a, b) => a.referenceSequenceNumber - b.referenceSequenceNumber,
    min: {
        canEvict: true,
        clientId: undefined,
        clientSequenceNumber: 0,
        lastUpdate: -1,
        nack: false,
        referenceSequenceNumber: -1,
        scopes: [],
    },
};

export class ClientSequenceNumberManager {
    private readonly clientNodeMap = new Map<string, IHeapNode<IClientSequenceNumber>>();
    private readonly clientSeqNumbers = new Heap<IClientSequenceNumber>(SequenceNumberComparer);

    public has(clientId: string): boolean {
        return this.clientNodeMap.has(clientId);
    }

    public get(clientId: string): IClientSequenceNumber {
        const node = this.clientNodeMap.get(clientId);
        if (node === undefined) {
            return undefined;
        }
        return node.value;
    }

    public count() {
        return this.clientNodeMap.size;
    }

    public peek() {
        const node = this.clientSeqNumbers.peek();
        if (node === undefined) {
            return undefined;
        }
        return node.value;
    }

    public cloneValues(): IClientSequenceNumber[] {
        const clients: IClientSequenceNumber[] = [];
        for (const [, value] of this.clientNodeMap) {
            const source = value.value;
            clients.push({ ...source });
        }
        return clients;
    }

    /**
     * Begins tracking or updates an already tracked client.
     * @param clientId The client identifier
     * @param clientSequenceNumber The sequence number generated by client
     * @param referenceSequenceNumber The sequence number the client is at
     * @param timestamp The time of the operation
     * @param canEvict Flag indicating whether or not we can evict the client (branch clients cannot be evicted)
     * @param scopes scope of the client
     * @param nack Flag indicating whether we have nacked this client
     * Returns false if the same client has been added earlier.
     */
    public upsertClient(
        clientId: string,
        clientSequenceNumber: number,
        referenceSequenceNumber: number,
        timestamp: number,
        canEvict: boolean,
        scopes: string[] = [],
        nack: boolean = false): boolean {
        // Add the client ID to our map if this is the first time we've seen it
        let newClient = false;
        if (!this.clientNodeMap.has(clientId)) {
            const newNode = this.clientSeqNumbers.add({
                canEvict,
                clientId,
                clientSequenceNumber,
                lastUpdate: timestamp,
                nack,
                referenceSequenceNumber,
                scopes,
            });
            this.clientNodeMap.set(clientId, newNode);
            newClient = true;
        }

        // And then update its values
        this.updateClient(clientId, timestamp, clientSequenceNumber, referenceSequenceNumber, nack);
        return newClient;
    }

    /**
     * Updates the sequence number of the specified client
     */
    public updateClient(
        clientId: string,
        lastUpdate: number,
        clientSequenceNumber: number,
        referenceSequenceNumber: number,
        nack: boolean) {
        // Lookup the node and then update its value based on the message
        const heapNode = this.clientNodeMap.get(clientId);
        heapNode.value.referenceSequenceNumber = referenceSequenceNumber;
        heapNode.value.clientSequenceNumber = clientSequenceNumber;
        heapNode.value.lastUpdate = lastUpdate;
        heapNode.value.nack = nack;
        this.clientSeqNumbers.update(heapNode);
    }

    /**
     * Removes the provided client from the list of tracked clients.
     * Returns false if the client has been removed earlier.
     */
    public removeClient(clientId: string): boolean {
        if (!this.clientNodeMap.has(clientId)) {
            return false;
        }

        // Remove the client from the list of nodes
        const details = this.clientNodeMap.get(clientId);
        this.clientSeqNumbers.remove(details);
        this.clientNodeMap.delete(clientId);
        return true;
    }

    /**
     * Retrieves the minimum sequence number.
     */
    public getMinimumSequenceNumber(): number {
        if (this.clientSeqNumbers.count() > 0) {
            const client = this.clientSeqNumbers.peek();
            return client.value.referenceSequenceNumber;
        } else {
            return -1;
        }
    }
}
