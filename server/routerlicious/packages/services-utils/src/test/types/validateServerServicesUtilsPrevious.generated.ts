/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-test-generator in @fluidframework/build-tools.
 */

import type * as old from "@fluidframework/server-services-utils-previous";
import type * as current from "../../index.js";


// See 'build-tools/src/type-test-generator/compatibility.ts' for more information.
type TypeOnly<T> = T extends number
	? number
	: T extends string
	? string
	: T extends boolean | bigint | symbol
	? T
	: {
			[P in keyof T]: TypeOnly<T[P]>;
	  };

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_AsyncLocalStorageContextProvider": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_AsyncLocalStorageContextProvider():
    TypeOnly<old.AsyncLocalStorageContextProvider<any>>;
declare function use_current_ClassDeclaration_AsyncLocalStorageContextProvider(
    use: TypeOnly<current.AsyncLocalStorageContextProvider<any>>): void;
use_current_ClassDeclaration_AsyncLocalStorageContextProvider(
    get_old_ClassDeclaration_AsyncLocalStorageContextProvider());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_AsyncLocalStorageContextProvider": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_AsyncLocalStorageContextProvider():
    TypeOnly<current.AsyncLocalStorageContextProvider<any>>;
declare function use_old_ClassDeclaration_AsyncLocalStorageContextProvider(
    use: TypeOnly<old.AsyncLocalStorageContextProvider<any>>): void;
use_old_ClassDeclaration_AsyncLocalStorageContextProvider(
    get_current_ClassDeclaration_AsyncLocalStorageContextProvider());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_AsyncLocalStorageTelemetryContext": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_AsyncLocalStorageTelemetryContext():
    TypeOnly<old.AsyncLocalStorageTelemetryContext>;
declare function use_current_ClassDeclaration_AsyncLocalStorageTelemetryContext(
    use: TypeOnly<current.AsyncLocalStorageTelemetryContext>): void;
use_current_ClassDeclaration_AsyncLocalStorageTelemetryContext(
    get_old_ClassDeclaration_AsyncLocalStorageTelemetryContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_AsyncLocalStorageTelemetryContext": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_AsyncLocalStorageTelemetryContext():
    TypeOnly<current.AsyncLocalStorageTelemetryContext>;
declare function use_old_ClassDeclaration_AsyncLocalStorageTelemetryContext(
    use: TypeOnly<old.AsyncLocalStorageTelemetryContext>): void;
use_old_ClassDeclaration_AsyncLocalStorageTelemetryContext(
    get_current_ClassDeclaration_AsyncLocalStorageTelemetryContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_AsyncLocalStorageTimeoutContext": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_AsyncLocalStorageTimeoutContext():
    TypeOnly<old.AsyncLocalStorageTimeoutContext>;
declare function use_current_ClassDeclaration_AsyncLocalStorageTimeoutContext(
    use: TypeOnly<current.AsyncLocalStorageTimeoutContext>): void;
use_current_ClassDeclaration_AsyncLocalStorageTimeoutContext(
    get_old_ClassDeclaration_AsyncLocalStorageTimeoutContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_AsyncLocalStorageTimeoutContext": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_AsyncLocalStorageTimeoutContext():
    TypeOnly<current.AsyncLocalStorageTimeoutContext>;
declare function use_old_ClassDeclaration_AsyncLocalStorageTimeoutContext(
    use: TypeOnly<old.AsyncLocalStorageTimeoutContext>): void;
use_old_ClassDeclaration_AsyncLocalStorageTimeoutContext(
    get_current_ClassDeclaration_AsyncLocalStorageTimeoutContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DummyRevokedTokenChecker": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_DummyRevokedTokenChecker():
    TypeOnly<old.DummyRevokedTokenChecker>;
declare function use_current_ClassDeclaration_DummyRevokedTokenChecker(
    use: TypeOnly<current.DummyRevokedTokenChecker>): void;
use_current_ClassDeclaration_DummyRevokedTokenChecker(
    get_old_ClassDeclaration_DummyRevokedTokenChecker());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DummyRevokedTokenChecker": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_DummyRevokedTokenChecker():
    TypeOnly<current.DummyRevokedTokenChecker>;
declare function use_old_ClassDeclaration_DummyRevokedTokenChecker(
    use: TypeOnly<old.DummyRevokedTokenChecker>): void;
use_old_ClassDeclaration_DummyRevokedTokenChecker(
    get_current_ClassDeclaration_DummyRevokedTokenChecker());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DummyTokenRevocationManager": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_DummyTokenRevocationManager():
    TypeOnly<old.DummyTokenRevocationManager>;
declare function use_current_ClassDeclaration_DummyTokenRevocationManager(
    use: TypeOnly<current.DummyTokenRevocationManager>): void;
use_current_ClassDeclaration_DummyTokenRevocationManager(
    get_old_ClassDeclaration_DummyTokenRevocationManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DummyTokenRevocationManager": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_DummyTokenRevocationManager():
    TypeOnly<current.DummyTokenRevocationManager>;
declare function use_old_ClassDeclaration_DummyTokenRevocationManager(
    use: TypeOnly<old.DummyTokenRevocationManager>): void;
use_old_ClassDeclaration_DummyTokenRevocationManager(
    get_current_ClassDeclaration_DummyTokenRevocationManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_FluidServiceError": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_FluidServiceError():
    TypeOnly<old.FluidServiceError>;
declare function use_current_ClassDeclaration_FluidServiceError(
    use: TypeOnly<current.FluidServiceError>): void;
use_current_ClassDeclaration_FluidServiceError(
    get_old_ClassDeclaration_FluidServiceError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_FluidServiceError": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_FluidServiceError():
    TypeOnly<current.FluidServiceError>;
declare function use_old_ClassDeclaration_FluidServiceError(
    use: TypeOnly<old.FluidServiceError>): void;
use_old_ClassDeclaration_FluidServiceError(
    get_current_ClassDeclaration_FluidServiceError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_FluidServiceErrorCode": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_FluidServiceErrorCode():
    TypeOnly<old.FluidServiceErrorCode>;
declare function use_current_EnumDeclaration_FluidServiceErrorCode(
    use: TypeOnly<current.FluidServiceErrorCode>): void;
use_current_EnumDeclaration_FluidServiceErrorCode(
    get_old_EnumDeclaration_FluidServiceErrorCode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_FluidServiceErrorCode": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_FluidServiceErrorCode():
    TypeOnly<current.FluidServiceErrorCode>;
declare function use_old_EnumDeclaration_FluidServiceErrorCode(
    use: TypeOnly<old.FluidServiceErrorCode>): void;
use_old_EnumDeclaration_FluidServiceErrorCode(
    get_current_EnumDeclaration_FluidServiceErrorCode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IApiCounters": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IApiCounters():
    TypeOnly<old.IApiCounters>;
declare function use_current_InterfaceDeclaration_IApiCounters(
    use: TypeOnly<current.IApiCounters>): void;
use_current_InterfaceDeclaration_IApiCounters(
    get_old_InterfaceDeclaration_IApiCounters());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IApiCounters": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IApiCounters():
    TypeOnly<current.IApiCounters>;
declare function use_old_InterfaceDeclaration_IApiCounters(
    use: TypeOnly<old.IApiCounters>): void;
use_old_InterfaceDeclaration_IApiCounters(
    get_current_InterfaceDeclaration_IApiCounters());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRedisClientConnectionManager": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRedisClientConnectionManager():
    TypeOnly<old.IRedisClientConnectionManager>;
declare function use_current_InterfaceDeclaration_IRedisClientConnectionManager(
    use: TypeOnly<current.IRedisClientConnectionManager>): void;
use_current_InterfaceDeclaration_IRedisClientConnectionManager(
    get_old_InterfaceDeclaration_IRedisClientConnectionManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRedisClientConnectionManager": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRedisClientConnectionManager():
    TypeOnly<current.IRedisClientConnectionManager>;
declare function use_old_InterfaceDeclaration_IRedisClientConnectionManager(
    use: TypeOnly<old.IRedisClientConnectionManager>): void;
use_old_InterfaceDeclaration_IRedisClientConnectionManager(
    get_current_InterfaceDeclaration_IRedisClientConnectionManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRedisParameters": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRedisParameters():
    TypeOnly<old.IRedisParameters>;
declare function use_current_InterfaceDeclaration_IRedisParameters(
    use: TypeOnly<current.IRedisParameters>): void;
use_current_InterfaceDeclaration_IRedisParameters(
    get_old_InterfaceDeclaration_IRedisParameters());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRedisParameters": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRedisParameters():
    TypeOnly<current.IRedisParameters>;
declare function use_old_InterfaceDeclaration_IRedisParameters(
    use: TypeOnly<old.IRedisParameters>): void;
use_old_InterfaceDeclaration_IRedisParameters(
    get_current_InterfaceDeclaration_IRedisParameters());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISimpleThrottleConfig": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISimpleThrottleConfig():
    TypeOnly<old.ISimpleThrottleConfig>;
declare function use_current_InterfaceDeclaration_ISimpleThrottleConfig(
    use: TypeOnly<current.ISimpleThrottleConfig>): void;
use_current_InterfaceDeclaration_ISimpleThrottleConfig(
    get_old_InterfaceDeclaration_ISimpleThrottleConfig());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISimpleThrottleConfig": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISimpleThrottleConfig():
    TypeOnly<current.ISimpleThrottleConfig>;
declare function use_old_InterfaceDeclaration_ISimpleThrottleConfig(
    use: TypeOnly<old.ISimpleThrottleConfig>): void;
use_old_InterfaceDeclaration_ISimpleThrottleConfig(
    get_current_InterfaceDeclaration_ISimpleThrottleConfig());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITenantKeyGenerator": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITenantKeyGenerator():
    TypeOnly<old.ITenantKeyGenerator>;
declare function use_current_InterfaceDeclaration_ITenantKeyGenerator(
    use: TypeOnly<current.ITenantKeyGenerator>): void;
use_current_InterfaceDeclaration_ITenantKeyGenerator(
    get_old_InterfaceDeclaration_ITenantKeyGenerator());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITenantKeyGenerator": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITenantKeyGenerator():
    TypeOnly<current.ITenantKeyGenerator>;
declare function use_old_InterfaceDeclaration_ITenantKeyGenerator(
    use: TypeOnly<old.ITenantKeyGenerator>): void;
use_old_InterfaceDeclaration_ITenantKeyGenerator(
    get_current_InterfaceDeclaration_ITenantKeyGenerator());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottleConfig": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IThrottleConfig():
    TypeOnly<old.IThrottleConfig>;
declare function use_current_InterfaceDeclaration_IThrottleConfig(
    use: TypeOnly<current.IThrottleConfig>): void;
use_current_InterfaceDeclaration_IThrottleConfig(
    get_old_InterfaceDeclaration_IThrottleConfig());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottleConfig": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IThrottleConfig():
    TypeOnly<current.IThrottleConfig>;
declare function use_old_InterfaceDeclaration_IThrottleConfig(
    use: TypeOnly<old.IThrottleConfig>): void;
use_old_InterfaceDeclaration_IThrottleConfig(
    get_current_InterfaceDeclaration_IThrottleConfig());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottleMiddlewareOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IThrottleMiddlewareOptions():
    TypeOnly<old.IThrottleMiddlewareOptions>;
declare function use_current_InterfaceDeclaration_IThrottleMiddlewareOptions(
    use: TypeOnly<current.IThrottleMiddlewareOptions>): void;
use_current_InterfaceDeclaration_IThrottleMiddlewareOptions(
    get_old_InterfaceDeclaration_IThrottleMiddlewareOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottleMiddlewareOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IThrottleMiddlewareOptions():
    TypeOnly<current.IThrottleMiddlewareOptions>;
declare function use_old_InterfaceDeclaration_IThrottleMiddlewareOptions(
    use: TypeOnly<old.IThrottleMiddlewareOptions>): void;
use_old_InterfaceDeclaration_IThrottleMiddlewareOptions(
    get_current_InterfaceDeclaration_IThrottleMiddlewareOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWinstonConfig": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IWinstonConfig():
    TypeOnly<old.IWinstonConfig>;
declare function use_current_InterfaceDeclaration_IWinstonConfig(
    use: TypeOnly<current.IWinstonConfig>): void;
use_current_InterfaceDeclaration_IWinstonConfig(
    get_old_InterfaceDeclaration_IWinstonConfig());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWinstonConfig": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IWinstonConfig():
    TypeOnly<current.IWinstonConfig>;
declare function use_old_InterfaceDeclaration_IWinstonConfig(
    use: TypeOnly<old.IWinstonConfig>): void;
use_old_InterfaceDeclaration_IWinstonConfig(
    get_current_InterfaceDeclaration_IWinstonConfig());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_InMemoryApiCounters": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_InMemoryApiCounters():
    TypeOnly<old.InMemoryApiCounters>;
declare function use_current_ClassDeclaration_InMemoryApiCounters(
    use: TypeOnly<current.InMemoryApiCounters>): void;
use_current_ClassDeclaration_InMemoryApiCounters(
    get_old_ClassDeclaration_InMemoryApiCounters());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_InMemoryApiCounters": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_InMemoryApiCounters():
    TypeOnly<current.InMemoryApiCounters>;
declare function use_old_ClassDeclaration_InMemoryApiCounters(
    use: TypeOnly<old.InMemoryApiCounters>): void;
use_old_ClassDeclaration_InMemoryApiCounters(
    get_current_ClassDeclaration_InMemoryApiCounters());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_RedisClientConnectionManager": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_RedisClientConnectionManager():
    TypeOnly<old.RedisClientConnectionManager>;
declare function use_current_ClassDeclaration_RedisClientConnectionManager(
    use: TypeOnly<current.RedisClientConnectionManager>): void;
use_current_ClassDeclaration_RedisClientConnectionManager(
    get_old_ClassDeclaration_RedisClientConnectionManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_RedisClientConnectionManager": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_RedisClientConnectionManager():
    TypeOnly<current.RedisClientConnectionManager>;
declare function use_old_ClassDeclaration_RedisClientConnectionManager(
    use: TypeOnly<old.RedisClientConnectionManager>): void;
use_old_ClassDeclaration_RedisClientConnectionManager(
    get_current_ClassDeclaration_RedisClientConnectionManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ScheduledJob": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ScheduledJob():
    TypeOnly<old.ScheduledJob>;
declare function use_current_ClassDeclaration_ScheduledJob(
    use: TypeOnly<current.ScheduledJob>): void;
use_current_ClassDeclaration_ScheduledJob(
    get_old_ClassDeclaration_ScheduledJob());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ScheduledJob": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ScheduledJob():
    TypeOnly<current.ScheduledJob>;
declare function use_old_ClassDeclaration_ScheduledJob(
    use: TypeOnly<old.ScheduledJob>): void;
use_old_ClassDeclaration_ScheduledJob(
    get_current_ClassDeclaration_ScheduledJob());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TenantKeyGenerator": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_TenantKeyGenerator():
    TypeOnly<old.TenantKeyGenerator>;
declare function use_current_ClassDeclaration_TenantKeyGenerator(
    use: TypeOnly<current.TenantKeyGenerator>): void;
use_current_ClassDeclaration_TenantKeyGenerator(
    get_old_ClassDeclaration_TenantKeyGenerator());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_TenantKeyGenerator": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_TenantKeyGenerator():
    TypeOnly<current.TenantKeyGenerator>;
declare function use_old_ClassDeclaration_TenantKeyGenerator(
    use: TypeOnly<old.TenantKeyGenerator>): void;
use_old_ClassDeclaration_TenantKeyGenerator(
    get_current_ClassDeclaration_TenantKeyGenerator());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_WebSocketTracker": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_WebSocketTracker():
    TypeOnly<old.WebSocketTracker>;
declare function use_current_ClassDeclaration_WebSocketTracker(
    use: TypeOnly<current.WebSocketTracker>): void;
use_current_ClassDeclaration_WebSocketTracker(
    get_old_ClassDeclaration_WebSocketTracker());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_WebSocketTracker": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_WebSocketTracker():
    TypeOnly<current.WebSocketTracker>;
declare function use_old_ClassDeclaration_WebSocketTracker(
    use: TypeOnly<old.WebSocketTracker>): void;
use_old_ClassDeclaration_WebSocketTracker(
    get_current_ClassDeclaration_WebSocketTracker());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_WinstonLumberjackEngine": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_WinstonLumberjackEngine():
    TypeOnly<old.WinstonLumberjackEngine>;
declare function use_current_ClassDeclaration_WinstonLumberjackEngine(
    use: TypeOnly<current.WinstonLumberjackEngine>): void;
use_current_ClassDeclaration_WinstonLumberjackEngine(
    get_old_ClassDeclaration_WinstonLumberjackEngine());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_WinstonLumberjackEngine": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_WinstonLumberjackEngine():
    TypeOnly<current.WinstonLumberjackEngine>;
declare function use_old_ClassDeclaration_WinstonLumberjackEngine(
    use: TypeOnly<old.WinstonLumberjackEngine>): void;
use_old_ClassDeclaration_WinstonLumberjackEngine(
    get_current_ClassDeclaration_WinstonLumberjackEngine());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_alternativeMorganLoggerMiddleware": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_alternativeMorganLoggerMiddleware():
    TypeOnly<typeof old.alternativeMorganLoggerMiddleware>;
declare function use_current_FunctionDeclaration_alternativeMorganLoggerMiddleware(
    use: TypeOnly<typeof current.alternativeMorganLoggerMiddleware>): void;
use_current_FunctionDeclaration_alternativeMorganLoggerMiddleware(
    get_old_FunctionDeclaration_alternativeMorganLoggerMiddleware());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_alternativeMorganLoggerMiddleware": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_alternativeMorganLoggerMiddleware():
    TypeOnly<typeof current.alternativeMorganLoggerMiddleware>;
declare function use_old_FunctionDeclaration_alternativeMorganLoggerMiddleware(
    use: TypeOnly<typeof old.alternativeMorganLoggerMiddleware>): void;
use_old_FunctionDeclaration_alternativeMorganLoggerMiddleware(
    get_current_FunctionDeclaration_alternativeMorganLoggerMiddleware());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_bindCorrelationId": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_bindCorrelationId():
    TypeOnly<typeof old.bindCorrelationId>;
declare function use_current_VariableDeclaration_bindCorrelationId(
    use: TypeOnly<typeof current.bindCorrelationId>): void;
use_current_VariableDeclaration_bindCorrelationId(
    get_old_VariableDeclaration_bindCorrelationId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_bindCorrelationId": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_bindCorrelationId():
    TypeOnly<typeof current.bindCorrelationId>;
declare function use_old_VariableDeclaration_bindCorrelationId(
    use: TypeOnly<typeof old.bindCorrelationId>): void;
use_old_VariableDeclaration_bindCorrelationId(
    get_current_VariableDeclaration_bindCorrelationId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_bindTelemetryContext": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_bindTelemetryContext():
    TypeOnly<typeof old.bindTelemetryContext>;
declare function use_current_VariableDeclaration_bindTelemetryContext(
    use: TypeOnly<typeof current.bindTelemetryContext>): void;
use_current_VariableDeclaration_bindTelemetryContext(
    get_old_VariableDeclaration_bindTelemetryContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_bindTelemetryContext": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_bindTelemetryContext():
    TypeOnly<typeof current.bindTelemetryContext>;
declare function use_old_VariableDeclaration_bindTelemetryContext(
    use: TypeOnly<typeof old.bindTelemetryContext>): void;
use_old_VariableDeclaration_bindTelemetryContext(
    get_current_VariableDeclaration_bindTelemetryContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_bindTimeoutContext": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_bindTimeoutContext():
    TypeOnly<typeof old.bindTimeoutContext>;
declare function use_current_VariableDeclaration_bindTimeoutContext(
    use: TypeOnly<typeof current.bindTimeoutContext>): void;
use_current_VariableDeclaration_bindTimeoutContext(
    get_old_VariableDeclaration_bindTimeoutContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_bindTimeoutContext": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_bindTimeoutContext():
    TypeOnly<typeof current.bindTimeoutContext>;
declare function use_old_VariableDeclaration_bindTimeoutContext(
    use: TypeOnly<typeof old.bindTimeoutContext>): void;
use_old_VariableDeclaration_bindTimeoutContext(
    get_current_VariableDeclaration_bindTimeoutContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_choose": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_choose():
    TypeOnly<typeof old.choose>;
declare function use_current_VariableDeclaration_choose(
    use: TypeOnly<typeof current.choose>): void;
use_current_VariableDeclaration_choose(
    get_old_VariableDeclaration_choose());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_choose": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_choose():
    TypeOnly<typeof current.choose>;
declare function use_old_VariableDeclaration_choose(
    use: TypeOnly<typeof old.choose>): void;
use_old_VariableDeclaration_choose(
    get_current_VariableDeclaration_choose());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_configureGlobalTelemetryContext": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_configureGlobalTelemetryContext():
    TypeOnly<typeof old.configureGlobalTelemetryContext>;
declare function use_current_FunctionDeclaration_configureGlobalTelemetryContext(
    use: TypeOnly<typeof current.configureGlobalTelemetryContext>): void;
use_current_FunctionDeclaration_configureGlobalTelemetryContext(
    get_old_FunctionDeclaration_configureGlobalTelemetryContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_configureGlobalTelemetryContext": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_configureGlobalTelemetryContext():
    TypeOnly<typeof current.configureGlobalTelemetryContext>;
declare function use_old_FunctionDeclaration_configureGlobalTelemetryContext(
    use: TypeOnly<typeof old.configureGlobalTelemetryContext>): void;
use_old_FunctionDeclaration_configureGlobalTelemetryContext(
    get_current_FunctionDeclaration_configureGlobalTelemetryContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_configureGlobalTimeoutContext": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_configureGlobalTimeoutContext():
    TypeOnly<typeof old.configureGlobalTimeoutContext>;
declare function use_current_FunctionDeclaration_configureGlobalTimeoutContext(
    use: TypeOnly<typeof current.configureGlobalTimeoutContext>): void;
use_current_FunctionDeclaration_configureGlobalTimeoutContext(
    get_old_FunctionDeclaration_configureGlobalTimeoutContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_configureGlobalTimeoutContext": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_configureGlobalTimeoutContext():
    TypeOnly<typeof current.configureGlobalTimeoutContext>;
declare function use_old_FunctionDeclaration_configureGlobalTimeoutContext(
    use: TypeOnly<typeof old.configureGlobalTimeoutContext>): void;
use_old_FunctionDeclaration_configureGlobalTimeoutContext(
    get_current_FunctionDeclaration_configureGlobalTimeoutContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_configureLogging": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_configureLogging():
    TypeOnly<typeof old.configureLogging>;
declare function use_current_FunctionDeclaration_configureLogging(
    use: TypeOnly<typeof current.configureLogging>): void;
use_current_FunctionDeclaration_configureLogging(
    get_old_FunctionDeclaration_configureLogging());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_configureLogging": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_configureLogging():
    TypeOnly<typeof current.configureLogging>;
declare function use_old_FunctionDeclaration_configureLogging(
    use: TypeOnly<typeof old.configureLogging>): void;
use_old_FunctionDeclaration_configureLogging(
    get_current_FunctionDeclaration_configureLogging());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_deleteSummarizedOps": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_deleteSummarizedOps():
    TypeOnly<typeof old.deleteSummarizedOps>;
declare function use_current_FunctionDeclaration_deleteSummarizedOps(
    use: TypeOnly<typeof current.deleteSummarizedOps>): void;
use_current_FunctionDeclaration_deleteSummarizedOps(
    get_old_FunctionDeclaration_deleteSummarizedOps());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_deleteSummarizedOps": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_deleteSummarizedOps():
    TypeOnly<typeof current.deleteSummarizedOps>;
declare function use_old_FunctionDeclaration_deleteSummarizedOps(
    use: TypeOnly<typeof old.deleteSummarizedOps>): void;
use_old_FunctionDeclaration_deleteSummarizedOps(
    get_current_FunctionDeclaration_deleteSummarizedOps());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_executeApiWithMetric": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_executeApiWithMetric():
    TypeOnly<typeof old.executeApiWithMetric>;
declare function use_current_FunctionDeclaration_executeApiWithMetric(
    use: TypeOnly<typeof current.executeApiWithMetric>): void;
use_current_FunctionDeclaration_executeApiWithMetric(
    get_old_FunctionDeclaration_executeApiWithMetric());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_executeApiWithMetric": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_executeApiWithMetric():
    TypeOnly<typeof current.executeApiWithMetric>;
declare function use_old_FunctionDeclaration_executeApiWithMetric(
    use: TypeOnly<typeof old.executeApiWithMetric>): void;
use_old_FunctionDeclaration_executeApiWithMetric(
    get_current_FunctionDeclaration_executeApiWithMetric());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_executeOnInterval": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_executeOnInterval():
    TypeOnly<typeof old.executeOnInterval>;
declare function use_current_FunctionDeclaration_executeOnInterval(
    use: TypeOnly<typeof current.executeOnInterval>): void;
use_current_FunctionDeclaration_executeOnInterval(
    get_old_FunctionDeclaration_executeOnInterval());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_executeOnInterval": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_executeOnInterval():
    TypeOnly<typeof current.executeOnInterval>;
declare function use_old_FunctionDeclaration_executeOnInterval(
    use: TypeOnly<typeof old.executeOnInterval>): void;
use_old_FunctionDeclaration_executeOnInterval(
    get_current_FunctionDeclaration_executeOnInterval());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_executeRedisMultiWithHmsetExpire": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_executeRedisMultiWithHmsetExpire():
    TypeOnly<typeof old.executeRedisMultiWithHmsetExpire>;
declare function use_current_VariableDeclaration_executeRedisMultiWithHmsetExpire(
    use: TypeOnly<typeof current.executeRedisMultiWithHmsetExpire>): void;
use_current_VariableDeclaration_executeRedisMultiWithHmsetExpire(
    get_old_VariableDeclaration_executeRedisMultiWithHmsetExpire());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_executeRedisMultiWithHmsetExpire": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_executeRedisMultiWithHmsetExpire():
    TypeOnly<typeof current.executeRedisMultiWithHmsetExpire>;
declare function use_old_VariableDeclaration_executeRedisMultiWithHmsetExpire(
    use: TypeOnly<typeof old.executeRedisMultiWithHmsetExpire>): void;
use_old_VariableDeclaration_executeRedisMultiWithHmsetExpire(
    get_current_VariableDeclaration_executeRedisMultiWithHmsetExpire());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_executeRedisMultiWithHmsetExpireAndLpush": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_executeRedisMultiWithHmsetExpireAndLpush():
    TypeOnly<typeof old.executeRedisMultiWithHmsetExpireAndLpush>;
declare function use_current_VariableDeclaration_executeRedisMultiWithHmsetExpireAndLpush(
    use: TypeOnly<typeof current.executeRedisMultiWithHmsetExpireAndLpush>): void;
use_current_VariableDeclaration_executeRedisMultiWithHmsetExpireAndLpush(
    get_old_VariableDeclaration_executeRedisMultiWithHmsetExpireAndLpush());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_executeRedisMultiWithHmsetExpireAndLpush": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_executeRedisMultiWithHmsetExpireAndLpush():
    TypeOnly<typeof current.executeRedisMultiWithHmsetExpireAndLpush>;
declare function use_old_VariableDeclaration_executeRedisMultiWithHmsetExpireAndLpush(
    use: TypeOnly<typeof old.executeRedisMultiWithHmsetExpireAndLpush>): void;
use_old_VariableDeclaration_executeRedisMultiWithHmsetExpireAndLpush(
    get_current_VariableDeclaration_executeRedisMultiWithHmsetExpireAndLpush());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateToken": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_generateToken():
    TypeOnly<typeof old.generateToken>;
declare function use_current_FunctionDeclaration_generateToken(
    use: TypeOnly<typeof current.generateToken>): void;
use_current_FunctionDeclaration_generateToken(
    get_old_FunctionDeclaration_generateToken());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateToken": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_generateToken():
    TypeOnly<typeof current.generateToken>;
declare function use_old_FunctionDeclaration_generateToken(
    use: TypeOnly<typeof old.generateToken>): void;
use_old_FunctionDeclaration_generateToken(
    get_current_FunctionDeclaration_generateToken());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateUser": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_generateUser():
    TypeOnly<typeof old.generateUser>;
declare function use_current_FunctionDeclaration_generateUser(
    use: TypeOnly<typeof current.generateUser>): void;
use_current_FunctionDeclaration_generateUser(
    get_old_FunctionDeclaration_generateUser());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateUser": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_generateUser():
    TypeOnly<typeof current.generateUser>;
declare function use_old_FunctionDeclaration_generateUser(
    use: TypeOnly<typeof old.generateUser>): void;
use_old_FunctionDeclaration_generateUser(
    get_current_FunctionDeclaration_generateUser());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getBooleanFromConfig": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getBooleanFromConfig():
    TypeOnly<typeof old.getBooleanFromConfig>;
declare function use_current_FunctionDeclaration_getBooleanFromConfig(
    use: TypeOnly<typeof current.getBooleanFromConfig>): void;
use_current_FunctionDeclaration_getBooleanFromConfig(
    get_old_FunctionDeclaration_getBooleanFromConfig());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getBooleanFromConfig": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getBooleanFromConfig():
    TypeOnly<typeof current.getBooleanFromConfig>;
declare function use_old_FunctionDeclaration_getBooleanFromConfig(
    use: TypeOnly<typeof old.getBooleanFromConfig>): void;
use_old_FunctionDeclaration_getBooleanFromConfig(
    get_current_FunctionDeclaration_getBooleanFromConfig());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getCorrelationId": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getCorrelationId():
    TypeOnly<typeof old.getCorrelationId>;
declare function use_current_FunctionDeclaration_getCorrelationId(
    use: TypeOnly<typeof current.getCorrelationId>): void;
use_current_FunctionDeclaration_getCorrelationId(
    get_old_FunctionDeclaration_getCorrelationId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getCorrelationId": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getCorrelationId():
    TypeOnly<typeof current.getCorrelationId>;
declare function use_old_FunctionDeclaration_getCorrelationId(
    use: TypeOnly<typeof old.getCorrelationId>): void;
use_old_FunctionDeclaration_getCorrelationId(
    get_current_FunctionDeclaration_getCorrelationId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getCorrelationIdWithHttpFallback": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getCorrelationIdWithHttpFallback():
    TypeOnly<typeof old.getCorrelationIdWithHttpFallback>;
declare function use_current_FunctionDeclaration_getCorrelationIdWithHttpFallback(
    use: TypeOnly<typeof current.getCorrelationIdWithHttpFallback>): void;
use_current_FunctionDeclaration_getCorrelationIdWithHttpFallback(
    get_old_FunctionDeclaration_getCorrelationIdWithHttpFallback());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getCorrelationIdWithHttpFallback": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getCorrelationIdWithHttpFallback():
    TypeOnly<typeof current.getCorrelationIdWithHttpFallback>;
declare function use_old_FunctionDeclaration_getCorrelationIdWithHttpFallback(
    use: TypeOnly<typeof old.getCorrelationIdWithHttpFallback>): void;
use_old_FunctionDeclaration_getCorrelationIdWithHttpFallback(
    get_current_FunctionDeclaration_getCorrelationIdWithHttpFallback());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getCreationToken": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getCreationToken():
    TypeOnly<typeof old.getCreationToken>;
declare function use_current_FunctionDeclaration_getCreationToken(
    use: TypeOnly<typeof current.getCreationToken>): void;
use_current_FunctionDeclaration_getCreationToken(
    get_old_FunctionDeclaration_getCreationToken());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getCreationToken": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getCreationToken():
    TypeOnly<typeof current.getCreationToken>;
declare function use_old_FunctionDeclaration_getCreationToken(
    use: TypeOnly<typeof old.getCreationToken>): void;
use_old_FunctionDeclaration_getCreationToken(
    get_current_FunctionDeclaration_getCreationToken());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getHostIp": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getHostIp():
    TypeOnly<typeof old.getHostIp>;
declare function use_current_FunctionDeclaration_getHostIp(
    use: TypeOnly<typeof current.getHostIp>): void;
use_current_FunctionDeclaration_getHostIp(
    get_old_FunctionDeclaration_getHostIp());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getHostIp": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getHostIp():
    TypeOnly<typeof current.getHostIp>;
declare function use_old_FunctionDeclaration_getHostIp(
    use: TypeOnly<typeof old.getHostIp>): void;
use_old_FunctionDeclaration_getHostIp(
    get_current_FunctionDeclaration_getHostIp());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getNumberFromConfig": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getNumberFromConfig():
    TypeOnly<typeof old.getNumberFromConfig>;
declare function use_current_FunctionDeclaration_getNumberFromConfig(
    use: TypeOnly<typeof current.getNumberFromConfig>): void;
use_current_FunctionDeclaration_getNumberFromConfig(
    get_old_FunctionDeclaration_getNumberFromConfig());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getNumberFromConfig": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getNumberFromConfig():
    TypeOnly<typeof current.getNumberFromConfig>;
declare function use_old_FunctionDeclaration_getNumberFromConfig(
    use: TypeOnly<typeof old.getNumberFromConfig>): void;
use_old_FunctionDeclaration_getNumberFromConfig(
    get_current_FunctionDeclaration_getNumberFromConfig());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getParam": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getParam():
    TypeOnly<typeof old.getParam>;
declare function use_current_FunctionDeclaration_getParam(
    use: TypeOnly<typeof current.getParam>): void;
use_current_FunctionDeclaration_getParam(
    get_old_FunctionDeclaration_getParam());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getParam": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getParam():
    TypeOnly<typeof current.getParam>;
declare function use_old_FunctionDeclaration_getParam(
    use: TypeOnly<typeof old.getParam>): void;
use_old_FunctionDeclaration_getParam(
    get_current_FunctionDeclaration_getParam());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getRandomName": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getRandomName():
    TypeOnly<typeof old.getRandomName>;
declare function use_current_FunctionDeclaration_getRandomName(
    use: TypeOnly<typeof current.getRandomName>): void;
use_current_FunctionDeclaration_getRandomName(
    get_old_FunctionDeclaration_getRandomName());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getRandomName": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getRandomName():
    TypeOnly<typeof current.getRandomName>;
declare function use_old_FunctionDeclaration_getRandomName(
    use: TypeOnly<typeof old.getRandomName>): void;
use_old_FunctionDeclaration_getRandomName(
    get_current_FunctionDeclaration_getRandomName());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getRedisClusterRetryStrategy": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_getRedisClusterRetryStrategy():
    TypeOnly<typeof old.getRedisClusterRetryStrategy>;
declare function use_current_VariableDeclaration_getRedisClusterRetryStrategy(
    use: TypeOnly<typeof current.getRedisClusterRetryStrategy>): void;
use_current_VariableDeclaration_getRedisClusterRetryStrategy(
    get_old_VariableDeclaration_getRedisClusterRetryStrategy());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getRedisClusterRetryStrategy": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_getRedisClusterRetryStrategy():
    TypeOnly<typeof current.getRedisClusterRetryStrategy>;
declare function use_old_VariableDeclaration_getRedisClusterRetryStrategy(
    use: TypeOnly<typeof old.getRedisClusterRetryStrategy>): void;
use_old_VariableDeclaration_getRedisClusterRetryStrategy(
    get_current_VariableDeclaration_getRedisClusterRetryStrategy());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getTelemetryContextPropertiesWithHttpInfo": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getTelemetryContextPropertiesWithHttpInfo():
    TypeOnly<typeof old.getTelemetryContextPropertiesWithHttpInfo>;
declare function use_current_FunctionDeclaration_getTelemetryContextPropertiesWithHttpInfo(
    use: TypeOnly<typeof current.getTelemetryContextPropertiesWithHttpInfo>): void;
use_current_FunctionDeclaration_getTelemetryContextPropertiesWithHttpInfo(
    get_old_FunctionDeclaration_getTelemetryContextPropertiesWithHttpInfo());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getTelemetryContextPropertiesWithHttpInfo": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getTelemetryContextPropertiesWithHttpInfo():
    TypeOnly<typeof current.getTelemetryContextPropertiesWithHttpInfo>;
declare function use_old_FunctionDeclaration_getTelemetryContextPropertiesWithHttpInfo(
    use: TypeOnly<typeof old.getTelemetryContextPropertiesWithHttpInfo>): void;
use_old_FunctionDeclaration_getTelemetryContextPropertiesWithHttpInfo(
    get_current_FunctionDeclaration_getTelemetryContextPropertiesWithHttpInfo());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getThrottleConfig": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_getThrottleConfig():
    TypeOnly<typeof old.getThrottleConfig>;
declare function use_current_VariableDeclaration_getThrottleConfig(
    use: TypeOnly<typeof current.getThrottleConfig>): void;
use_current_VariableDeclaration_getThrottleConfig(
    get_old_VariableDeclaration_getThrottleConfig());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getThrottleConfig": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_getThrottleConfig():
    TypeOnly<typeof current.getThrottleConfig>;
declare function use_old_VariableDeclaration_getThrottleConfig(
    use: TypeOnly<typeof old.getThrottleConfig>): void;
use_old_VariableDeclaration_getThrottleConfig(
    get_current_VariableDeclaration_getThrottleConfig());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_jsonMorganLoggerMiddleware": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_jsonMorganLoggerMiddleware():
    TypeOnly<typeof old.jsonMorganLoggerMiddleware>;
declare function use_current_FunctionDeclaration_jsonMorganLoggerMiddleware(
    use: TypeOnly<typeof current.jsonMorganLoggerMiddleware>): void;
use_current_FunctionDeclaration_jsonMorganLoggerMiddleware(
    get_old_FunctionDeclaration_jsonMorganLoggerMiddleware());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_jsonMorganLoggerMiddleware": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_jsonMorganLoggerMiddleware():
    TypeOnly<typeof current.jsonMorganLoggerMiddleware>;
declare function use_old_FunctionDeclaration_jsonMorganLoggerMiddleware(
    use: TypeOnly<typeof old.jsonMorganLoggerMiddleware>): void;
use_old_FunctionDeclaration_jsonMorganLoggerMiddleware(
    get_current_FunctionDeclaration_jsonMorganLoggerMiddleware());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_normalizePort": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_normalizePort():
    TypeOnly<typeof old.normalizePort>;
declare function use_current_FunctionDeclaration_normalizePort(
    use: TypeOnly<typeof current.normalizePort>): void;
use_current_FunctionDeclaration_normalizePort(
    get_old_FunctionDeclaration_normalizePort());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_normalizePort": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_normalizePort():
    TypeOnly<typeof current.normalizePort>;
declare function use_old_FunctionDeclaration_normalizePort(
    use: TypeOnly<typeof old.normalizePort>): void;
use_old_FunctionDeclaration_normalizePort(
    get_current_FunctionDeclaration_normalizePort());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_parseBoolean": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_parseBoolean():
    TypeOnly<typeof old.parseBoolean>;
declare function use_current_VariableDeclaration_parseBoolean(
    use: TypeOnly<typeof current.parseBoolean>): void;
use_current_VariableDeclaration_parseBoolean(
    get_old_VariableDeclaration_parseBoolean());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_parseBoolean": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_parseBoolean():
    TypeOnly<typeof current.parseBoolean>;
declare function use_old_VariableDeclaration_parseBoolean(
    use: TypeOnly<typeof old.parseBoolean>): void;
use_old_VariableDeclaration_parseBoolean(
    get_current_VariableDeclaration_parseBoolean());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_respondWithNetworkError": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_respondWithNetworkError():
    TypeOnly<typeof old.respondWithNetworkError>;
declare function use_current_FunctionDeclaration_respondWithNetworkError(
    use: TypeOnly<typeof current.respondWithNetworkError>): void;
use_current_FunctionDeclaration_respondWithNetworkError(
    get_old_FunctionDeclaration_respondWithNetworkError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_respondWithNetworkError": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_respondWithNetworkError():
    TypeOnly<typeof current.respondWithNetworkError>;
declare function use_old_FunctionDeclaration_respondWithNetworkError(
    use: TypeOnly<typeof old.respondWithNetworkError>): void;
use_old_FunctionDeclaration_respondWithNetworkError(
    get_current_FunctionDeclaration_respondWithNetworkError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_throttle": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_throttle():
    TypeOnly<typeof old.throttle>;
declare function use_current_FunctionDeclaration_throttle(
    use: TypeOnly<typeof current.throttle>): void;
use_current_FunctionDeclaration_throttle(
    get_old_FunctionDeclaration_throttle());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_throttle": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_throttle():
    TypeOnly<typeof current.throttle>;
declare function use_old_FunctionDeclaration_throttle(
    use: TypeOnly<typeof old.throttle>): void;
use_old_FunctionDeclaration_throttle(
    get_current_FunctionDeclaration_throttle());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_validateTokenClaims": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_validateTokenClaims():
    TypeOnly<typeof old.validateTokenClaims>;
declare function use_current_FunctionDeclaration_validateTokenClaims(
    use: TypeOnly<typeof current.validateTokenClaims>): void;
use_current_FunctionDeclaration_validateTokenClaims(
    get_old_FunctionDeclaration_validateTokenClaims());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_validateTokenClaims": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_validateTokenClaims():
    TypeOnly<typeof current.validateTokenClaims>;
declare function use_old_FunctionDeclaration_validateTokenClaims(
    use: TypeOnly<typeof old.validateTokenClaims>): void;
use_old_FunctionDeclaration_validateTokenClaims(
    get_current_FunctionDeclaration_validateTokenClaims());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_validateTokenScopeClaims": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_validateTokenScopeClaims():
    TypeOnly<typeof old.validateTokenScopeClaims>;
declare function use_current_FunctionDeclaration_validateTokenScopeClaims(
    use: TypeOnly<typeof current.validateTokenScopeClaims>): void;
use_current_FunctionDeclaration_validateTokenScopeClaims(
    get_old_FunctionDeclaration_validateTokenScopeClaims());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_validateTokenScopeClaims": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_validateTokenScopeClaims():
    TypeOnly<typeof current.validateTokenScopeClaims>;
declare function use_old_FunctionDeclaration_validateTokenScopeClaims(
    use: TypeOnly<typeof old.validateTokenScopeClaims>): void;
use_old_FunctionDeclaration_validateTokenScopeClaims(
    get_current_FunctionDeclaration_validateTokenScopeClaims());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_verifyStorageToken": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_verifyStorageToken():
    TypeOnly<typeof old.verifyStorageToken>;
declare function use_current_FunctionDeclaration_verifyStorageToken(
    use: TypeOnly<typeof current.verifyStorageToken>): void;
use_current_FunctionDeclaration_verifyStorageToken(
    get_old_FunctionDeclaration_verifyStorageToken());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_verifyStorageToken": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_verifyStorageToken():
    TypeOnly<typeof current.verifyStorageToken>;
declare function use_old_FunctionDeclaration_verifyStorageToken(
    use: TypeOnly<typeof old.verifyStorageToken>): void;
use_old_FunctionDeclaration_verifyStorageToken(
    get_current_FunctionDeclaration_verifyStorageToken());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_verifyToken": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_verifyToken():
    TypeOnly<typeof old.verifyToken>;
declare function use_current_FunctionDeclaration_verifyToken(
    use: TypeOnly<typeof current.verifyToken>): void;
use_current_FunctionDeclaration_verifyToken(
    get_old_FunctionDeclaration_verifyToken());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_verifyToken": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_verifyToken():
    TypeOnly<typeof current.verifyToken>;
declare function use_old_FunctionDeclaration_verifyToken(
    use: TypeOnly<typeof old.verifyToken>): void;
use_old_FunctionDeclaration_verifyToken(
    get_current_FunctionDeclaration_verifyToken());
