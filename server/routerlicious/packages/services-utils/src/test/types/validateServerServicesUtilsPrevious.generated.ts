/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/server-services-utils-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_AsyncLocalStorageContextProvider": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_AsyncLocalStorageContextProvider = requireAssignableTo<TypeOnly<old.AsyncLocalStorageContextProvider<never>>, TypeOnly<current.AsyncLocalStorageContextProvider<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_AsyncLocalStorageContextProvider": {"backCompat": false}
 */
declare type current_as_old_for_Class_AsyncLocalStorageContextProvider = requireAssignableTo<TypeOnly<current.AsyncLocalStorageContextProvider<never>>, TypeOnly<old.AsyncLocalStorageContextProvider<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_AsyncLocalStorageTelemetryContext": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_AsyncLocalStorageTelemetryContext = requireAssignableTo<TypeOnly<old.AsyncLocalStorageTelemetryContext>, TypeOnly<current.AsyncLocalStorageTelemetryContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_AsyncLocalStorageTelemetryContext": {"backCompat": false}
 */
declare type current_as_old_for_Class_AsyncLocalStorageTelemetryContext = requireAssignableTo<TypeOnly<current.AsyncLocalStorageTelemetryContext>, TypeOnly<old.AsyncLocalStorageTelemetryContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_AsyncLocalStorageTimeoutContext": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_AsyncLocalStorageTimeoutContext = requireAssignableTo<TypeOnly<old.AsyncLocalStorageTimeoutContext>, TypeOnly<current.AsyncLocalStorageTimeoutContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_AsyncLocalStorageTimeoutContext": {"backCompat": false}
 */
declare type current_as_old_for_Class_AsyncLocalStorageTimeoutContext = requireAssignableTo<TypeOnly<current.AsyncLocalStorageTimeoutContext>, TypeOnly<old.AsyncLocalStorageTimeoutContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DummyRevokedTokenChecker": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_DummyRevokedTokenChecker = requireAssignableTo<TypeOnly<old.DummyRevokedTokenChecker>, TypeOnly<current.DummyRevokedTokenChecker>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DummyRevokedTokenChecker": {"backCompat": false}
 */
declare type current_as_old_for_Class_DummyRevokedTokenChecker = requireAssignableTo<TypeOnly<current.DummyRevokedTokenChecker>, TypeOnly<old.DummyRevokedTokenChecker>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DummyTokenRevocationManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_DummyTokenRevocationManager = requireAssignableTo<TypeOnly<old.DummyTokenRevocationManager>, TypeOnly<current.DummyTokenRevocationManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_DummyTokenRevocationManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_DummyTokenRevocationManager = requireAssignableTo<TypeOnly<current.DummyTokenRevocationManager>, TypeOnly<old.DummyTokenRevocationManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_FluidServiceError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_FluidServiceError = requireAssignableTo<TypeOnly<old.FluidServiceError>, TypeOnly<current.FluidServiceError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_FluidServiceError": {"backCompat": false}
 */
declare type current_as_old_for_Class_FluidServiceError = requireAssignableTo<TypeOnly<current.FluidServiceError>, TypeOnly<old.FluidServiceError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_InMemoryApiCounters": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_InMemoryApiCounters = requireAssignableTo<TypeOnly<old.InMemoryApiCounters>, TypeOnly<current.InMemoryApiCounters>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_InMemoryApiCounters": {"backCompat": false}
 */
declare type current_as_old_for_Class_InMemoryApiCounters = requireAssignableTo<TypeOnly<current.InMemoryApiCounters>, TypeOnly<old.InMemoryApiCounters>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RedisClientConnectionManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_RedisClientConnectionManager = requireAssignableTo<TypeOnly<old.RedisClientConnectionManager>, TypeOnly<current.RedisClientConnectionManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RedisClientConnectionManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_RedisClientConnectionManager = requireAssignableTo<TypeOnly<current.RedisClientConnectionManager>, TypeOnly<old.RedisClientConnectionManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ScheduledJob": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_ScheduledJob = requireAssignableTo<TypeOnly<old.ScheduledJob>, TypeOnly<current.ScheduledJob>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ScheduledJob": {"backCompat": false}
 */
declare type current_as_old_for_Class_ScheduledJob = requireAssignableTo<TypeOnly<current.ScheduledJob>, TypeOnly<old.ScheduledJob>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TenantKeyGenerator": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_TenantKeyGenerator = requireAssignableTo<TypeOnly<old.TenantKeyGenerator>, TypeOnly<current.TenantKeyGenerator>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_TenantKeyGenerator": {"backCompat": false}
 */
declare type current_as_old_for_Class_TenantKeyGenerator = requireAssignableTo<TypeOnly<current.TenantKeyGenerator>, TypeOnly<old.TenantKeyGenerator>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_WebSocketTracker": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_WebSocketTracker = requireAssignableTo<TypeOnly<old.WebSocketTracker>, TypeOnly<current.WebSocketTracker>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_WebSocketTracker": {"backCompat": false}
 */
declare type current_as_old_for_Class_WebSocketTracker = requireAssignableTo<TypeOnly<current.WebSocketTracker>, TypeOnly<old.WebSocketTracker>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_WinstonLumberjackEngine": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_WinstonLumberjackEngine = requireAssignableTo<TypeOnly<old.WinstonLumberjackEngine>, TypeOnly<current.WinstonLumberjackEngine>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_WinstonLumberjackEngine": {"backCompat": false}
 */
declare type current_as_old_for_Class_WinstonLumberjackEngine = requireAssignableTo<TypeOnly<current.WinstonLumberjackEngine>, TypeOnly<old.WinstonLumberjackEngine>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_AsyncLocalStorageContextProvider": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_AsyncLocalStorageContextProvider = requireAssignableTo<TypeOnly<typeof current.AsyncLocalStorageContextProvider>, TypeOnly<typeof old.AsyncLocalStorageContextProvider>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_AsyncLocalStorageTelemetryContext": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_AsyncLocalStorageTelemetryContext = requireAssignableTo<TypeOnly<typeof current.AsyncLocalStorageTelemetryContext>, TypeOnly<typeof old.AsyncLocalStorageTelemetryContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_AsyncLocalStorageTimeoutContext": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_AsyncLocalStorageTimeoutContext = requireAssignableTo<TypeOnly<typeof current.AsyncLocalStorageTimeoutContext>, TypeOnly<typeof old.AsyncLocalStorageTimeoutContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DummyRevokedTokenChecker": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DummyRevokedTokenChecker = requireAssignableTo<TypeOnly<typeof current.DummyRevokedTokenChecker>, TypeOnly<typeof old.DummyRevokedTokenChecker>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_DummyTokenRevocationManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_DummyTokenRevocationManager = requireAssignableTo<TypeOnly<typeof current.DummyTokenRevocationManager>, TypeOnly<typeof old.DummyTokenRevocationManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_FluidServiceError": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_FluidServiceError = requireAssignableTo<TypeOnly<typeof current.FluidServiceError>, TypeOnly<typeof old.FluidServiceError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_InMemoryApiCounters": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_InMemoryApiCounters = requireAssignableTo<TypeOnly<typeof current.InMemoryApiCounters>, TypeOnly<typeof old.InMemoryApiCounters>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_RedisClientConnectionManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_RedisClientConnectionManager = requireAssignableTo<TypeOnly<typeof current.RedisClientConnectionManager>, TypeOnly<typeof old.RedisClientConnectionManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ScheduledJob": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ScheduledJob = requireAssignableTo<TypeOnly<typeof current.ScheduledJob>, TypeOnly<typeof old.ScheduledJob>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_TenantKeyGenerator": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_TenantKeyGenerator = requireAssignableTo<TypeOnly<typeof current.TenantKeyGenerator>, TypeOnly<typeof old.TenantKeyGenerator>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_WebSocketTracker": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_WebSocketTracker = requireAssignableTo<TypeOnly<typeof current.WebSocketTracker>, TypeOnly<typeof old.WebSocketTracker>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_WinstonLumberjackEngine": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_WinstonLumberjackEngine = requireAssignableTo<TypeOnly<typeof current.WinstonLumberjackEngine>, TypeOnly<typeof old.WinstonLumberjackEngine>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_FluidServiceErrorCode": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_FluidServiceErrorCode = requireAssignableTo<TypeOnly<old.FluidServiceErrorCode>, TypeOnly<current.FluidServiceErrorCode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_FluidServiceErrorCode": {"backCompat": false}
 */
declare type current_as_old_for_Enum_FluidServiceErrorCode = requireAssignableTo<TypeOnly<current.FluidServiceErrorCode>, TypeOnly<old.FluidServiceErrorCode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_alternativeMorganLoggerMiddleware": {"backCompat": false}
 */
declare type current_as_old_for_Function_alternativeMorganLoggerMiddleware = requireAssignableTo<TypeOnly<typeof current.alternativeMorganLoggerMiddleware>, TypeOnly<typeof old.alternativeMorganLoggerMiddleware>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_configureGlobalTelemetryContext": {"backCompat": false}
 */
declare type current_as_old_for_Function_configureGlobalTelemetryContext = requireAssignableTo<TypeOnly<typeof current.configureGlobalTelemetryContext>, TypeOnly<typeof old.configureGlobalTelemetryContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_configureGlobalTimeoutContext": {"backCompat": false}
 */
declare type current_as_old_for_Function_configureGlobalTimeoutContext = requireAssignableTo<TypeOnly<typeof current.configureGlobalTimeoutContext>, TypeOnly<typeof old.configureGlobalTimeoutContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_configureLogging": {"backCompat": false}
 */
declare type current_as_old_for_Function_configureLogging = requireAssignableTo<TypeOnly<typeof current.configureLogging>, TypeOnly<typeof old.configureLogging>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_deleteSummarizedOps": {"backCompat": false}
 */
declare type current_as_old_for_Function_deleteSummarizedOps = requireAssignableTo<TypeOnly<typeof current.deleteSummarizedOps>, TypeOnly<typeof old.deleteSummarizedOps>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_executeApiWithMetric": {"backCompat": false}
 */
declare type current_as_old_for_Function_executeApiWithMetric = requireAssignableTo<TypeOnly<typeof current.executeApiWithMetric>, TypeOnly<typeof old.executeApiWithMetric>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_executeOnInterval": {"backCompat": false}
 */
declare type current_as_old_for_Function_executeOnInterval = requireAssignableTo<TypeOnly<typeof current.executeOnInterval>, TypeOnly<typeof old.executeOnInterval>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_generateToken": {"backCompat": false}
 */
declare type current_as_old_for_Function_generateToken = requireAssignableTo<TypeOnly<typeof current.generateToken>, TypeOnly<typeof old.generateToken>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_generateUser": {"backCompat": false}
 */
declare type current_as_old_for_Function_generateUser = requireAssignableTo<TypeOnly<typeof current.generateUser>, TypeOnly<typeof old.generateUser>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_getBooleanFromConfig": {"backCompat": false}
 */
declare type current_as_old_for_Function_getBooleanFromConfig = requireAssignableTo<TypeOnly<typeof current.getBooleanFromConfig>, TypeOnly<typeof old.getBooleanFromConfig>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_getCorrelationId": {"backCompat": false}
 */
declare type current_as_old_for_Function_getCorrelationId = requireAssignableTo<TypeOnly<typeof current.getCorrelationId>, TypeOnly<typeof old.getCorrelationId>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_getCorrelationIdWithHttpFallback": {"backCompat": false}
 */
declare type current_as_old_for_Function_getCorrelationIdWithHttpFallback = requireAssignableTo<TypeOnly<typeof current.getCorrelationIdWithHttpFallback>, TypeOnly<typeof old.getCorrelationIdWithHttpFallback>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_getCreationToken": {"backCompat": false}
 */
declare type current_as_old_for_Function_getCreationToken = requireAssignableTo<TypeOnly<typeof current.getCreationToken>, TypeOnly<typeof old.getCreationToken>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_getHostIp": {"backCompat": false}
 */
declare type current_as_old_for_Function_getHostIp = requireAssignableTo<TypeOnly<typeof current.getHostIp>, TypeOnly<typeof old.getHostIp>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_getNumberFromConfig": {"backCompat": false}
 */
declare type current_as_old_for_Function_getNumberFromConfig = requireAssignableTo<TypeOnly<typeof current.getNumberFromConfig>, TypeOnly<typeof old.getNumberFromConfig>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_getParam": {"backCompat": false}
 */
declare type current_as_old_for_Function_getParam = requireAssignableTo<TypeOnly<typeof current.getParam>, TypeOnly<typeof old.getParam>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_getRandomName": {"backCompat": false}
 */
declare type current_as_old_for_Function_getRandomName = requireAssignableTo<TypeOnly<typeof current.getRandomName>, TypeOnly<typeof old.getRandomName>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_getTelemetryContextPropertiesWithHttpInfo": {"backCompat": false}
 */
declare type current_as_old_for_Function_getTelemetryContextPropertiesWithHttpInfo = requireAssignableTo<TypeOnly<typeof current.getTelemetryContextPropertiesWithHttpInfo>, TypeOnly<typeof old.getTelemetryContextPropertiesWithHttpInfo>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_jsonMorganLoggerMiddleware": {"backCompat": false}
 */
declare type current_as_old_for_Function_jsonMorganLoggerMiddleware = requireAssignableTo<TypeOnly<typeof current.jsonMorganLoggerMiddleware>, TypeOnly<typeof old.jsonMorganLoggerMiddleware>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_normalizePort": {"backCompat": false}
 */
declare type current_as_old_for_Function_normalizePort = requireAssignableTo<TypeOnly<typeof current.normalizePort>, TypeOnly<typeof old.normalizePort>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_respondWithNetworkError": {"backCompat": false}
 */
declare type current_as_old_for_Function_respondWithNetworkError = requireAssignableTo<TypeOnly<typeof current.respondWithNetworkError>, TypeOnly<typeof old.respondWithNetworkError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_throttle": {"backCompat": false}
 */
declare type current_as_old_for_Function_throttle = requireAssignableTo<TypeOnly<typeof current.throttle>, TypeOnly<typeof old.throttle>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_validateTokenClaims": {"backCompat": false}
 */
declare type current_as_old_for_Function_validateTokenClaims = requireAssignableTo<TypeOnly<typeof current.validateTokenClaims>, TypeOnly<typeof old.validateTokenClaims>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_validateTokenScopeClaims": {"backCompat": false}
 */
declare type current_as_old_for_Function_validateTokenScopeClaims = requireAssignableTo<TypeOnly<typeof current.validateTokenScopeClaims>, TypeOnly<typeof old.validateTokenScopeClaims>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_verifyStorageToken": {"backCompat": false}
 */
declare type current_as_old_for_Function_verifyStorageToken = requireAssignableTo<TypeOnly<typeof current.verifyStorageToken>, TypeOnly<typeof old.verifyStorageToken>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_verifyToken": {"backCompat": false}
 */
declare type current_as_old_for_Function_verifyToken = requireAssignableTo<TypeOnly<typeof current.verifyToken>, TypeOnly<typeof old.verifyToken>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IApiCounters": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IApiCounters = requireAssignableTo<TypeOnly<old.IApiCounters>, TypeOnly<current.IApiCounters>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IApiCounters": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IApiCounters = requireAssignableTo<TypeOnly<current.IApiCounters>, TypeOnly<old.IApiCounters>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRedisClientConnectionManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRedisClientConnectionManager = requireAssignableTo<TypeOnly<old.IRedisClientConnectionManager>, TypeOnly<current.IRedisClientConnectionManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRedisClientConnectionManager": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRedisClientConnectionManager = requireAssignableTo<TypeOnly<current.IRedisClientConnectionManager>, TypeOnly<old.IRedisClientConnectionManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRedisParameters": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IRedisParameters = requireAssignableTo<TypeOnly<old.IRedisParameters>, TypeOnly<current.IRedisParameters>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IRedisParameters": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IRedisParameters = requireAssignableTo<TypeOnly<current.IRedisParameters>, TypeOnly<old.IRedisParameters>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISimpleThrottleConfig": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISimpleThrottleConfig = requireAssignableTo<TypeOnly<old.ISimpleThrottleConfig>, TypeOnly<current.ISimpleThrottleConfig>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISimpleThrottleConfig": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISimpleThrottleConfig = requireAssignableTo<TypeOnly<current.ISimpleThrottleConfig>, TypeOnly<old.ISimpleThrottleConfig>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITenantKeyGenerator": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITenantKeyGenerator = requireAssignableTo<TypeOnly<old.ITenantKeyGenerator>, TypeOnly<current.ITenantKeyGenerator>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITenantKeyGenerator": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITenantKeyGenerator = requireAssignableTo<TypeOnly<current.ITenantKeyGenerator>, TypeOnly<old.ITenantKeyGenerator>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IThrottleConfig": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IThrottleConfig = requireAssignableTo<TypeOnly<old.IThrottleConfig>, TypeOnly<current.IThrottleConfig>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IThrottleConfig": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IThrottleConfig = requireAssignableTo<TypeOnly<current.IThrottleConfig>, TypeOnly<old.IThrottleConfig>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IThrottleMiddlewareOptions": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IThrottleMiddlewareOptions = requireAssignableTo<TypeOnly<old.IThrottleMiddlewareOptions>, TypeOnly<current.IThrottleMiddlewareOptions>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IThrottleMiddlewareOptions": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IThrottleMiddlewareOptions = requireAssignableTo<TypeOnly<current.IThrottleMiddlewareOptions>, TypeOnly<old.IThrottleMiddlewareOptions>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWinstonConfig": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IWinstonConfig = requireAssignableTo<TypeOnly<old.IWinstonConfig>, TypeOnly<current.IWinstonConfig>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWinstonConfig": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IWinstonConfig = requireAssignableTo<TypeOnly<current.IWinstonConfig>, TypeOnly<old.IWinstonConfig>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_bindCorrelationId": {"backCompat": false}
 */
declare type current_as_old_for_Variable_bindCorrelationId = requireAssignableTo<TypeOnly<typeof current.bindCorrelationId>, TypeOnly<typeof old.bindCorrelationId>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_bindTelemetryContext": {"backCompat": false}
 */
declare type current_as_old_for_Variable_bindTelemetryContext = requireAssignableTo<TypeOnly<typeof current.bindTelemetryContext>, TypeOnly<typeof old.bindTelemetryContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_bindTimeoutContext": {"backCompat": false}
 */
declare type current_as_old_for_Variable_bindTimeoutContext = requireAssignableTo<TypeOnly<typeof current.bindTimeoutContext>, TypeOnly<typeof old.bindTimeoutContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_choose": {"backCompat": false}
 */
declare type current_as_old_for_Variable_choose = requireAssignableTo<TypeOnly<typeof current.choose>, TypeOnly<typeof old.choose>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_executeRedisMultiWithHmsetExpire": {"backCompat": false}
 */
declare type current_as_old_for_Variable_executeRedisMultiWithHmsetExpire = requireAssignableTo<TypeOnly<typeof current.executeRedisMultiWithHmsetExpire>, TypeOnly<typeof old.executeRedisMultiWithHmsetExpire>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_executeRedisMultiWithHmsetExpireAndLpush": {"backCompat": false}
 */
declare type current_as_old_for_Variable_executeRedisMultiWithHmsetExpireAndLpush = requireAssignableTo<TypeOnly<typeof current.executeRedisMultiWithHmsetExpireAndLpush>, TypeOnly<typeof old.executeRedisMultiWithHmsetExpireAndLpush>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_getRedisClusterRetryStrategy": {"backCompat": false}
 */
declare type current_as_old_for_Variable_getRedisClusterRetryStrategy = requireAssignableTo<TypeOnly<typeof current.getRedisClusterRetryStrategy>, TypeOnly<typeof old.getRedisClusterRetryStrategy>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_getThrottleConfig": {"backCompat": false}
 */
declare type current_as_old_for_Variable_getThrottleConfig = requireAssignableTo<TypeOnly<typeof current.getThrottleConfig>, TypeOnly<typeof old.getThrottleConfig>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_parseBoolean": {"backCompat": false}
 */
declare type current_as_old_for_Variable_parseBoolean = requireAssignableTo<TypeOnly<typeof current.parseBoolean>, TypeOnly<typeof old.parseBoolean>>
