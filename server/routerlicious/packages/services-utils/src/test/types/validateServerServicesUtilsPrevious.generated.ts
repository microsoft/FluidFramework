/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-test-generator in @fluidframework/build-tools.
 */
import * as old from "@fluidframework/server-services-utils-previous";
import * as current from "../../index";

type TypeOnly<T> = {
    [P in keyof T]: TypeOnly<T[P]>;
};

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DummyTokenRevocationManager": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_DummyTokenRevocationManager():
    TypeOnly<old.DummyTokenRevocationManager>;
declare function use_current_ClassDeclaration_DummyTokenRevocationManager(
    use: TypeOnly<current.DummyTokenRevocationManager>);
use_current_ClassDeclaration_DummyTokenRevocationManager(
    get_old_ClassDeclaration_DummyTokenRevocationManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_DummyTokenRevocationManager": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_DummyTokenRevocationManager():
    TypeOnly<current.DummyTokenRevocationManager>;
declare function use_old_ClassDeclaration_DummyTokenRevocationManager(
    use: TypeOnly<old.DummyTokenRevocationManager>);
use_old_ClassDeclaration_DummyTokenRevocationManager(
    // @ts-expect-error compatibility expected to be broken
    get_current_ClassDeclaration_DummyTokenRevocationManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_FluidServiceError": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_FluidServiceError():
    TypeOnly<old.FluidServiceError>;
declare function use_current_ClassDeclaration_FluidServiceError(
    use: TypeOnly<current.FluidServiceError>);
use_current_ClassDeclaration_FluidServiceError(
    get_old_ClassDeclaration_FluidServiceError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_FluidServiceError": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_FluidServiceError():
    TypeOnly<current.FluidServiceError>;
declare function use_old_ClassDeclaration_FluidServiceError(
    use: TypeOnly<old.FluidServiceError>);
use_old_ClassDeclaration_FluidServiceError(
    get_current_ClassDeclaration_FluidServiceError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_FluidServiceErrorCode": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_FluidServiceErrorCode():
    TypeOnly<old.FluidServiceErrorCode>;
declare function use_current_EnumDeclaration_FluidServiceErrorCode(
    use: TypeOnly<current.FluidServiceErrorCode>);
use_current_EnumDeclaration_FluidServiceErrorCode(
    get_old_EnumDeclaration_FluidServiceErrorCode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_FluidServiceErrorCode": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_FluidServiceErrorCode():
    TypeOnly<current.FluidServiceErrorCode>;
declare function use_old_EnumDeclaration_FluidServiceErrorCode(
    use: TypeOnly<old.FluidServiceErrorCode>);
use_old_EnumDeclaration_FluidServiceErrorCode(
    get_current_EnumDeclaration_FluidServiceErrorCode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRedisParameters": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IRedisParameters():
    TypeOnly<old.IRedisParameters>;
declare function use_current_InterfaceDeclaration_IRedisParameters(
    use: TypeOnly<current.IRedisParameters>);
use_current_InterfaceDeclaration_IRedisParameters(
    get_old_InterfaceDeclaration_IRedisParameters());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IRedisParameters": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IRedisParameters():
    TypeOnly<current.IRedisParameters>;
declare function use_old_InterfaceDeclaration_IRedisParameters(
    use: TypeOnly<old.IRedisParameters>);
use_old_InterfaceDeclaration_IRedisParameters(
    get_current_InterfaceDeclaration_IRedisParameters());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottleMiddlewareOptions": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IThrottleMiddlewareOptions():
    TypeOnly<old.IThrottleMiddlewareOptions>;
declare function use_current_InterfaceDeclaration_IThrottleMiddlewareOptions(
    use: TypeOnly<current.IThrottleMiddlewareOptions>);
use_current_InterfaceDeclaration_IThrottleMiddlewareOptions(
    get_old_InterfaceDeclaration_IThrottleMiddlewareOptions());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IThrottleMiddlewareOptions": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IThrottleMiddlewareOptions():
    TypeOnly<current.IThrottleMiddlewareOptions>;
declare function use_old_InterfaceDeclaration_IThrottleMiddlewareOptions(
    use: TypeOnly<old.IThrottleMiddlewareOptions>);
use_old_InterfaceDeclaration_IThrottleMiddlewareOptions(
    get_current_InterfaceDeclaration_IThrottleMiddlewareOptions());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWinstonConfig": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IWinstonConfig():
    TypeOnly<old.IWinstonConfig>;
declare function use_current_InterfaceDeclaration_IWinstonConfig(
    use: TypeOnly<current.IWinstonConfig>);
use_current_InterfaceDeclaration_IWinstonConfig(
    get_old_InterfaceDeclaration_IWinstonConfig());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWinstonConfig": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IWinstonConfig():
    TypeOnly<current.IWinstonConfig>;
declare function use_old_InterfaceDeclaration_IWinstonConfig(
    use: TypeOnly<old.IWinstonConfig>);
use_old_InterfaceDeclaration_IWinstonConfig(
    // @ts-expect-error compatibility expected to be broken
    get_current_InterfaceDeclaration_IWinstonConfig());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ScheduledJob": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_ScheduledJob():
    TypeOnly<old.ScheduledJob>;
declare function use_current_ClassDeclaration_ScheduledJob(
    use: TypeOnly<current.ScheduledJob>);
use_current_ClassDeclaration_ScheduledJob(
    get_old_ClassDeclaration_ScheduledJob());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_ScheduledJob": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_ScheduledJob():
    TypeOnly<current.ScheduledJob>;
declare function use_old_ClassDeclaration_ScheduledJob(
    use: TypeOnly<old.ScheduledJob>);
use_old_ClassDeclaration_ScheduledJob(
    get_current_ClassDeclaration_ScheduledJob());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_WebSocketTracker": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_WebSocketTracker():
    TypeOnly<old.WebSocketTracker>;
declare function use_current_ClassDeclaration_WebSocketTracker(
    use: TypeOnly<current.WebSocketTracker>);
use_current_ClassDeclaration_WebSocketTracker(
    get_old_ClassDeclaration_WebSocketTracker());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_WebSocketTracker": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_WebSocketTracker():
    TypeOnly<current.WebSocketTracker>;
declare function use_old_ClassDeclaration_WebSocketTracker(
    use: TypeOnly<old.WebSocketTracker>);
use_old_ClassDeclaration_WebSocketTracker(
    get_current_ClassDeclaration_WebSocketTracker());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_WinstonLumberjackEngine": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_WinstonLumberjackEngine():
    TypeOnly<old.WinstonLumberjackEngine>;
declare function use_current_ClassDeclaration_WinstonLumberjackEngine(
    use: TypeOnly<current.WinstonLumberjackEngine>);
use_current_ClassDeclaration_WinstonLumberjackEngine(
    get_old_ClassDeclaration_WinstonLumberjackEngine());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_WinstonLumberjackEngine": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_WinstonLumberjackEngine():
    TypeOnly<current.WinstonLumberjackEngine>;
declare function use_old_ClassDeclaration_WinstonLumberjackEngine(
    use: TypeOnly<old.WinstonLumberjackEngine>);
use_old_ClassDeclaration_WinstonLumberjackEngine(
    get_current_ClassDeclaration_WinstonLumberjackEngine());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_alternativeMorganLoggerMiddleware": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_alternativeMorganLoggerMiddleware():
    TypeOnly<typeof old.alternativeMorganLoggerMiddleware>;
declare function use_current_FunctionDeclaration_alternativeMorganLoggerMiddleware(
    use: TypeOnly<typeof current.alternativeMorganLoggerMiddleware>);
use_current_FunctionDeclaration_alternativeMorganLoggerMiddleware(
    get_old_FunctionDeclaration_alternativeMorganLoggerMiddleware());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_alternativeMorganLoggerMiddleware": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_alternativeMorganLoggerMiddleware():
    TypeOnly<typeof current.alternativeMorganLoggerMiddleware>;
declare function use_old_FunctionDeclaration_alternativeMorganLoggerMiddleware(
    use: TypeOnly<typeof old.alternativeMorganLoggerMiddleware>);
use_old_FunctionDeclaration_alternativeMorganLoggerMiddleware(
    get_current_FunctionDeclaration_alternativeMorganLoggerMiddleware());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_bindCorrelationId": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_bindCorrelationId():
    TypeOnly<typeof old.bindCorrelationId>;
declare function use_current_VariableDeclaration_bindCorrelationId(
    use: TypeOnly<typeof current.bindCorrelationId>);
use_current_VariableDeclaration_bindCorrelationId(
    get_old_VariableDeclaration_bindCorrelationId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_bindCorrelationId": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_bindCorrelationId():
    TypeOnly<typeof current.bindCorrelationId>;
declare function use_old_VariableDeclaration_bindCorrelationId(
    use: TypeOnly<typeof old.bindCorrelationId>);
use_old_VariableDeclaration_bindCorrelationId(
    get_current_VariableDeclaration_bindCorrelationId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_choose": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_choose():
    TypeOnly<typeof old.choose>;
declare function use_current_VariableDeclaration_choose(
    use: TypeOnly<typeof current.choose>);
use_current_VariableDeclaration_choose(
    get_old_VariableDeclaration_choose());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_choose": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_choose():
    TypeOnly<typeof current.choose>;
declare function use_old_VariableDeclaration_choose(
    use: TypeOnly<typeof old.choose>);
use_old_VariableDeclaration_choose(
    get_current_VariableDeclaration_choose());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_configureLogging": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_configureLogging():
    TypeOnly<typeof old.configureLogging>;
declare function use_current_FunctionDeclaration_configureLogging(
    use: TypeOnly<typeof current.configureLogging>);
use_current_FunctionDeclaration_configureLogging(
    get_old_FunctionDeclaration_configureLogging());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_configureLogging": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_configureLogging():
    TypeOnly<typeof current.configureLogging>;
declare function use_old_FunctionDeclaration_configureLogging(
    use: TypeOnly<typeof old.configureLogging>);
use_old_FunctionDeclaration_configureLogging(
    get_current_FunctionDeclaration_configureLogging());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_deleteSummarizedOps": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_deleteSummarizedOps():
    TypeOnly<typeof old.deleteSummarizedOps>;
declare function use_current_FunctionDeclaration_deleteSummarizedOps(
    use: TypeOnly<typeof current.deleteSummarizedOps>);
use_current_FunctionDeclaration_deleteSummarizedOps(
    get_old_FunctionDeclaration_deleteSummarizedOps());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_deleteSummarizedOps": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_deleteSummarizedOps():
    TypeOnly<typeof current.deleteSummarizedOps>;
declare function use_old_FunctionDeclaration_deleteSummarizedOps(
    use: TypeOnly<typeof old.deleteSummarizedOps>);
use_old_FunctionDeclaration_deleteSummarizedOps(
    get_current_FunctionDeclaration_deleteSummarizedOps());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_executeApiWithMetric": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_executeApiWithMetric():
    TypeOnly<typeof old.executeApiWithMetric>;
declare function use_current_FunctionDeclaration_executeApiWithMetric(
    use: TypeOnly<typeof current.executeApiWithMetric>);
use_current_FunctionDeclaration_executeApiWithMetric(
    get_old_FunctionDeclaration_executeApiWithMetric());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_executeApiWithMetric": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_executeApiWithMetric():
    TypeOnly<typeof current.executeApiWithMetric>;
declare function use_old_FunctionDeclaration_executeApiWithMetric(
    use: TypeOnly<typeof old.executeApiWithMetric>);
use_old_FunctionDeclaration_executeApiWithMetric(
    get_current_FunctionDeclaration_executeApiWithMetric());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_executeOnInterval": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_executeOnInterval():
    TypeOnly<typeof old.executeOnInterval>;
declare function use_current_FunctionDeclaration_executeOnInterval(
    use: TypeOnly<typeof current.executeOnInterval>);
use_current_FunctionDeclaration_executeOnInterval(
    get_old_FunctionDeclaration_executeOnInterval());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_executeOnInterval": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_executeOnInterval():
    TypeOnly<typeof current.executeOnInterval>;
declare function use_old_FunctionDeclaration_executeOnInterval(
    use: TypeOnly<typeof old.executeOnInterval>);
use_old_FunctionDeclaration_executeOnInterval(
    get_current_FunctionDeclaration_executeOnInterval());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_executeRedisMultiWithHmsetExpire": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_executeRedisMultiWithHmsetExpire():
    TypeOnly<typeof old.executeRedisMultiWithHmsetExpire>;
declare function use_current_VariableDeclaration_executeRedisMultiWithHmsetExpire(
    use: TypeOnly<typeof current.executeRedisMultiWithHmsetExpire>);
use_current_VariableDeclaration_executeRedisMultiWithHmsetExpire(
    get_old_VariableDeclaration_executeRedisMultiWithHmsetExpire());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_executeRedisMultiWithHmsetExpire": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_executeRedisMultiWithHmsetExpire():
    TypeOnly<typeof current.executeRedisMultiWithHmsetExpire>;
declare function use_old_VariableDeclaration_executeRedisMultiWithHmsetExpire(
    use: TypeOnly<typeof old.executeRedisMultiWithHmsetExpire>);
use_old_VariableDeclaration_executeRedisMultiWithHmsetExpire(
    get_current_VariableDeclaration_executeRedisMultiWithHmsetExpire());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_executeRedisMultiWithHmsetExpireAndLpush": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_executeRedisMultiWithHmsetExpireAndLpush():
    TypeOnly<typeof old.executeRedisMultiWithHmsetExpireAndLpush>;
declare function use_current_VariableDeclaration_executeRedisMultiWithHmsetExpireAndLpush(
    use: TypeOnly<typeof current.executeRedisMultiWithHmsetExpireAndLpush>);
use_current_VariableDeclaration_executeRedisMultiWithHmsetExpireAndLpush(
    get_old_VariableDeclaration_executeRedisMultiWithHmsetExpireAndLpush());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_executeRedisMultiWithHmsetExpireAndLpush": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_executeRedisMultiWithHmsetExpireAndLpush():
    TypeOnly<typeof current.executeRedisMultiWithHmsetExpireAndLpush>;
declare function use_old_VariableDeclaration_executeRedisMultiWithHmsetExpireAndLpush(
    use: TypeOnly<typeof old.executeRedisMultiWithHmsetExpireAndLpush>);
use_old_VariableDeclaration_executeRedisMultiWithHmsetExpireAndLpush(
    get_current_VariableDeclaration_executeRedisMultiWithHmsetExpireAndLpush());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateToken": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_generateToken():
    TypeOnly<typeof old.generateToken>;
declare function use_current_FunctionDeclaration_generateToken(
    use: TypeOnly<typeof current.generateToken>);
use_current_FunctionDeclaration_generateToken(
    get_old_FunctionDeclaration_generateToken());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateToken": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_generateToken():
    TypeOnly<typeof current.generateToken>;
declare function use_old_FunctionDeclaration_generateToken(
    use: TypeOnly<typeof old.generateToken>);
use_old_FunctionDeclaration_generateToken(
    get_current_FunctionDeclaration_generateToken());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateUser": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_generateUser():
    TypeOnly<typeof old.generateUser>;
declare function use_current_FunctionDeclaration_generateUser(
    use: TypeOnly<typeof current.generateUser>);
use_current_FunctionDeclaration_generateUser(
    get_old_FunctionDeclaration_generateUser());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateUser": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_generateUser():
    TypeOnly<typeof current.generateUser>;
declare function use_old_FunctionDeclaration_generateUser(
    use: TypeOnly<typeof old.generateUser>);
use_old_FunctionDeclaration_generateUser(
    get_current_FunctionDeclaration_generateUser());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getCorrelationId": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getCorrelationId():
    TypeOnly<typeof old.getCorrelationId>;
declare function use_current_FunctionDeclaration_getCorrelationId(
    use: TypeOnly<typeof current.getCorrelationId>);
use_current_FunctionDeclaration_getCorrelationId(
    get_old_FunctionDeclaration_getCorrelationId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getCorrelationId": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getCorrelationId():
    TypeOnly<typeof current.getCorrelationId>;
declare function use_old_FunctionDeclaration_getCorrelationId(
    use: TypeOnly<typeof old.getCorrelationId>);
use_old_FunctionDeclaration_getCorrelationId(
    get_current_FunctionDeclaration_getCorrelationId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getCorrelationIdWithHttpFallback": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getCorrelationIdWithHttpFallback():
    TypeOnly<typeof old.getCorrelationIdWithHttpFallback>;
declare function use_current_FunctionDeclaration_getCorrelationIdWithHttpFallback(
    use: TypeOnly<typeof current.getCorrelationIdWithHttpFallback>);
use_current_FunctionDeclaration_getCorrelationIdWithHttpFallback(
    get_old_FunctionDeclaration_getCorrelationIdWithHttpFallback());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getCorrelationIdWithHttpFallback": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getCorrelationIdWithHttpFallback():
    TypeOnly<typeof current.getCorrelationIdWithHttpFallback>;
declare function use_old_FunctionDeclaration_getCorrelationIdWithHttpFallback(
    use: TypeOnly<typeof old.getCorrelationIdWithHttpFallback>);
use_old_FunctionDeclaration_getCorrelationIdWithHttpFallback(
    get_current_FunctionDeclaration_getCorrelationIdWithHttpFallback());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getCreationToken": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getCreationToken():
    TypeOnly<typeof old.getCreationToken>;
declare function use_current_FunctionDeclaration_getCreationToken(
    use: TypeOnly<typeof current.getCreationToken>);
use_current_FunctionDeclaration_getCreationToken(
    get_old_FunctionDeclaration_getCreationToken());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getCreationToken": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getCreationToken():
    TypeOnly<typeof current.getCreationToken>;
declare function use_old_FunctionDeclaration_getCreationToken(
    use: TypeOnly<typeof old.getCreationToken>);
use_old_FunctionDeclaration_getCreationToken(
    get_current_FunctionDeclaration_getCreationToken());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getHostIp": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getHostIp():
    TypeOnly<typeof old.getHostIp>;
declare function use_current_FunctionDeclaration_getHostIp(
    use: TypeOnly<typeof current.getHostIp>);
use_current_FunctionDeclaration_getHostIp(
    get_old_FunctionDeclaration_getHostIp());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getHostIp": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getHostIp():
    TypeOnly<typeof current.getHostIp>;
declare function use_old_FunctionDeclaration_getHostIp(
    use: TypeOnly<typeof old.getHostIp>);
use_old_FunctionDeclaration_getHostIp(
    get_current_FunctionDeclaration_getHostIp());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getParam": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getParam():
    TypeOnly<typeof old.getParam>;
declare function use_current_FunctionDeclaration_getParam(
    use: TypeOnly<typeof current.getParam>);
use_current_FunctionDeclaration_getParam(
    get_old_FunctionDeclaration_getParam());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getParam": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getParam():
    TypeOnly<typeof current.getParam>;
declare function use_old_FunctionDeclaration_getParam(
    use: TypeOnly<typeof old.getParam>);
use_old_FunctionDeclaration_getParam(
    get_current_FunctionDeclaration_getParam());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getRandomName": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getRandomName():
    TypeOnly<typeof old.getRandomName>;
declare function use_current_FunctionDeclaration_getRandomName(
    use: TypeOnly<typeof current.getRandomName>);
use_current_FunctionDeclaration_getRandomName(
    get_old_FunctionDeclaration_getRandomName());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getRandomName": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getRandomName():
    TypeOnly<typeof current.getRandomName>;
declare function use_old_FunctionDeclaration_getRandomName(
    use: TypeOnly<typeof old.getRandomName>);
use_old_FunctionDeclaration_getRandomName(
    get_current_FunctionDeclaration_getRandomName());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_jsonMorganLoggerMiddleware": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_jsonMorganLoggerMiddleware():
    TypeOnly<typeof old.jsonMorganLoggerMiddleware>;
declare function use_current_FunctionDeclaration_jsonMorganLoggerMiddleware(
    use: TypeOnly<typeof current.jsonMorganLoggerMiddleware>);
use_current_FunctionDeclaration_jsonMorganLoggerMiddleware(
    get_old_FunctionDeclaration_jsonMorganLoggerMiddleware());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_jsonMorganLoggerMiddleware": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_jsonMorganLoggerMiddleware():
    TypeOnly<typeof current.jsonMorganLoggerMiddleware>;
declare function use_old_FunctionDeclaration_jsonMorganLoggerMiddleware(
    use: TypeOnly<typeof old.jsonMorganLoggerMiddleware>);
use_old_FunctionDeclaration_jsonMorganLoggerMiddleware(
    get_current_FunctionDeclaration_jsonMorganLoggerMiddleware());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_normalizePort": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_normalizePort():
    TypeOnly<typeof old.normalizePort>;
declare function use_current_FunctionDeclaration_normalizePort(
    use: TypeOnly<typeof current.normalizePort>);
use_current_FunctionDeclaration_normalizePort(
    get_old_FunctionDeclaration_normalizePort());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_normalizePort": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_normalizePort():
    TypeOnly<typeof current.normalizePort>;
declare function use_old_FunctionDeclaration_normalizePort(
    use: TypeOnly<typeof old.normalizePort>);
use_old_FunctionDeclaration_normalizePort(
    get_current_FunctionDeclaration_normalizePort());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_parseBoolean": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_parseBoolean():
    TypeOnly<typeof old.parseBoolean>;
declare function use_current_VariableDeclaration_parseBoolean(
    use: TypeOnly<typeof current.parseBoolean>);
use_current_VariableDeclaration_parseBoolean(
    get_old_VariableDeclaration_parseBoolean());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_parseBoolean": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_parseBoolean():
    TypeOnly<typeof current.parseBoolean>;
declare function use_old_VariableDeclaration_parseBoolean(
    use: TypeOnly<typeof old.parseBoolean>);
use_old_VariableDeclaration_parseBoolean(
    get_current_VariableDeclaration_parseBoolean());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_respondWithNetworkError": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_respondWithNetworkError():
    TypeOnly<typeof old.respondWithNetworkError>;
declare function use_current_FunctionDeclaration_respondWithNetworkError(
    use: TypeOnly<typeof current.respondWithNetworkError>);
use_current_FunctionDeclaration_respondWithNetworkError(
    get_old_FunctionDeclaration_respondWithNetworkError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_respondWithNetworkError": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_respondWithNetworkError():
    TypeOnly<typeof current.respondWithNetworkError>;
declare function use_old_FunctionDeclaration_respondWithNetworkError(
    use: TypeOnly<typeof old.respondWithNetworkError>);
use_old_FunctionDeclaration_respondWithNetworkError(
    get_current_FunctionDeclaration_respondWithNetworkError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_throttle": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_throttle():
    TypeOnly<typeof old.throttle>;
declare function use_current_FunctionDeclaration_throttle(
    use: TypeOnly<typeof current.throttle>);
use_current_FunctionDeclaration_throttle(
    get_old_FunctionDeclaration_throttle());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_throttle": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_throttle():
    TypeOnly<typeof current.throttle>;
declare function use_old_FunctionDeclaration_throttle(
    use: TypeOnly<typeof old.throttle>);
use_old_FunctionDeclaration_throttle(
    get_current_FunctionDeclaration_throttle());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_validateTokenClaims": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_validateTokenClaims():
    TypeOnly<typeof old.validateTokenClaims>;
declare function use_current_FunctionDeclaration_validateTokenClaims(
    use: TypeOnly<typeof current.validateTokenClaims>);
use_current_FunctionDeclaration_validateTokenClaims(
    get_old_FunctionDeclaration_validateTokenClaims());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_validateTokenClaims": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_validateTokenClaims():
    TypeOnly<typeof current.validateTokenClaims>;
declare function use_old_FunctionDeclaration_validateTokenClaims(
    use: TypeOnly<typeof old.validateTokenClaims>);
use_old_FunctionDeclaration_validateTokenClaims(
    get_current_FunctionDeclaration_validateTokenClaims());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedFunctionDeclaration_validateTokenRevocationClaims": {"forwardCompat": false}
*/

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "RemovedFunctionDeclaration_validateTokenRevocationClaims": {"backCompat": false}
*/

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_verifyStorageToken": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_verifyStorageToken():
    TypeOnly<typeof old.verifyStorageToken>;
declare function use_current_FunctionDeclaration_verifyStorageToken(
    use: TypeOnly<typeof current.verifyStorageToken>);
use_current_FunctionDeclaration_verifyStorageToken(
    get_old_FunctionDeclaration_verifyStorageToken());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_verifyStorageToken": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_verifyStorageToken():
    TypeOnly<typeof current.verifyStorageToken>;
declare function use_old_FunctionDeclaration_verifyStorageToken(
    use: TypeOnly<typeof old.verifyStorageToken>);
use_old_FunctionDeclaration_verifyStorageToken(
    get_current_FunctionDeclaration_verifyStorageToken());
