/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/server-memory-orderer-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LocalContext": {"forwardCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type old_as_current_for_Class_LocalContext = requireAssignableTo<TypeOnly<old.LocalContext>, TypeOnly<current.LocalContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LocalContext": {"backCompat": false}
 */
declare type current_as_old_for_Class_LocalContext = requireAssignableTo<TypeOnly<current.LocalContext>, TypeOnly<old.LocalContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LocalKafka": {"forwardCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type old_as_current_for_Class_LocalKafka = requireAssignableTo<TypeOnly<old.LocalKafka>, TypeOnly<current.LocalKafka>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LocalKafka": {"backCompat": false}
 */
declare type current_as_old_for_Class_LocalKafka = requireAssignableTo<TypeOnly<current.LocalKafka>, TypeOnly<old.LocalKafka>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LocalLambdaController": {"forwardCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type old_as_current_for_Class_LocalLambdaController = requireAssignableTo<TypeOnly<old.LocalLambdaController>, TypeOnly<current.LocalLambdaController>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LocalLambdaController": {"backCompat": false}
 */
declare type current_as_old_for_Class_LocalLambdaController = requireAssignableTo<TypeOnly<current.LocalLambdaController>, TypeOnly<old.LocalLambdaController>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LocalNodeFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_LocalNodeFactory = requireAssignableTo<TypeOnly<old.LocalNodeFactory>, TypeOnly<current.LocalNodeFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LocalNodeFactory": {"backCompat": false}
 */
declare type current_as_old_for_Class_LocalNodeFactory = requireAssignableTo<TypeOnly<current.LocalNodeFactory>, TypeOnly<old.LocalNodeFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LocalOrderer": {"forwardCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type old_as_current_for_Class_LocalOrderer = requireAssignableTo<TypeOnly<old.LocalOrderer>, TypeOnly<current.LocalOrderer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LocalOrderer": {"backCompat": false}
 */
declare type current_as_old_for_Class_LocalOrderer = requireAssignableTo<TypeOnly<current.LocalOrderer>, TypeOnly<old.LocalOrderer>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LocalOrderManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_LocalOrderManager = requireAssignableTo<TypeOnly<old.LocalOrderManager>, TypeOnly<current.LocalOrderManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_LocalOrderManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_LocalOrderManager = requireAssignableTo<TypeOnly<current.LocalOrderManager>, TypeOnly<old.LocalOrderManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_NodeManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_NodeManager = requireAssignableTo<TypeOnly<old.NodeManager>, TypeOnly<current.NodeManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_NodeManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_NodeManager = requireAssignableTo<TypeOnly<current.NodeManager>, TypeOnly<old.NodeManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_PubSub": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_PubSub = requireAssignableTo<TypeOnly<old.PubSub>, TypeOnly<current.PubSub>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_PubSub": {"backCompat": false}
 */
declare type current_as_old_for_Class_PubSub = requireAssignableTo<TypeOnly<current.PubSub>, TypeOnly<old.PubSub>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ReservationManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_ReservationManager = requireAssignableTo<TypeOnly<old.ReservationManager>, TypeOnly<current.ReservationManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_ReservationManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_ReservationManager = requireAssignableTo<TypeOnly<current.ReservationManager>, TypeOnly<old.ReservationManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_WebSocketSubscriber": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_WebSocketSubscriber = requireAssignableTo<TypeOnly<old.WebSocketSubscriber>, TypeOnly<current.WebSocketSubscriber>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_WebSocketSubscriber": {"backCompat": false}
 */
declare type current_as_old_for_Class_WebSocketSubscriber = requireAssignableTo<TypeOnly<current.WebSocketSubscriber>, TypeOnly<old.WebSocketSubscriber>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_LocalContext": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_LocalContext = requireAssignableTo<TypeOnly<typeof current.LocalContext>, TypeOnly<typeof old.LocalContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_LocalKafka": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_LocalKafka = requireAssignableTo<TypeOnly<typeof current.LocalKafka>, TypeOnly<typeof old.LocalKafka>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_LocalLambdaController": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_LocalLambdaController = requireAssignableTo<TypeOnly<typeof current.LocalLambdaController>, TypeOnly<typeof old.LocalLambdaController>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_LocalNodeFactory": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_LocalNodeFactory = requireAssignableTo<TypeOnly<typeof current.LocalNodeFactory>, TypeOnly<typeof old.LocalNodeFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_LocalOrderer": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_LocalOrderer = requireAssignableTo<TypeOnly<typeof current.LocalOrderer>, TypeOnly<typeof old.LocalOrderer>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_LocalOrderManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_LocalOrderManager = requireAssignableTo<TypeOnly<typeof current.LocalOrderManager>, TypeOnly<typeof old.LocalOrderManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_NodeManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_NodeManager = requireAssignableTo<TypeOnly<typeof current.NodeManager>, TypeOnly<typeof old.NodeManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_PubSub": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_PubSub = requireAssignableTo<TypeOnly<typeof current.PubSub>, TypeOnly<typeof old.PubSub>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_ReservationManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_ReservationManager = requireAssignableTo<TypeOnly<typeof current.ReservationManager>, TypeOnly<typeof old.ReservationManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_WebSocketSubscriber": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_WebSocketSubscriber = requireAssignableTo<TypeOnly<typeof current.WebSocketSubscriber>, TypeOnly<typeof old.WebSocketSubscriber>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConcreteNode": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IConcreteNode = requireAssignableTo<TypeOnly<old.IConcreteNode>, TypeOnly<current.IConcreteNode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConcreteNode": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IConcreteNode = requireAssignableTo<TypeOnly<current.IConcreteNode>, TypeOnly<old.IConcreteNode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConcreteNodeFactory": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IConcreteNodeFactory = requireAssignableTo<TypeOnly<old.IConcreteNodeFactory>, TypeOnly<current.IConcreteNodeFactory>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConcreteNodeFactory": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IConcreteNodeFactory = requireAssignableTo<TypeOnly<current.IConcreteNodeFactory>, TypeOnly<old.IConcreteNodeFactory>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConnectedMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IConnectedMessage = requireAssignableTo<TypeOnly<old.IConnectedMessage>, TypeOnly<current.IConnectedMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConnectedMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IConnectedMessage = requireAssignableTo<TypeOnly<current.IConnectedMessage>, TypeOnly<old.IConnectedMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConnectMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IConnectMessage = requireAssignableTo<TypeOnly<old.IConnectMessage>, TypeOnly<current.IConnectMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IConnectMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IConnectMessage = requireAssignableTo<TypeOnly<current.IConnectMessage>, TypeOnly<old.IConnectMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IKafkaSubscriber": {"forwardCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type old_as_current_for_Interface_IKafkaSubscriber = requireAssignableTo<TypeOnly<old.IKafkaSubscriber>, TypeOnly<current.IKafkaSubscriber>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IKafkaSubscriber": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IKafkaSubscriber = requireAssignableTo<TypeOnly<current.IKafkaSubscriber>, TypeOnly<old.IKafkaSubscriber>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILocalOrdererSetup": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ILocalOrdererSetup = requireAssignableTo<TypeOnly<old.ILocalOrdererSetup>, TypeOnly<current.ILocalOrdererSetup>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ILocalOrdererSetup": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ILocalOrdererSetup = requireAssignableTo<TypeOnly<current.ILocalOrdererSetup>, TypeOnly<old.ILocalOrdererSetup>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INodeMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_INodeMessage = requireAssignableTo<TypeOnly<old.INodeMessage>, TypeOnly<current.INodeMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INodeMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_INodeMessage = requireAssignableTo<TypeOnly<current.INodeMessage>, TypeOnly<old.INodeMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IOpMessage": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IOpMessage = requireAssignableTo<TypeOnly<old.IOpMessage>, TypeOnly<current.IOpMessage>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IOpMessage": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IOpMessage = requireAssignableTo<TypeOnly<current.IOpMessage>, TypeOnly<old.IOpMessage>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPubSub": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IPubSub = requireAssignableTo<TypeOnly<old.IPubSub>, TypeOnly<current.IPubSub>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPubSub": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IPubSub = requireAssignableTo<TypeOnly<current.IPubSub>, TypeOnly<old.IPubSub>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IReservation": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IReservation = requireAssignableTo<TypeOnly<old.IReservation>, TypeOnly<current.IReservation>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IReservation": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IReservation = requireAssignableTo<TypeOnly<current.IReservation>, TypeOnly<old.IReservation>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IReservationManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IReservationManager = requireAssignableTo<TypeOnly<old.IReservationManager>, TypeOnly<current.IReservationManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IReservationManager": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IReservationManager = requireAssignableTo<TypeOnly<current.IReservationManager>, TypeOnly<old.IReservationManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISubscriber": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISubscriber = requireAssignableTo<TypeOnly<old.ISubscriber>, TypeOnly<current.ISubscriber>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISubscriber": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISubscriber = requireAssignableTo<TypeOnly<current.ISubscriber>, TypeOnly<old.ISubscriber>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LocalLambdaControllerState": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_LocalLambdaControllerState = requireAssignableTo<TypeOnly<old.LocalLambdaControllerState>, TypeOnly<current.LocalLambdaControllerState>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_LocalLambdaControllerState": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_LocalLambdaControllerState = requireAssignableTo<TypeOnly<current.LocalLambdaControllerState>, TypeOnly<old.LocalLambdaControllerState>>
