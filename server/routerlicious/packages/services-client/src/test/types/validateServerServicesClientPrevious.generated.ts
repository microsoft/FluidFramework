/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by flub generate:typetests in @fluid-tools/build-cli.
 */

import type { TypeOnly, MinimalType, FullType, requireAssignableTo } from "@fluidframework/build-tools";
import type * as old from "@fluidframework/server-services-client-previous";

import type * as current from "../../index.js";

declare type MakeUnusedImportErrorsGoAway<T> = TypeOnly<T> | MinimalType<T> | FullType<T> | typeof old | typeof current | requireAssignableTo<true, true>;

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_BasicRestWrapper": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_BasicRestWrapper = requireAssignableTo<TypeOnly<old.BasicRestWrapper>, TypeOnly<current.BasicRestWrapper>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_BasicRestWrapper": {"backCompat": false}
 */
declare type current_as_old_for_Class_BasicRestWrapper = requireAssignableTo<TypeOnly<current.BasicRestWrapper>, TypeOnly<old.BasicRestWrapper>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_GitManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_GitManager = requireAssignableTo<TypeOnly<old.GitManager>, TypeOnly<current.GitManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_GitManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_GitManager = requireAssignableTo<TypeOnly<current.GitManager>, TypeOnly<old.GitManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Heap": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_Heap = requireAssignableTo<TypeOnly<old.Heap<never>>, TypeOnly<current.Heap<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Heap": {"backCompat": false}
 */
declare type current_as_old_for_Class_Heap = requireAssignableTo<TypeOnly<current.Heap<never>>, TypeOnly<old.Heap<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Historian": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_Historian = requireAssignableTo<TypeOnly<old.Historian>, TypeOnly<current.Historian>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_Historian": {"backCompat": false}
 */
declare type current_as_old_for_Class_Historian = requireAssignableTo<TypeOnly<current.Historian>, TypeOnly<old.Historian>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_NetworkError": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_NetworkError = requireAssignableTo<TypeOnly<old.NetworkError>, TypeOnly<current.NetworkError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_NetworkError": {"backCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type current_as_old_for_Class_NetworkError = requireAssignableTo<TypeOnly<current.NetworkError>, TypeOnly<old.NetworkError>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RestLessClient": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_RestLessClient = requireAssignableTo<TypeOnly<old.RestLessClient>, TypeOnly<current.RestLessClient>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RestLessClient": {"backCompat": false}
 */
declare type current_as_old_for_Class_RestLessClient = requireAssignableTo<TypeOnly<current.RestLessClient>, TypeOnly<old.RestLessClient>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RestWrapper": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_RestWrapper = requireAssignableTo<TypeOnly<old.RestWrapper>, TypeOnly<current.RestWrapper>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_RestWrapper": {"backCompat": false}
 */
declare type current_as_old_for_Class_RestWrapper = requireAssignableTo<TypeOnly<current.RestWrapper>, TypeOnly<old.RestWrapper>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SummaryTreeUploadManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_SummaryTreeUploadManager = requireAssignableTo<TypeOnly<old.SummaryTreeUploadManager>, TypeOnly<current.SummaryTreeUploadManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_SummaryTreeUploadManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_SummaryTreeUploadManager = requireAssignableTo<TypeOnly<current.SummaryTreeUploadManager>, TypeOnly<old.SummaryTreeUploadManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_WholeSummaryUploadManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Class_WholeSummaryUploadManager = requireAssignableTo<TypeOnly<old.WholeSummaryUploadManager>, TypeOnly<current.WholeSummaryUploadManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Class_WholeSummaryUploadManager": {"backCompat": false}
 */
declare type current_as_old_for_Class_WholeSummaryUploadManager = requireAssignableTo<TypeOnly<current.WholeSummaryUploadManager>, TypeOnly<old.WholeSummaryUploadManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_BasicRestWrapper": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_BasicRestWrapper = requireAssignableTo<TypeOnly<typeof current.BasicRestWrapper>, TypeOnly<typeof old.BasicRestWrapper>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_GitManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_GitManager = requireAssignableTo<TypeOnly<typeof current.GitManager>, TypeOnly<typeof old.GitManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_Heap": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_Heap = requireAssignableTo<TypeOnly<typeof current.Heap>, TypeOnly<typeof old.Heap>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_Historian": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_Historian = requireAssignableTo<TypeOnly<typeof current.Historian>, TypeOnly<typeof old.Historian>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_NetworkError": {"backCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type current_as_old_for_ClassStatics_NetworkError = requireAssignableTo<TypeOnly<typeof current.NetworkError>, TypeOnly<typeof old.NetworkError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_RestLessClient": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_RestLessClient = requireAssignableTo<TypeOnly<typeof current.RestLessClient>, TypeOnly<typeof old.RestLessClient>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_RestWrapper": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_RestWrapper = requireAssignableTo<TypeOnly<typeof current.RestWrapper>, TypeOnly<typeof old.RestWrapper>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_SummaryTreeUploadManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_SummaryTreeUploadManager = requireAssignableTo<TypeOnly<typeof current.SummaryTreeUploadManager>, TypeOnly<typeof old.SummaryTreeUploadManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "ClassStatics_WholeSummaryUploadManager": {"backCompat": false}
 */
declare type current_as_old_for_ClassStatics_WholeSummaryUploadManager = requireAssignableTo<TypeOnly<typeof current.WholeSummaryUploadManager>, TypeOnly<typeof old.WholeSummaryUploadManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_InternalErrorCode": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_InternalErrorCode = requireAssignableTo<TypeOnly<old.InternalErrorCode>, TypeOnly<current.InternalErrorCode>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_InternalErrorCode": {"backCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type current_as_old_for_Enum_InternalErrorCode = requireAssignableTo<TypeOnly<current.InternalErrorCode>, TypeOnly<old.InternalErrorCode>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_RestLessFieldNames": {"forwardCompat": false}
 */
declare type old_as_current_for_Enum_RestLessFieldNames = requireAssignableTo<TypeOnly<old.RestLessFieldNames>, TypeOnly<current.RestLessFieldNames>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Enum_RestLessFieldNames": {"backCompat": false}
 */
declare type current_as_old_for_Enum_RestLessFieldNames = requireAssignableTo<TypeOnly<current.RestLessFieldNames>, TypeOnly<old.RestLessFieldNames>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_convertFirstSummaryWholeSummaryTreeToSummaryTree": {"backCompat": false}
 */
declare type current_as_old_for_Function_convertFirstSummaryWholeSummaryTreeToSummaryTree = requireAssignableTo<TypeOnly<typeof current.convertFirstSummaryWholeSummaryTreeToSummaryTree>, TypeOnly<typeof old.convertFirstSummaryWholeSummaryTreeToSummaryTree>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_convertSortedNumberArrayToRanges": {"backCompat": false}
 */
declare type current_as_old_for_Function_convertSortedNumberArrayToRanges = requireAssignableTo<TypeOnly<typeof current.convertSortedNumberArrayToRanges>, TypeOnly<typeof old.convertSortedNumberArrayToRanges>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_convertSummaryTreeToWholeSummaryTree": {"backCompat": false}
 */
declare type current_as_old_for_Function_convertSummaryTreeToWholeSummaryTree = requireAssignableTo<TypeOnly<typeof current.convertSummaryTreeToWholeSummaryTree>, TypeOnly<typeof old.convertSummaryTreeToWholeSummaryTree>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_convertWholeFlatSummaryToSnapshotTreeAndBlobs": {"backCompat": false}
 */
declare type current_as_old_for_Function_convertWholeFlatSummaryToSnapshotTreeAndBlobs = requireAssignableTo<TypeOnly<typeof current.convertWholeFlatSummaryToSnapshotTreeAndBlobs>, TypeOnly<typeof old.convertWholeFlatSummaryToSnapshotTreeAndBlobs>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_createFluidServiceNetworkError": {"backCompat": false}
 */
declare type current_as_old_for_Function_createFluidServiceNetworkError = requireAssignableTo<TypeOnly<typeof current.createFluidServiceNetworkError>, TypeOnly<typeof old.createFluidServiceNetworkError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_dedupeSortedArray": {"backCompat": false}
 */
declare type current_as_old_for_Function_dedupeSortedArray = requireAssignableTo<TypeOnly<typeof current.dedupeSortedArray>, TypeOnly<typeof old.dedupeSortedArray>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_generateServiceProtocolEntries": {"backCompat": false}
 */
declare type current_as_old_for_Function_generateServiceProtocolEntries = requireAssignableTo<TypeOnly<typeof current.generateServiceProtocolEntries>, TypeOnly<typeof old.generateServiceProtocolEntries>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_generateToken": {"backCompat": false}
 */
declare type current_as_old_for_Function_generateToken = requireAssignableTo<TypeOnly<typeof current.generateToken>, TypeOnly<typeof old.generateToken>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_generateUser": {"backCompat": false}
 */
declare type current_as_old_for_Function_generateUser = requireAssignableTo<TypeOnly<typeof current.generateUser>, TypeOnly<typeof old.generateUser>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_getNextHash": {"backCompat": false}
 */
declare type current_as_old_for_Function_getNextHash = requireAssignableTo<TypeOnly<typeof current.getNextHash>, TypeOnly<typeof old.getNextHash>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_getOrCreateRepository": {"backCompat": false}
 */
declare type current_as_old_for_Function_getOrCreateRepository = requireAssignableTo<TypeOnly<typeof current.getOrCreateRepository>, TypeOnly<typeof old.getOrCreateRepository>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_getQuorumTreeEntries": {"backCompat": false}
 */
declare type current_as_old_for_Function_getQuorumTreeEntries = requireAssignableTo<TypeOnly<typeof current.getQuorumTreeEntries>, TypeOnly<typeof old.getQuorumTreeEntries>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_getRandomName": {"backCompat": false}
 */
declare type current_as_old_for_Function_getRandomName = requireAssignableTo<TypeOnly<typeof current.getRandomName>, TypeOnly<typeof old.getRandomName>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_isNetworkError": {"backCompat": false}
 */
declare type current_as_old_for_Function_isNetworkError = requireAssignableTo<TypeOnly<typeof current.isNetworkError>, TypeOnly<typeof old.isNetworkError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_mergeAppAndProtocolTree": {"backCompat": false}
 */
declare type current_as_old_for_Function_mergeAppAndProtocolTree = requireAssignableTo<TypeOnly<typeof current.mergeAppAndProtocolTree>, TypeOnly<typeof old.mergeAppAndProtocolTree>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_mergeKArrays": {"backCompat": false}
 */
declare type current_as_old_for_Function_mergeKArrays = requireAssignableTo<TypeOnly<typeof current.mergeKArrays>, TypeOnly<typeof old.mergeKArrays>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_mergeSortedArrays": {"backCompat": false}
 */
declare type current_as_old_for_Function_mergeSortedArrays = requireAssignableTo<TypeOnly<typeof current.mergeSortedArrays>, TypeOnly<typeof old.mergeSortedArrays>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_promiseTimeout": {"backCompat": false}
 */
declare type current_as_old_for_Function_promiseTimeout = requireAssignableTo<TypeOnly<typeof current.promiseTimeout>, TypeOnly<typeof old.promiseTimeout>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_throwFluidServiceNetworkError": {"backCompat": false}
 */
declare type current_as_old_for_Function_throwFluidServiceNetworkError = requireAssignableTo<TypeOnly<typeof current.throwFluidServiceNetworkError>, TypeOnly<typeof old.throwFluidServiceNetworkError>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_validateTokenClaims": {"backCompat": false}
 */
declare type current_as_old_for_Function_validateTokenClaims = requireAssignableTo<TypeOnly<typeof current.validateTokenClaims>, TypeOnly<typeof old.validateTokenClaims>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Function_validateTokenClaimsExpiration": {"backCompat": false}
 */
declare type current_as_old_for_Function_validateTokenClaimsExpiration = requireAssignableTo<TypeOnly<typeof current.validateTokenClaimsExpiration>, TypeOnly<typeof old.validateTokenClaimsExpiration>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAlfredTenant": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IAlfredTenant = requireAssignableTo<TypeOnly<old.IAlfredTenant>, TypeOnly<current.IAlfredTenant>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IAlfredTenant": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IAlfredTenant = requireAssignableTo<TypeOnly<current.IAlfredTenant>, TypeOnly<old.IAlfredTenant>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICreateRefParamsExternal": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ICreateRefParamsExternal = requireAssignableTo<TypeOnly<old.ICreateRefParamsExternal>, TypeOnly<current.ICreateRefParamsExternal>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICreateRefParamsExternal": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ICreateRefParamsExternal = requireAssignableTo<TypeOnly<current.ICreateRefParamsExternal>, TypeOnly<old.ICreateRefParamsExternal>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICredentials": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ICredentials = requireAssignableTo<TypeOnly<old.ICredentials>, TypeOnly<current.ICredentials>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ICredentials": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ICredentials = requireAssignableTo<TypeOnly<current.ICredentials>, TypeOnly<old.ICredentials>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IEmbeddedSummaryHandle": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IEmbeddedSummaryHandle = requireAssignableTo<TypeOnly<old.IEmbeddedSummaryHandle>, TypeOnly<current.IEmbeddedSummaryHandle>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IEmbeddedSummaryHandle": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IEmbeddedSummaryHandle = requireAssignableTo<TypeOnly<current.IEmbeddedSummaryHandle>, TypeOnly<old.IEmbeddedSummaryHandle>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IExternalWriterConfig": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IExternalWriterConfig = requireAssignableTo<TypeOnly<old.IExternalWriterConfig>, TypeOnly<current.IExternalWriterConfig>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IExternalWriterConfig": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IExternalWriterConfig = requireAssignableTo<TypeOnly<current.IExternalWriterConfig>, TypeOnly<old.IExternalWriterConfig>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGetRefParamsExternal": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IGetRefParamsExternal = requireAssignableTo<TypeOnly<old.IGetRefParamsExternal>, TypeOnly<current.IGetRefParamsExternal>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGetRefParamsExternal": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IGetRefParamsExternal = requireAssignableTo<TypeOnly<current.IGetRefParamsExternal>, TypeOnly<old.IGetRefParamsExternal>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGitCache": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IGitCache = requireAssignableTo<TypeOnly<old.IGitCache>, TypeOnly<current.IGitCache>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGitCache": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IGitCache = requireAssignableTo<TypeOnly<current.IGitCache>, TypeOnly<old.IGitCache>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGitManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IGitManager = requireAssignableTo<TypeOnly<old.IGitManager>, TypeOnly<current.IGitManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGitManager": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IGitManager = requireAssignableTo<TypeOnly<current.IGitManager>, TypeOnly<old.IGitManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGitService": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IGitService = requireAssignableTo<TypeOnly<old.IGitService>, TypeOnly<current.IGitService>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IGitService": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IGitService = requireAssignableTo<TypeOnly<current.IGitService>, TypeOnly<old.IGitService>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IHeapComparator": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IHeapComparator = requireAssignableTo<TypeOnly<old.IHeapComparator<never>>, TypeOnly<current.IHeapComparator<never>>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IHeapComparator": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IHeapComparator = requireAssignableTo<TypeOnly<current.IHeapComparator<never>>, TypeOnly<old.IHeapComparator<never>>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IHistorian": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IHistorian = requireAssignableTo<TypeOnly<old.IHistorian>, TypeOnly<current.IHistorian>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IHistorian": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IHistorian = requireAssignableTo<TypeOnly<current.IHistorian>, TypeOnly<old.IHistorian>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INetworkErrorDetails": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_INetworkErrorDetails = requireAssignableTo<TypeOnly<old.INetworkErrorDetails>, TypeOnly<current.INetworkErrorDetails>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INetworkErrorDetails": {"backCompat": false}
 */
// @ts-expect-error compatibility expected to be broken
declare type current_as_old_for_Interface_INetworkErrorDetails = requireAssignableTo<TypeOnly<current.INetworkErrorDetails>, TypeOnly<old.INetworkErrorDetails>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INormalizedWholeSummary": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_INormalizedWholeSummary = requireAssignableTo<TypeOnly<old.INormalizedWholeSummary>, TypeOnly<current.INormalizedWholeSummary>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_INormalizedWholeSummary": {"backCompat": false}
 */
declare type current_as_old_for_Interface_INormalizedWholeSummary = requireAssignableTo<TypeOnly<current.INormalizedWholeSummary>, TypeOnly<old.INormalizedWholeSummary>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPatchRefParamsExternal": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IPatchRefParamsExternal = requireAssignableTo<TypeOnly<old.IPatchRefParamsExternal>, TypeOnly<current.IPatchRefParamsExternal>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IPatchRefParamsExternal": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IPatchRefParamsExternal = requireAssignableTo<TypeOnly<current.IPatchRefParamsExternal>, TypeOnly<old.IPatchRefParamsExternal>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISession": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISession = requireAssignableTo<TypeOnly<old.ISession>, TypeOnly<current.ISession>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISession": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISession = requireAssignableTo<TypeOnly<current.ISession>, TypeOnly<old.ISession>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryTree": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryTree = requireAssignableTo<TypeOnly<old.ISummaryTree>, TypeOnly<current.ISummaryTree>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryTree": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryTree = requireAssignableTo<TypeOnly<current.ISummaryTree>, TypeOnly<old.ISummaryTree>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryUploadManager": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ISummaryUploadManager = requireAssignableTo<TypeOnly<old.ISummaryUploadManager>, TypeOnly<current.ISummaryUploadManager>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ISummaryUploadManager": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ISummaryUploadManager = requireAssignableTo<TypeOnly<current.ISummaryUploadManager>, TypeOnly<old.ISummaryUploadManager>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITimeoutContext": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_ITimeoutContext = requireAssignableTo<TypeOnly<old.ITimeoutContext>, TypeOnly<current.ITimeoutContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_ITimeoutContext": {"backCompat": false}
 */
declare type current_as_old_for_Interface_ITimeoutContext = requireAssignableTo<TypeOnly<current.ITimeoutContext>, TypeOnly<old.ITimeoutContext>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWholeFlatSummary": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IWholeFlatSummary = requireAssignableTo<TypeOnly<old.IWholeFlatSummary>, TypeOnly<current.IWholeFlatSummary>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWholeFlatSummary": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IWholeFlatSummary = requireAssignableTo<TypeOnly<current.IWholeFlatSummary>, TypeOnly<old.IWholeFlatSummary>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWholeFlatSummaryBlob": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IWholeFlatSummaryBlob = requireAssignableTo<TypeOnly<old.IWholeFlatSummaryBlob>, TypeOnly<current.IWholeFlatSummaryBlob>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWholeFlatSummaryBlob": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IWholeFlatSummaryBlob = requireAssignableTo<TypeOnly<current.IWholeFlatSummaryBlob>, TypeOnly<old.IWholeFlatSummaryBlob>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWholeFlatSummaryTree": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IWholeFlatSummaryTree = requireAssignableTo<TypeOnly<old.IWholeFlatSummaryTree>, TypeOnly<current.IWholeFlatSummaryTree>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWholeFlatSummaryTree": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IWholeFlatSummaryTree = requireAssignableTo<TypeOnly<current.IWholeFlatSummaryTree>, TypeOnly<old.IWholeFlatSummaryTree>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWholeFlatSummaryTreeEntryBlob": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IWholeFlatSummaryTreeEntryBlob = requireAssignableTo<TypeOnly<old.IWholeFlatSummaryTreeEntryBlob>, TypeOnly<current.IWholeFlatSummaryTreeEntryBlob>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWholeFlatSummaryTreeEntryBlob": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IWholeFlatSummaryTreeEntryBlob = requireAssignableTo<TypeOnly<current.IWholeFlatSummaryTreeEntryBlob>, TypeOnly<old.IWholeFlatSummaryTreeEntryBlob>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWholeFlatSummaryTreeEntryTree": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IWholeFlatSummaryTreeEntryTree = requireAssignableTo<TypeOnly<old.IWholeFlatSummaryTreeEntryTree>, TypeOnly<current.IWholeFlatSummaryTreeEntryTree>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWholeFlatSummaryTreeEntryTree": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IWholeFlatSummaryTreeEntryTree = requireAssignableTo<TypeOnly<current.IWholeFlatSummaryTreeEntryTree>, TypeOnly<old.IWholeFlatSummaryTreeEntryTree>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWholeSummaryBlob": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IWholeSummaryBlob = requireAssignableTo<TypeOnly<old.IWholeSummaryBlob>, TypeOnly<current.IWholeSummaryBlob>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWholeSummaryBlob": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IWholeSummaryBlob = requireAssignableTo<TypeOnly<current.IWholeSummaryBlob>, TypeOnly<old.IWholeSummaryBlob>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWholeSummaryPayload": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IWholeSummaryPayload = requireAssignableTo<TypeOnly<old.IWholeSummaryPayload>, TypeOnly<current.IWholeSummaryPayload>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWholeSummaryPayload": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IWholeSummaryPayload = requireAssignableTo<TypeOnly<current.IWholeSummaryPayload>, TypeOnly<old.IWholeSummaryPayload>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWholeSummaryTree": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IWholeSummaryTree = requireAssignableTo<TypeOnly<old.IWholeSummaryTree>, TypeOnly<current.IWholeSummaryTree>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWholeSummaryTree": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IWholeSummaryTree = requireAssignableTo<TypeOnly<current.IWholeSummaryTree>, TypeOnly<old.IWholeSummaryTree>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWholeSummaryTreeBaseEntry": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IWholeSummaryTreeBaseEntry = requireAssignableTo<TypeOnly<old.IWholeSummaryTreeBaseEntry>, TypeOnly<current.IWholeSummaryTreeBaseEntry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWholeSummaryTreeBaseEntry": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IWholeSummaryTreeBaseEntry = requireAssignableTo<TypeOnly<current.IWholeSummaryTreeBaseEntry>, TypeOnly<old.IWholeSummaryTreeBaseEntry>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWholeSummaryTreeHandleEntry": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IWholeSummaryTreeHandleEntry = requireAssignableTo<TypeOnly<old.IWholeSummaryTreeHandleEntry>, TypeOnly<current.IWholeSummaryTreeHandleEntry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWholeSummaryTreeHandleEntry": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IWholeSummaryTreeHandleEntry = requireAssignableTo<TypeOnly<current.IWholeSummaryTreeHandleEntry>, TypeOnly<old.IWholeSummaryTreeHandleEntry>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWholeSummaryTreeValueEntry": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IWholeSummaryTreeValueEntry = requireAssignableTo<TypeOnly<old.IWholeSummaryTreeValueEntry>, TypeOnly<current.IWholeSummaryTreeValueEntry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWholeSummaryTreeValueEntry": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IWholeSummaryTreeValueEntry = requireAssignableTo<TypeOnly<current.IWholeSummaryTreeValueEntry>, TypeOnly<old.IWholeSummaryTreeValueEntry>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWriteSummaryResponse": {"forwardCompat": false}
 */
declare type old_as_current_for_Interface_IWriteSummaryResponse = requireAssignableTo<TypeOnly<old.IWriteSummaryResponse>, TypeOnly<current.IWriteSummaryResponse>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Interface_IWriteSummaryResponse": {"backCompat": false}
 */
declare type current_as_old_for_Interface_IWriteSummaryResponse = requireAssignableTo<TypeOnly<current.IWriteSummaryResponse>, TypeOnly<old.IWriteSummaryResponse>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ExtendedSummaryObject": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_ExtendedSummaryObject = requireAssignableTo<TypeOnly<old.ExtendedSummaryObject>, TypeOnly<current.ExtendedSummaryObject>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_ExtendedSummaryObject": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_ExtendedSummaryObject = requireAssignableTo<TypeOnly<current.ExtendedSummaryObject>, TypeOnly<old.ExtendedSummaryObject>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IWholeFlatSummaryTreeEntry": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IWholeFlatSummaryTreeEntry = requireAssignableTo<TypeOnly<old.IWholeFlatSummaryTreeEntry>, TypeOnly<current.IWholeFlatSummaryTreeEntry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IWholeFlatSummaryTreeEntry": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IWholeFlatSummaryTreeEntry = requireAssignableTo<TypeOnly<current.IWholeFlatSummaryTreeEntry>, TypeOnly<old.IWholeFlatSummaryTreeEntry>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IWholeSummaryPayloadType": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_IWholeSummaryPayloadType = requireAssignableTo<TypeOnly<old.IWholeSummaryPayloadType>, TypeOnly<current.IWholeSummaryPayloadType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_IWholeSummaryPayloadType": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_IWholeSummaryPayloadType = requireAssignableTo<TypeOnly<current.IWholeSummaryPayloadType>, TypeOnly<old.IWholeSummaryPayloadType>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_WholeSummaryTreeEntry": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_WholeSummaryTreeEntry = requireAssignableTo<TypeOnly<old.WholeSummaryTreeEntry>, TypeOnly<current.WholeSummaryTreeEntry>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_WholeSummaryTreeEntry": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_WholeSummaryTreeEntry = requireAssignableTo<TypeOnly<current.WholeSummaryTreeEntry>, TypeOnly<old.WholeSummaryTreeEntry>>

/*
 * Validate forward compatibility by using the old type in place of the current type.
 * If this test starts failing, it indicates a change that is not forward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_WholeSummaryTreeValue": {"forwardCompat": false}
 */
declare type old_as_current_for_TypeAlias_WholeSummaryTreeValue = requireAssignableTo<TypeOnly<old.WholeSummaryTreeValue>, TypeOnly<current.WholeSummaryTreeValue>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "TypeAlias_WholeSummaryTreeValue": {"backCompat": false}
 */
declare type current_as_old_for_TypeAlias_WholeSummaryTreeValue = requireAssignableTo<TypeOnly<current.WholeSummaryTreeValue>, TypeOnly<old.WholeSummaryTreeValue>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_buildTreePath": {"backCompat": false}
 */
declare type current_as_old_for_Variable_buildTreePath = requireAssignableTo<TypeOnly<typeof current.buildTreePath>, TypeOnly<typeof old.buildTreePath>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_canDeleteDoc": {"backCompat": false}
 */
declare type current_as_old_for_Variable_canDeleteDoc = requireAssignableTo<TypeOnly<typeof current.canDeleteDoc>, TypeOnly<typeof old.canDeleteDoc>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_canRead": {"backCompat": false}
 */
declare type current_as_old_for_Variable_canRead = requireAssignableTo<TypeOnly<typeof current.canRead>, TypeOnly<typeof old.canRead>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_canRevokeToken": {"backCompat": false}
 */
declare type current_as_old_for_Variable_canRevokeToken = requireAssignableTo<TypeOnly<typeof current.canRevokeToken>, TypeOnly<typeof old.canRevokeToken>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_canSummarize": {"backCompat": false}
 */
declare type current_as_old_for_Variable_canSummarize = requireAssignableTo<TypeOnly<typeof current.canSummarize>, TypeOnly<typeof old.canSummarize>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_canWrite": {"backCompat": false}
 */
declare type current_as_old_for_Variable_canWrite = requireAssignableTo<TypeOnly<typeof current.canWrite>, TypeOnly<typeof old.canWrite>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_choose": {"backCompat": false}
 */
declare type current_as_old_for_Variable_choose = requireAssignableTo<TypeOnly<typeof current.choose>, TypeOnly<typeof old.choose>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_CorrelationIdHeaderName": {"backCompat": false}
 */
declare type current_as_old_for_Variable_CorrelationIdHeaderName = requireAssignableTo<TypeOnly<typeof current.CorrelationIdHeaderName>, TypeOnly<typeof old.CorrelationIdHeaderName>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_defaultHash": {"backCompat": false}
 */
declare type current_as_old_for_Variable_defaultHash = requireAssignableTo<TypeOnly<typeof current.defaultHash>, TypeOnly<typeof old.defaultHash>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_DocDeleteScopeType": {"backCompat": false}
 */
declare type current_as_old_for_Variable_DocDeleteScopeType = requireAssignableTo<TypeOnly<typeof current.DocDeleteScopeType>, TypeOnly<typeof old.DocDeleteScopeType>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_DriverVersionHeaderName": {"backCompat": false}
 */
declare type current_as_old_for_Variable_DriverVersionHeaderName = requireAssignableTo<TypeOnly<typeof current.DriverVersionHeaderName>, TypeOnly<typeof old.DriverVersionHeaderName>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_getAuthorizationTokenFromCredentials": {"backCompat": false}
 */
declare type current_as_old_for_Variable_getAuthorizationTokenFromCredentials = requireAssignableTo<TypeOnly<typeof current.getAuthorizationTokenFromCredentials>, TypeOnly<typeof old.getAuthorizationTokenFromCredentials>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_getGlobalTimeoutContext": {"backCompat": false}
 */
declare type current_as_old_for_Variable_getGlobalTimeoutContext = requireAssignableTo<TypeOnly<typeof current.getGlobalTimeoutContext>, TypeOnly<typeof old.getGlobalTimeoutContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_getRandomInt": {"backCompat": false}
 */
declare type current_as_old_for_Variable_getRandomInt = requireAssignableTo<TypeOnly<typeof current.getRandomInt>, TypeOnly<typeof old.getRandomInt>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_LatestSummaryId": {"backCompat": false}
 */
declare type current_as_old_for_Variable_LatestSummaryId = requireAssignableTo<TypeOnly<typeof current.LatestSummaryId>, TypeOnly<typeof old.LatestSummaryId>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_setGlobalTimeoutContext": {"backCompat": false}
 */
declare type current_as_old_for_Variable_setGlobalTimeoutContext = requireAssignableTo<TypeOnly<typeof current.setGlobalTimeoutContext>, TypeOnly<typeof old.setGlobalTimeoutContext>>

/*
 * Validate backward compatibility by using the current type in place of the old type.
 * If this test starts failing, it indicates a change that is not backward compatible.
 * To acknowledge the breaking change, add the following to package.json under
 * typeValidation.broken:
 * "Variable_TokenRevokeScopeType": {"backCompat": false}
 */
declare type current_as_old_for_Variable_TokenRevokeScopeType = requireAssignableTo<TypeOnly<typeof current.TokenRevokeScopeType>, TypeOnly<typeof old.TokenRevokeScopeType>>
