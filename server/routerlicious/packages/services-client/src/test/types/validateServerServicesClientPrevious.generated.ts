/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-test-generator in @fluidframework/build-tools.
 */

import type * as old from "@fluidframework/server-services-client-previous";
import type * as current from "../../index.js";


// See 'build-tools/src/type-test-generator/compatibility.ts' for more information.
type TypeOnly<T> = T extends number
	? number
	: T extends string
	? string
	: T extends boolean | bigint | symbol
	? T
	: {
			[P in keyof T]: TypeOnly<T[P]>;
	  };

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BasicRestWrapper": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_BasicRestWrapper():
    TypeOnly<old.BasicRestWrapper>;
declare function use_current_ClassDeclaration_BasicRestWrapper(
    use: TypeOnly<current.BasicRestWrapper>): void;
use_current_ClassDeclaration_BasicRestWrapper(
    get_old_ClassDeclaration_BasicRestWrapper());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_BasicRestWrapper": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_BasicRestWrapper():
    TypeOnly<current.BasicRestWrapper>;
declare function use_old_ClassDeclaration_BasicRestWrapper(
    use: TypeOnly<old.BasicRestWrapper>): void;
use_old_ClassDeclaration_BasicRestWrapper(
    get_current_ClassDeclaration_BasicRestWrapper());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_CorrelationIdHeaderName": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_CorrelationIdHeaderName():
    TypeOnly<typeof old.CorrelationIdHeaderName>;
declare function use_current_VariableDeclaration_CorrelationIdHeaderName(
    use: TypeOnly<typeof current.CorrelationIdHeaderName>): void;
use_current_VariableDeclaration_CorrelationIdHeaderName(
    get_old_VariableDeclaration_CorrelationIdHeaderName());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_CorrelationIdHeaderName": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_CorrelationIdHeaderName():
    TypeOnly<typeof current.CorrelationIdHeaderName>;
declare function use_old_VariableDeclaration_CorrelationIdHeaderName(
    use: TypeOnly<typeof old.CorrelationIdHeaderName>): void;
use_old_VariableDeclaration_CorrelationIdHeaderName(
    get_current_VariableDeclaration_CorrelationIdHeaderName());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DocDeleteScopeType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_DocDeleteScopeType():
    TypeOnly<typeof old.DocDeleteScopeType>;
declare function use_current_VariableDeclaration_DocDeleteScopeType(
    use: TypeOnly<typeof current.DocDeleteScopeType>): void;
use_current_VariableDeclaration_DocDeleteScopeType(
    get_old_VariableDeclaration_DocDeleteScopeType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DocDeleteScopeType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_DocDeleteScopeType():
    TypeOnly<typeof current.DocDeleteScopeType>;
declare function use_old_VariableDeclaration_DocDeleteScopeType(
    use: TypeOnly<typeof old.DocDeleteScopeType>): void;
use_old_VariableDeclaration_DocDeleteScopeType(
    get_current_VariableDeclaration_DocDeleteScopeType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DriverVersionHeaderName": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_DriverVersionHeaderName():
    TypeOnly<typeof old.DriverVersionHeaderName>;
declare function use_current_VariableDeclaration_DriverVersionHeaderName(
    use: TypeOnly<typeof current.DriverVersionHeaderName>): void;
use_current_VariableDeclaration_DriverVersionHeaderName(
    get_old_VariableDeclaration_DriverVersionHeaderName());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_DriverVersionHeaderName": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_DriverVersionHeaderName():
    TypeOnly<typeof current.DriverVersionHeaderName>;
declare function use_old_VariableDeclaration_DriverVersionHeaderName(
    use: TypeOnly<typeof old.DriverVersionHeaderName>): void;
use_old_VariableDeclaration_DriverVersionHeaderName(
    get_current_VariableDeclaration_DriverVersionHeaderName());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ExtendedSummaryObject": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_ExtendedSummaryObject():
    TypeOnly<old.ExtendedSummaryObject>;
declare function use_current_TypeAliasDeclaration_ExtendedSummaryObject(
    use: TypeOnly<current.ExtendedSummaryObject>): void;
use_current_TypeAliasDeclaration_ExtendedSummaryObject(
    get_old_TypeAliasDeclaration_ExtendedSummaryObject());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_ExtendedSummaryObject": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_ExtendedSummaryObject():
    TypeOnly<current.ExtendedSummaryObject>;
declare function use_old_TypeAliasDeclaration_ExtendedSummaryObject(
    use: TypeOnly<old.ExtendedSummaryObject>): void;
use_old_TypeAliasDeclaration_ExtendedSummaryObject(
    get_current_TypeAliasDeclaration_ExtendedSummaryObject());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_GitManager": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_GitManager():
    TypeOnly<old.GitManager>;
declare function use_current_ClassDeclaration_GitManager(
    use: TypeOnly<current.GitManager>): void;
use_current_ClassDeclaration_GitManager(
    get_old_ClassDeclaration_GitManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_GitManager": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_GitManager():
    TypeOnly<current.GitManager>;
declare function use_old_ClassDeclaration_GitManager(
    use: TypeOnly<old.GitManager>): void;
use_old_ClassDeclaration_GitManager(
    get_current_ClassDeclaration_GitManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Heap": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Heap():
    TypeOnly<old.Heap<any>>;
declare function use_current_ClassDeclaration_Heap(
    use: TypeOnly<current.Heap<any>>): void;
use_current_ClassDeclaration_Heap(
    get_old_ClassDeclaration_Heap());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Heap": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Heap():
    TypeOnly<current.Heap<any>>;
declare function use_old_ClassDeclaration_Heap(
    use: TypeOnly<old.Heap<any>>): void;
use_old_ClassDeclaration_Heap(
    get_current_ClassDeclaration_Heap());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Historian": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_Historian():
    TypeOnly<old.Historian>;
declare function use_current_ClassDeclaration_Historian(
    use: TypeOnly<current.Historian>): void;
use_current_ClassDeclaration_Historian(
    get_old_ClassDeclaration_Historian());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_Historian": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_Historian():
    TypeOnly<current.Historian>;
declare function use_old_ClassDeclaration_Historian(
    use: TypeOnly<old.Historian>): void;
use_old_ClassDeclaration_Historian(
    get_current_ClassDeclaration_Historian());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAlfredTenant": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IAlfredTenant():
    TypeOnly<old.IAlfredTenant>;
declare function use_current_InterfaceDeclaration_IAlfredTenant(
    use: TypeOnly<current.IAlfredTenant>): void;
use_current_InterfaceDeclaration_IAlfredTenant(
    get_old_InterfaceDeclaration_IAlfredTenant());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IAlfredTenant": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IAlfredTenant():
    TypeOnly<current.IAlfredTenant>;
declare function use_old_InterfaceDeclaration_IAlfredTenant(
    use: TypeOnly<old.IAlfredTenant>): void;
use_old_InterfaceDeclaration_IAlfredTenant(
    get_current_InterfaceDeclaration_IAlfredTenant());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICreateRefParamsExternal": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICreateRefParamsExternal():
    TypeOnly<old.ICreateRefParamsExternal>;
declare function use_current_InterfaceDeclaration_ICreateRefParamsExternal(
    use: TypeOnly<current.ICreateRefParamsExternal>): void;
use_current_InterfaceDeclaration_ICreateRefParamsExternal(
    get_old_InterfaceDeclaration_ICreateRefParamsExternal());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICreateRefParamsExternal": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICreateRefParamsExternal():
    TypeOnly<current.ICreateRefParamsExternal>;
declare function use_old_InterfaceDeclaration_ICreateRefParamsExternal(
    use: TypeOnly<old.ICreateRefParamsExternal>): void;
use_old_InterfaceDeclaration_ICreateRefParamsExternal(
    get_current_InterfaceDeclaration_ICreateRefParamsExternal());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICredentials": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ICredentials():
    TypeOnly<old.ICredentials>;
declare function use_current_InterfaceDeclaration_ICredentials(
    use: TypeOnly<current.ICredentials>): void;
use_current_InterfaceDeclaration_ICredentials(
    get_old_InterfaceDeclaration_ICredentials());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ICredentials": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ICredentials():
    TypeOnly<current.ICredentials>;
declare function use_old_InterfaceDeclaration_ICredentials(
    use: TypeOnly<old.ICredentials>): void;
use_old_InterfaceDeclaration_ICredentials(
    get_current_InterfaceDeclaration_ICredentials());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEmbeddedSummaryHandle": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IEmbeddedSummaryHandle():
    TypeOnly<old.IEmbeddedSummaryHandle>;
declare function use_current_InterfaceDeclaration_IEmbeddedSummaryHandle(
    use: TypeOnly<current.IEmbeddedSummaryHandle>): void;
use_current_InterfaceDeclaration_IEmbeddedSummaryHandle(
    get_old_InterfaceDeclaration_IEmbeddedSummaryHandle());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IEmbeddedSummaryHandle": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IEmbeddedSummaryHandle():
    TypeOnly<current.IEmbeddedSummaryHandle>;
declare function use_old_InterfaceDeclaration_IEmbeddedSummaryHandle(
    use: TypeOnly<old.IEmbeddedSummaryHandle>): void;
use_old_InterfaceDeclaration_IEmbeddedSummaryHandle(
    get_current_InterfaceDeclaration_IEmbeddedSummaryHandle());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IExternalWriterConfig": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IExternalWriterConfig():
    TypeOnly<old.IExternalWriterConfig>;
declare function use_current_InterfaceDeclaration_IExternalWriterConfig(
    use: TypeOnly<current.IExternalWriterConfig>): void;
use_current_InterfaceDeclaration_IExternalWriterConfig(
    get_old_InterfaceDeclaration_IExternalWriterConfig());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IExternalWriterConfig": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IExternalWriterConfig():
    TypeOnly<current.IExternalWriterConfig>;
declare function use_old_InterfaceDeclaration_IExternalWriterConfig(
    use: TypeOnly<old.IExternalWriterConfig>): void;
use_old_InterfaceDeclaration_IExternalWriterConfig(
    get_current_InterfaceDeclaration_IExternalWriterConfig());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGetRefParamsExternal": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGetRefParamsExternal():
    TypeOnly<old.IGetRefParamsExternal>;
declare function use_current_InterfaceDeclaration_IGetRefParamsExternal(
    use: TypeOnly<current.IGetRefParamsExternal>): void;
use_current_InterfaceDeclaration_IGetRefParamsExternal(
    get_old_InterfaceDeclaration_IGetRefParamsExternal());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGetRefParamsExternal": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGetRefParamsExternal():
    TypeOnly<current.IGetRefParamsExternal>;
declare function use_old_InterfaceDeclaration_IGetRefParamsExternal(
    use: TypeOnly<old.IGetRefParamsExternal>): void;
use_old_InterfaceDeclaration_IGetRefParamsExternal(
    get_current_InterfaceDeclaration_IGetRefParamsExternal());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGitCache": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGitCache():
    TypeOnly<old.IGitCache>;
declare function use_current_InterfaceDeclaration_IGitCache(
    use: TypeOnly<current.IGitCache>): void;
use_current_InterfaceDeclaration_IGitCache(
    get_old_InterfaceDeclaration_IGitCache());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGitCache": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGitCache():
    TypeOnly<current.IGitCache>;
declare function use_old_InterfaceDeclaration_IGitCache(
    use: TypeOnly<old.IGitCache>): void;
use_old_InterfaceDeclaration_IGitCache(
    get_current_InterfaceDeclaration_IGitCache());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGitManager": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGitManager():
    TypeOnly<old.IGitManager>;
declare function use_current_InterfaceDeclaration_IGitManager(
    use: TypeOnly<current.IGitManager>): void;
use_current_InterfaceDeclaration_IGitManager(
    get_old_InterfaceDeclaration_IGitManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGitManager": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGitManager():
    TypeOnly<current.IGitManager>;
declare function use_old_InterfaceDeclaration_IGitManager(
    use: TypeOnly<old.IGitManager>): void;
use_old_InterfaceDeclaration_IGitManager(
    get_current_InterfaceDeclaration_IGitManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGitService": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IGitService():
    TypeOnly<old.IGitService>;
declare function use_current_InterfaceDeclaration_IGitService(
    use: TypeOnly<current.IGitService>): void;
use_current_InterfaceDeclaration_IGitService(
    get_old_InterfaceDeclaration_IGitService());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IGitService": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IGitService():
    TypeOnly<current.IGitService>;
declare function use_old_InterfaceDeclaration_IGitService(
    use: TypeOnly<old.IGitService>): void;
use_old_InterfaceDeclaration_IGitService(
    get_current_InterfaceDeclaration_IGitService());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IHeapComparator": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IHeapComparator():
    TypeOnly<old.IHeapComparator<any>>;
declare function use_current_InterfaceDeclaration_IHeapComparator(
    use: TypeOnly<current.IHeapComparator<any>>): void;
use_current_InterfaceDeclaration_IHeapComparator(
    get_old_InterfaceDeclaration_IHeapComparator());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IHeapComparator": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IHeapComparator():
    TypeOnly<current.IHeapComparator<any>>;
declare function use_old_InterfaceDeclaration_IHeapComparator(
    use: TypeOnly<old.IHeapComparator<any>>): void;
use_old_InterfaceDeclaration_IHeapComparator(
    get_current_InterfaceDeclaration_IHeapComparator());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IHistorian": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IHistorian():
    TypeOnly<old.IHistorian>;
declare function use_current_InterfaceDeclaration_IHistorian(
    use: TypeOnly<current.IHistorian>): void;
use_current_InterfaceDeclaration_IHistorian(
    get_old_InterfaceDeclaration_IHistorian());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IHistorian": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IHistorian():
    TypeOnly<current.IHistorian>;
declare function use_old_InterfaceDeclaration_IHistorian(
    use: TypeOnly<old.IHistorian>): void;
use_old_InterfaceDeclaration_IHistorian(
    get_current_InterfaceDeclaration_IHistorian());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_INetworkErrorDetails": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_INetworkErrorDetails():
    TypeOnly<old.INetworkErrorDetails>;
declare function use_current_InterfaceDeclaration_INetworkErrorDetails(
    use: TypeOnly<current.INetworkErrorDetails>): void;
use_current_InterfaceDeclaration_INetworkErrorDetails(
    get_old_InterfaceDeclaration_INetworkErrorDetails());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_INetworkErrorDetails": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_INetworkErrorDetails():
    TypeOnly<current.INetworkErrorDetails>;
declare function use_old_InterfaceDeclaration_INetworkErrorDetails(
    use: TypeOnly<old.INetworkErrorDetails>): void;
use_old_InterfaceDeclaration_INetworkErrorDetails(
    get_current_InterfaceDeclaration_INetworkErrorDetails());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_INormalizedWholeSummary": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_INormalizedWholeSummary():
    TypeOnly<old.INormalizedWholeSummary>;
declare function use_current_InterfaceDeclaration_INormalizedWholeSummary(
    use: TypeOnly<current.INormalizedWholeSummary>): void;
use_current_InterfaceDeclaration_INormalizedWholeSummary(
    get_old_InterfaceDeclaration_INormalizedWholeSummary());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_INormalizedWholeSummary": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_INormalizedWholeSummary():
    TypeOnly<current.INormalizedWholeSummary>;
declare function use_old_InterfaceDeclaration_INormalizedWholeSummary(
    use: TypeOnly<old.INormalizedWholeSummary>): void;
use_old_InterfaceDeclaration_INormalizedWholeSummary(
    get_current_InterfaceDeclaration_INormalizedWholeSummary());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPatchRefParamsExternal": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IPatchRefParamsExternal():
    TypeOnly<old.IPatchRefParamsExternal>;
declare function use_current_InterfaceDeclaration_IPatchRefParamsExternal(
    use: TypeOnly<current.IPatchRefParamsExternal>): void;
use_current_InterfaceDeclaration_IPatchRefParamsExternal(
    get_old_InterfaceDeclaration_IPatchRefParamsExternal());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IPatchRefParamsExternal": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IPatchRefParamsExternal():
    TypeOnly<current.IPatchRefParamsExternal>;
declare function use_old_InterfaceDeclaration_IPatchRefParamsExternal(
    use: TypeOnly<old.IPatchRefParamsExternal>): void;
use_old_InterfaceDeclaration_IPatchRefParamsExternal(
    get_current_InterfaceDeclaration_IPatchRefParamsExternal());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISession": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISession():
    TypeOnly<old.ISession>;
declare function use_current_InterfaceDeclaration_ISession(
    use: TypeOnly<current.ISession>): void;
use_current_InterfaceDeclaration_ISession(
    get_old_InterfaceDeclaration_ISession());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISession": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISession():
    TypeOnly<current.ISession>;
declare function use_old_InterfaceDeclaration_ISession(
    use: TypeOnly<old.ISession>): void;
use_old_InterfaceDeclaration_ISession(
    get_current_InterfaceDeclaration_ISession());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryTree": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryTree():
    TypeOnly<old.ISummaryTree>;
declare function use_current_InterfaceDeclaration_ISummaryTree(
    use: TypeOnly<current.ISummaryTree>): void;
use_current_InterfaceDeclaration_ISummaryTree(
    get_old_InterfaceDeclaration_ISummaryTree());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryTree": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryTree():
    TypeOnly<current.ISummaryTree>;
declare function use_old_InterfaceDeclaration_ISummaryTree(
    use: TypeOnly<old.ISummaryTree>): void;
use_old_InterfaceDeclaration_ISummaryTree(
    get_current_InterfaceDeclaration_ISummaryTree());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryUploadManager": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ISummaryUploadManager():
    TypeOnly<old.ISummaryUploadManager>;
declare function use_current_InterfaceDeclaration_ISummaryUploadManager(
    use: TypeOnly<current.ISummaryUploadManager>): void;
use_current_InterfaceDeclaration_ISummaryUploadManager(
    get_old_InterfaceDeclaration_ISummaryUploadManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ISummaryUploadManager": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ISummaryUploadManager():
    TypeOnly<current.ISummaryUploadManager>;
declare function use_old_InterfaceDeclaration_ISummaryUploadManager(
    use: TypeOnly<old.ISummaryUploadManager>): void;
use_old_InterfaceDeclaration_ISummaryUploadManager(
    get_current_InterfaceDeclaration_ISummaryUploadManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITimeoutContext": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_ITimeoutContext():
    TypeOnly<old.ITimeoutContext>;
declare function use_current_InterfaceDeclaration_ITimeoutContext(
    use: TypeOnly<current.ITimeoutContext>): void;
use_current_InterfaceDeclaration_ITimeoutContext(
    get_old_InterfaceDeclaration_ITimeoutContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_ITimeoutContext": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_ITimeoutContext():
    TypeOnly<current.ITimeoutContext>;
declare function use_old_InterfaceDeclaration_ITimeoutContext(
    use: TypeOnly<old.ITimeoutContext>): void;
use_old_InterfaceDeclaration_ITimeoutContext(
    get_current_InterfaceDeclaration_ITimeoutContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWholeFlatSummary": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IWholeFlatSummary():
    TypeOnly<old.IWholeFlatSummary>;
declare function use_current_InterfaceDeclaration_IWholeFlatSummary(
    use: TypeOnly<current.IWholeFlatSummary>): void;
use_current_InterfaceDeclaration_IWholeFlatSummary(
    get_old_InterfaceDeclaration_IWholeFlatSummary());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWholeFlatSummary": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IWholeFlatSummary():
    TypeOnly<current.IWholeFlatSummary>;
declare function use_old_InterfaceDeclaration_IWholeFlatSummary(
    use: TypeOnly<old.IWholeFlatSummary>): void;
use_old_InterfaceDeclaration_IWholeFlatSummary(
    get_current_InterfaceDeclaration_IWholeFlatSummary());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWholeFlatSummaryBlob": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IWholeFlatSummaryBlob():
    TypeOnly<old.IWholeFlatSummaryBlob>;
declare function use_current_InterfaceDeclaration_IWholeFlatSummaryBlob(
    use: TypeOnly<current.IWholeFlatSummaryBlob>): void;
use_current_InterfaceDeclaration_IWholeFlatSummaryBlob(
    get_old_InterfaceDeclaration_IWholeFlatSummaryBlob());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWholeFlatSummaryBlob": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IWholeFlatSummaryBlob():
    TypeOnly<current.IWholeFlatSummaryBlob>;
declare function use_old_InterfaceDeclaration_IWholeFlatSummaryBlob(
    use: TypeOnly<old.IWholeFlatSummaryBlob>): void;
use_old_InterfaceDeclaration_IWholeFlatSummaryBlob(
    get_current_InterfaceDeclaration_IWholeFlatSummaryBlob());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWholeFlatSummaryTree": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IWholeFlatSummaryTree():
    TypeOnly<old.IWholeFlatSummaryTree>;
declare function use_current_InterfaceDeclaration_IWholeFlatSummaryTree(
    use: TypeOnly<current.IWholeFlatSummaryTree>): void;
use_current_InterfaceDeclaration_IWholeFlatSummaryTree(
    get_old_InterfaceDeclaration_IWholeFlatSummaryTree());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWholeFlatSummaryTree": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IWholeFlatSummaryTree():
    TypeOnly<current.IWholeFlatSummaryTree>;
declare function use_old_InterfaceDeclaration_IWholeFlatSummaryTree(
    use: TypeOnly<old.IWholeFlatSummaryTree>): void;
use_old_InterfaceDeclaration_IWholeFlatSummaryTree(
    get_current_InterfaceDeclaration_IWholeFlatSummaryTree());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IWholeFlatSummaryTreeEntry": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IWholeFlatSummaryTreeEntry():
    TypeOnly<old.IWholeFlatSummaryTreeEntry>;
declare function use_current_TypeAliasDeclaration_IWholeFlatSummaryTreeEntry(
    use: TypeOnly<current.IWholeFlatSummaryTreeEntry>): void;
use_current_TypeAliasDeclaration_IWholeFlatSummaryTreeEntry(
    get_old_TypeAliasDeclaration_IWholeFlatSummaryTreeEntry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IWholeFlatSummaryTreeEntry": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IWholeFlatSummaryTreeEntry():
    TypeOnly<current.IWholeFlatSummaryTreeEntry>;
declare function use_old_TypeAliasDeclaration_IWholeFlatSummaryTreeEntry(
    use: TypeOnly<old.IWholeFlatSummaryTreeEntry>): void;
use_old_TypeAliasDeclaration_IWholeFlatSummaryTreeEntry(
    get_current_TypeAliasDeclaration_IWholeFlatSummaryTreeEntry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWholeFlatSummaryTreeEntryBlob": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IWholeFlatSummaryTreeEntryBlob():
    TypeOnly<old.IWholeFlatSummaryTreeEntryBlob>;
declare function use_current_InterfaceDeclaration_IWholeFlatSummaryTreeEntryBlob(
    use: TypeOnly<current.IWholeFlatSummaryTreeEntryBlob>): void;
use_current_InterfaceDeclaration_IWholeFlatSummaryTreeEntryBlob(
    get_old_InterfaceDeclaration_IWholeFlatSummaryTreeEntryBlob());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWholeFlatSummaryTreeEntryBlob": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IWholeFlatSummaryTreeEntryBlob():
    TypeOnly<current.IWholeFlatSummaryTreeEntryBlob>;
declare function use_old_InterfaceDeclaration_IWholeFlatSummaryTreeEntryBlob(
    use: TypeOnly<old.IWholeFlatSummaryTreeEntryBlob>): void;
use_old_InterfaceDeclaration_IWholeFlatSummaryTreeEntryBlob(
    get_current_InterfaceDeclaration_IWholeFlatSummaryTreeEntryBlob());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWholeFlatSummaryTreeEntryTree": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IWholeFlatSummaryTreeEntryTree():
    TypeOnly<old.IWholeFlatSummaryTreeEntryTree>;
declare function use_current_InterfaceDeclaration_IWholeFlatSummaryTreeEntryTree(
    use: TypeOnly<current.IWholeFlatSummaryTreeEntryTree>): void;
use_current_InterfaceDeclaration_IWholeFlatSummaryTreeEntryTree(
    get_old_InterfaceDeclaration_IWholeFlatSummaryTreeEntryTree());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWholeFlatSummaryTreeEntryTree": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IWholeFlatSummaryTreeEntryTree():
    TypeOnly<current.IWholeFlatSummaryTreeEntryTree>;
declare function use_old_InterfaceDeclaration_IWholeFlatSummaryTreeEntryTree(
    use: TypeOnly<old.IWholeFlatSummaryTreeEntryTree>): void;
use_old_InterfaceDeclaration_IWholeFlatSummaryTreeEntryTree(
    get_current_InterfaceDeclaration_IWholeFlatSummaryTreeEntryTree());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWholeSummaryBlob": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IWholeSummaryBlob():
    TypeOnly<old.IWholeSummaryBlob>;
declare function use_current_InterfaceDeclaration_IWholeSummaryBlob(
    use: TypeOnly<current.IWholeSummaryBlob>): void;
use_current_InterfaceDeclaration_IWholeSummaryBlob(
    get_old_InterfaceDeclaration_IWholeSummaryBlob());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWholeSummaryBlob": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IWholeSummaryBlob():
    TypeOnly<current.IWholeSummaryBlob>;
declare function use_old_InterfaceDeclaration_IWholeSummaryBlob(
    use: TypeOnly<old.IWholeSummaryBlob>): void;
use_old_InterfaceDeclaration_IWholeSummaryBlob(
    get_current_InterfaceDeclaration_IWholeSummaryBlob());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWholeSummaryPayload": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IWholeSummaryPayload():
    TypeOnly<old.IWholeSummaryPayload>;
declare function use_current_InterfaceDeclaration_IWholeSummaryPayload(
    use: TypeOnly<current.IWholeSummaryPayload>): void;
use_current_InterfaceDeclaration_IWholeSummaryPayload(
    get_old_InterfaceDeclaration_IWholeSummaryPayload());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWholeSummaryPayload": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IWholeSummaryPayload():
    TypeOnly<current.IWholeSummaryPayload>;
declare function use_old_InterfaceDeclaration_IWholeSummaryPayload(
    use: TypeOnly<old.IWholeSummaryPayload>): void;
use_old_InterfaceDeclaration_IWholeSummaryPayload(
    get_current_InterfaceDeclaration_IWholeSummaryPayload());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IWholeSummaryPayloadType": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_IWholeSummaryPayloadType():
    TypeOnly<old.IWholeSummaryPayloadType>;
declare function use_current_TypeAliasDeclaration_IWholeSummaryPayloadType(
    use: TypeOnly<current.IWholeSummaryPayloadType>): void;
use_current_TypeAliasDeclaration_IWholeSummaryPayloadType(
    get_old_TypeAliasDeclaration_IWholeSummaryPayloadType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_IWholeSummaryPayloadType": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_IWholeSummaryPayloadType():
    TypeOnly<current.IWholeSummaryPayloadType>;
declare function use_old_TypeAliasDeclaration_IWholeSummaryPayloadType(
    use: TypeOnly<old.IWholeSummaryPayloadType>): void;
use_old_TypeAliasDeclaration_IWholeSummaryPayloadType(
    get_current_TypeAliasDeclaration_IWholeSummaryPayloadType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWholeSummaryTree": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IWholeSummaryTree():
    TypeOnly<old.IWholeSummaryTree>;
declare function use_current_InterfaceDeclaration_IWholeSummaryTree(
    use: TypeOnly<current.IWholeSummaryTree>): void;
use_current_InterfaceDeclaration_IWholeSummaryTree(
    get_old_InterfaceDeclaration_IWholeSummaryTree());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWholeSummaryTree": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IWholeSummaryTree():
    TypeOnly<current.IWholeSummaryTree>;
declare function use_old_InterfaceDeclaration_IWholeSummaryTree(
    use: TypeOnly<old.IWholeSummaryTree>): void;
use_old_InterfaceDeclaration_IWholeSummaryTree(
    get_current_InterfaceDeclaration_IWholeSummaryTree());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWholeSummaryTreeBaseEntry": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IWholeSummaryTreeBaseEntry():
    TypeOnly<old.IWholeSummaryTreeBaseEntry>;
declare function use_current_InterfaceDeclaration_IWholeSummaryTreeBaseEntry(
    use: TypeOnly<current.IWholeSummaryTreeBaseEntry>): void;
use_current_InterfaceDeclaration_IWholeSummaryTreeBaseEntry(
    get_old_InterfaceDeclaration_IWholeSummaryTreeBaseEntry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWholeSummaryTreeBaseEntry": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IWholeSummaryTreeBaseEntry():
    TypeOnly<current.IWholeSummaryTreeBaseEntry>;
declare function use_old_InterfaceDeclaration_IWholeSummaryTreeBaseEntry(
    use: TypeOnly<old.IWholeSummaryTreeBaseEntry>): void;
use_old_InterfaceDeclaration_IWholeSummaryTreeBaseEntry(
    get_current_InterfaceDeclaration_IWholeSummaryTreeBaseEntry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWholeSummaryTreeHandleEntry": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IWholeSummaryTreeHandleEntry():
    TypeOnly<old.IWholeSummaryTreeHandleEntry>;
declare function use_current_InterfaceDeclaration_IWholeSummaryTreeHandleEntry(
    use: TypeOnly<current.IWholeSummaryTreeHandleEntry>): void;
use_current_InterfaceDeclaration_IWholeSummaryTreeHandleEntry(
    get_old_InterfaceDeclaration_IWholeSummaryTreeHandleEntry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWholeSummaryTreeHandleEntry": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IWholeSummaryTreeHandleEntry():
    TypeOnly<current.IWholeSummaryTreeHandleEntry>;
declare function use_old_InterfaceDeclaration_IWholeSummaryTreeHandleEntry(
    use: TypeOnly<old.IWholeSummaryTreeHandleEntry>): void;
use_old_InterfaceDeclaration_IWholeSummaryTreeHandleEntry(
    get_current_InterfaceDeclaration_IWholeSummaryTreeHandleEntry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWholeSummaryTreeValueEntry": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IWholeSummaryTreeValueEntry():
    TypeOnly<old.IWholeSummaryTreeValueEntry>;
declare function use_current_InterfaceDeclaration_IWholeSummaryTreeValueEntry(
    use: TypeOnly<current.IWholeSummaryTreeValueEntry>): void;
use_current_InterfaceDeclaration_IWholeSummaryTreeValueEntry(
    get_old_InterfaceDeclaration_IWholeSummaryTreeValueEntry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWholeSummaryTreeValueEntry": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IWholeSummaryTreeValueEntry():
    TypeOnly<current.IWholeSummaryTreeValueEntry>;
declare function use_old_InterfaceDeclaration_IWholeSummaryTreeValueEntry(
    use: TypeOnly<old.IWholeSummaryTreeValueEntry>): void;
use_old_InterfaceDeclaration_IWholeSummaryTreeValueEntry(
    get_current_InterfaceDeclaration_IWholeSummaryTreeValueEntry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWriteSummaryResponse": {"forwardCompat": false}
*/
declare function get_old_InterfaceDeclaration_IWriteSummaryResponse():
    TypeOnly<old.IWriteSummaryResponse>;
declare function use_current_InterfaceDeclaration_IWriteSummaryResponse(
    use: TypeOnly<current.IWriteSummaryResponse>): void;
use_current_InterfaceDeclaration_IWriteSummaryResponse(
    get_old_InterfaceDeclaration_IWriteSummaryResponse());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "InterfaceDeclaration_IWriteSummaryResponse": {"backCompat": false}
*/
declare function get_current_InterfaceDeclaration_IWriteSummaryResponse():
    TypeOnly<current.IWriteSummaryResponse>;
declare function use_old_InterfaceDeclaration_IWriteSummaryResponse(
    use: TypeOnly<old.IWriteSummaryResponse>): void;
use_old_InterfaceDeclaration_IWriteSummaryResponse(
    get_current_InterfaceDeclaration_IWriteSummaryResponse());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_InternalErrorCode": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_InternalErrorCode():
    TypeOnly<old.InternalErrorCode>;
declare function use_current_EnumDeclaration_InternalErrorCode(
    use: TypeOnly<current.InternalErrorCode>): void;
use_current_EnumDeclaration_InternalErrorCode(
    get_old_EnumDeclaration_InternalErrorCode());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_InternalErrorCode": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_InternalErrorCode():
    TypeOnly<current.InternalErrorCode>;
declare function use_old_EnumDeclaration_InternalErrorCode(
    use: TypeOnly<old.InternalErrorCode>): void;
use_old_EnumDeclaration_InternalErrorCode(
    get_current_EnumDeclaration_InternalErrorCode());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_LatestSummaryId": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_LatestSummaryId():
    TypeOnly<typeof old.LatestSummaryId>;
declare function use_current_VariableDeclaration_LatestSummaryId(
    use: TypeOnly<typeof current.LatestSummaryId>): void;
use_current_VariableDeclaration_LatestSummaryId(
    get_old_VariableDeclaration_LatestSummaryId());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_LatestSummaryId": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_LatestSummaryId():
    TypeOnly<typeof current.LatestSummaryId>;
declare function use_old_VariableDeclaration_LatestSummaryId(
    use: TypeOnly<typeof old.LatestSummaryId>): void;
use_old_VariableDeclaration_LatestSummaryId(
    get_current_VariableDeclaration_LatestSummaryId());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_NetworkError": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_NetworkError():
    TypeOnly<old.NetworkError>;
declare function use_current_ClassDeclaration_NetworkError(
    use: TypeOnly<current.NetworkError>): void;
use_current_ClassDeclaration_NetworkError(
    get_old_ClassDeclaration_NetworkError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_NetworkError": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_NetworkError():
    TypeOnly<current.NetworkError>;
declare function use_old_ClassDeclaration_NetworkError(
    use: TypeOnly<old.NetworkError>): void;
use_old_ClassDeclaration_NetworkError(
    get_current_ClassDeclaration_NetworkError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_RestLessClient": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_RestLessClient():
    TypeOnly<old.RestLessClient>;
declare function use_current_ClassDeclaration_RestLessClient(
    use: TypeOnly<current.RestLessClient>): void;
use_current_ClassDeclaration_RestLessClient(
    get_old_ClassDeclaration_RestLessClient());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_RestLessClient": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_RestLessClient():
    TypeOnly<current.RestLessClient>;
declare function use_old_ClassDeclaration_RestLessClient(
    use: TypeOnly<old.RestLessClient>): void;
use_old_ClassDeclaration_RestLessClient(
    get_current_ClassDeclaration_RestLessClient());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_RestLessFieldNames": {"forwardCompat": false}
*/
declare function get_old_EnumDeclaration_RestLessFieldNames():
    TypeOnly<old.RestLessFieldNames>;
declare function use_current_EnumDeclaration_RestLessFieldNames(
    use: TypeOnly<current.RestLessFieldNames>): void;
use_current_EnumDeclaration_RestLessFieldNames(
    get_old_EnumDeclaration_RestLessFieldNames());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "EnumDeclaration_RestLessFieldNames": {"backCompat": false}
*/
declare function get_current_EnumDeclaration_RestLessFieldNames():
    TypeOnly<current.RestLessFieldNames>;
declare function use_old_EnumDeclaration_RestLessFieldNames(
    use: TypeOnly<old.RestLessFieldNames>): void;
use_old_EnumDeclaration_RestLessFieldNames(
    get_current_EnumDeclaration_RestLessFieldNames());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_RestWrapper": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_RestWrapper():
    TypeOnly<old.RestWrapper>;
declare function use_current_ClassDeclaration_RestWrapper(
    use: TypeOnly<current.RestWrapper>): void;
use_current_ClassDeclaration_RestWrapper(
    get_old_ClassDeclaration_RestWrapper());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_RestWrapper": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_RestWrapper():
    TypeOnly<current.RestWrapper>;
declare function use_old_ClassDeclaration_RestWrapper(
    use: TypeOnly<old.RestWrapper>): void;
use_old_ClassDeclaration_RestWrapper(
    get_current_ClassDeclaration_RestWrapper());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SummaryTreeUploadManager": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_SummaryTreeUploadManager():
    TypeOnly<old.SummaryTreeUploadManager>;
declare function use_current_ClassDeclaration_SummaryTreeUploadManager(
    use: TypeOnly<current.SummaryTreeUploadManager>): void;
use_current_ClassDeclaration_SummaryTreeUploadManager(
    get_old_ClassDeclaration_SummaryTreeUploadManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_SummaryTreeUploadManager": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_SummaryTreeUploadManager():
    TypeOnly<current.SummaryTreeUploadManager>;
declare function use_old_ClassDeclaration_SummaryTreeUploadManager(
    use: TypeOnly<old.SummaryTreeUploadManager>): void;
use_old_ClassDeclaration_SummaryTreeUploadManager(
    get_current_ClassDeclaration_SummaryTreeUploadManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_TokenRevokeScopeType": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_TokenRevokeScopeType():
    TypeOnly<typeof old.TokenRevokeScopeType>;
declare function use_current_VariableDeclaration_TokenRevokeScopeType(
    use: TypeOnly<typeof current.TokenRevokeScopeType>): void;
use_current_VariableDeclaration_TokenRevokeScopeType(
    get_old_VariableDeclaration_TokenRevokeScopeType());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_TokenRevokeScopeType": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_TokenRevokeScopeType():
    TypeOnly<typeof current.TokenRevokeScopeType>;
declare function use_old_VariableDeclaration_TokenRevokeScopeType(
    use: TypeOnly<typeof old.TokenRevokeScopeType>): void;
use_old_VariableDeclaration_TokenRevokeScopeType(
    get_current_VariableDeclaration_TokenRevokeScopeType());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_WholeSummaryTreeEntry": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_WholeSummaryTreeEntry():
    TypeOnly<old.WholeSummaryTreeEntry>;
declare function use_current_TypeAliasDeclaration_WholeSummaryTreeEntry(
    use: TypeOnly<current.WholeSummaryTreeEntry>): void;
use_current_TypeAliasDeclaration_WholeSummaryTreeEntry(
    get_old_TypeAliasDeclaration_WholeSummaryTreeEntry());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_WholeSummaryTreeEntry": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_WholeSummaryTreeEntry():
    TypeOnly<current.WholeSummaryTreeEntry>;
declare function use_old_TypeAliasDeclaration_WholeSummaryTreeEntry(
    use: TypeOnly<old.WholeSummaryTreeEntry>): void;
use_old_TypeAliasDeclaration_WholeSummaryTreeEntry(
    get_current_TypeAliasDeclaration_WholeSummaryTreeEntry());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_WholeSummaryTreeValue": {"forwardCompat": false}
*/
declare function get_old_TypeAliasDeclaration_WholeSummaryTreeValue():
    TypeOnly<old.WholeSummaryTreeValue>;
declare function use_current_TypeAliasDeclaration_WholeSummaryTreeValue(
    use: TypeOnly<current.WholeSummaryTreeValue>): void;
use_current_TypeAliasDeclaration_WholeSummaryTreeValue(
    get_old_TypeAliasDeclaration_WholeSummaryTreeValue());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "TypeAliasDeclaration_WholeSummaryTreeValue": {"backCompat": false}
*/
declare function get_current_TypeAliasDeclaration_WholeSummaryTreeValue():
    TypeOnly<current.WholeSummaryTreeValue>;
declare function use_old_TypeAliasDeclaration_WholeSummaryTreeValue(
    use: TypeOnly<old.WholeSummaryTreeValue>): void;
use_old_TypeAliasDeclaration_WholeSummaryTreeValue(
    get_current_TypeAliasDeclaration_WholeSummaryTreeValue());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_WholeSummaryUploadManager": {"forwardCompat": false}
*/
declare function get_old_ClassDeclaration_WholeSummaryUploadManager():
    TypeOnly<old.WholeSummaryUploadManager>;
declare function use_current_ClassDeclaration_WholeSummaryUploadManager(
    use: TypeOnly<current.WholeSummaryUploadManager>): void;
use_current_ClassDeclaration_WholeSummaryUploadManager(
    get_old_ClassDeclaration_WholeSummaryUploadManager());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "ClassDeclaration_WholeSummaryUploadManager": {"backCompat": false}
*/
declare function get_current_ClassDeclaration_WholeSummaryUploadManager():
    TypeOnly<current.WholeSummaryUploadManager>;
declare function use_old_ClassDeclaration_WholeSummaryUploadManager(
    use: TypeOnly<old.WholeSummaryUploadManager>): void;
use_old_ClassDeclaration_WholeSummaryUploadManager(
    get_current_ClassDeclaration_WholeSummaryUploadManager());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_buildTreePath": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_buildTreePath():
    TypeOnly<typeof old.buildTreePath>;
declare function use_current_VariableDeclaration_buildTreePath(
    use: TypeOnly<typeof current.buildTreePath>): void;
use_current_VariableDeclaration_buildTreePath(
    get_old_VariableDeclaration_buildTreePath());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_buildTreePath": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_buildTreePath():
    TypeOnly<typeof current.buildTreePath>;
declare function use_old_VariableDeclaration_buildTreePath(
    use: TypeOnly<typeof old.buildTreePath>): void;
use_old_VariableDeclaration_buildTreePath(
    get_current_VariableDeclaration_buildTreePath());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_canDeleteDoc": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_canDeleteDoc():
    TypeOnly<typeof old.canDeleteDoc>;
declare function use_current_VariableDeclaration_canDeleteDoc(
    use: TypeOnly<typeof current.canDeleteDoc>): void;
use_current_VariableDeclaration_canDeleteDoc(
    get_old_VariableDeclaration_canDeleteDoc());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_canDeleteDoc": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_canDeleteDoc():
    TypeOnly<typeof current.canDeleteDoc>;
declare function use_old_VariableDeclaration_canDeleteDoc(
    use: TypeOnly<typeof old.canDeleteDoc>): void;
use_old_VariableDeclaration_canDeleteDoc(
    get_current_VariableDeclaration_canDeleteDoc());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_canRead": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_canRead():
    TypeOnly<typeof old.canRead>;
declare function use_current_VariableDeclaration_canRead(
    use: TypeOnly<typeof current.canRead>): void;
use_current_VariableDeclaration_canRead(
    get_old_VariableDeclaration_canRead());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_canRead": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_canRead():
    TypeOnly<typeof current.canRead>;
declare function use_old_VariableDeclaration_canRead(
    use: TypeOnly<typeof old.canRead>): void;
use_old_VariableDeclaration_canRead(
    get_current_VariableDeclaration_canRead());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_canRevokeToken": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_canRevokeToken():
    TypeOnly<typeof old.canRevokeToken>;
declare function use_current_VariableDeclaration_canRevokeToken(
    use: TypeOnly<typeof current.canRevokeToken>): void;
use_current_VariableDeclaration_canRevokeToken(
    get_old_VariableDeclaration_canRevokeToken());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_canRevokeToken": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_canRevokeToken():
    TypeOnly<typeof current.canRevokeToken>;
declare function use_old_VariableDeclaration_canRevokeToken(
    use: TypeOnly<typeof old.canRevokeToken>): void;
use_old_VariableDeclaration_canRevokeToken(
    get_current_VariableDeclaration_canRevokeToken());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_canSummarize": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_canSummarize():
    TypeOnly<typeof old.canSummarize>;
declare function use_current_VariableDeclaration_canSummarize(
    use: TypeOnly<typeof current.canSummarize>): void;
use_current_VariableDeclaration_canSummarize(
    get_old_VariableDeclaration_canSummarize());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_canSummarize": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_canSummarize():
    TypeOnly<typeof current.canSummarize>;
declare function use_old_VariableDeclaration_canSummarize(
    use: TypeOnly<typeof old.canSummarize>): void;
use_old_VariableDeclaration_canSummarize(
    get_current_VariableDeclaration_canSummarize());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_canWrite": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_canWrite():
    TypeOnly<typeof old.canWrite>;
declare function use_current_VariableDeclaration_canWrite(
    use: TypeOnly<typeof current.canWrite>): void;
use_current_VariableDeclaration_canWrite(
    get_old_VariableDeclaration_canWrite());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_canWrite": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_canWrite():
    TypeOnly<typeof current.canWrite>;
declare function use_old_VariableDeclaration_canWrite(
    use: TypeOnly<typeof old.canWrite>): void;
use_old_VariableDeclaration_canWrite(
    get_current_VariableDeclaration_canWrite());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_choose": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_choose():
    TypeOnly<typeof old.choose>;
declare function use_current_VariableDeclaration_choose(
    use: TypeOnly<typeof current.choose>): void;
use_current_VariableDeclaration_choose(
    get_old_VariableDeclaration_choose());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_choose": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_choose():
    TypeOnly<typeof current.choose>;
declare function use_old_VariableDeclaration_choose(
    use: TypeOnly<typeof old.choose>): void;
use_old_VariableDeclaration_choose(
    get_current_VariableDeclaration_choose());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_convertFirstSummaryWholeSummaryTreeToSummaryTree": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_convertFirstSummaryWholeSummaryTreeToSummaryTree():
    TypeOnly<typeof old.convertFirstSummaryWholeSummaryTreeToSummaryTree>;
declare function use_current_FunctionDeclaration_convertFirstSummaryWholeSummaryTreeToSummaryTree(
    use: TypeOnly<typeof current.convertFirstSummaryWholeSummaryTreeToSummaryTree>): void;
use_current_FunctionDeclaration_convertFirstSummaryWholeSummaryTreeToSummaryTree(
    get_old_FunctionDeclaration_convertFirstSummaryWholeSummaryTreeToSummaryTree());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_convertFirstSummaryWholeSummaryTreeToSummaryTree": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_convertFirstSummaryWholeSummaryTreeToSummaryTree():
    TypeOnly<typeof current.convertFirstSummaryWholeSummaryTreeToSummaryTree>;
declare function use_old_FunctionDeclaration_convertFirstSummaryWholeSummaryTreeToSummaryTree(
    use: TypeOnly<typeof old.convertFirstSummaryWholeSummaryTreeToSummaryTree>): void;
use_old_FunctionDeclaration_convertFirstSummaryWholeSummaryTreeToSummaryTree(
    get_current_FunctionDeclaration_convertFirstSummaryWholeSummaryTreeToSummaryTree());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_convertSortedNumberArrayToRanges": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_convertSortedNumberArrayToRanges():
    TypeOnly<typeof old.convertSortedNumberArrayToRanges>;
declare function use_current_FunctionDeclaration_convertSortedNumberArrayToRanges(
    use: TypeOnly<typeof current.convertSortedNumberArrayToRanges>): void;
use_current_FunctionDeclaration_convertSortedNumberArrayToRanges(
    get_old_FunctionDeclaration_convertSortedNumberArrayToRanges());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_convertSortedNumberArrayToRanges": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_convertSortedNumberArrayToRanges():
    TypeOnly<typeof current.convertSortedNumberArrayToRanges>;
declare function use_old_FunctionDeclaration_convertSortedNumberArrayToRanges(
    use: TypeOnly<typeof old.convertSortedNumberArrayToRanges>): void;
use_old_FunctionDeclaration_convertSortedNumberArrayToRanges(
    get_current_FunctionDeclaration_convertSortedNumberArrayToRanges());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_convertSummaryTreeToWholeSummaryTree": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_convertSummaryTreeToWholeSummaryTree():
    TypeOnly<typeof old.convertSummaryTreeToWholeSummaryTree>;
declare function use_current_FunctionDeclaration_convertSummaryTreeToWholeSummaryTree(
    use: TypeOnly<typeof current.convertSummaryTreeToWholeSummaryTree>): void;
use_current_FunctionDeclaration_convertSummaryTreeToWholeSummaryTree(
    get_old_FunctionDeclaration_convertSummaryTreeToWholeSummaryTree());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_convertSummaryTreeToWholeSummaryTree": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_convertSummaryTreeToWholeSummaryTree():
    TypeOnly<typeof current.convertSummaryTreeToWholeSummaryTree>;
declare function use_old_FunctionDeclaration_convertSummaryTreeToWholeSummaryTree(
    use: TypeOnly<typeof old.convertSummaryTreeToWholeSummaryTree>): void;
use_old_FunctionDeclaration_convertSummaryTreeToWholeSummaryTree(
    get_current_FunctionDeclaration_convertSummaryTreeToWholeSummaryTree());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_convertWholeFlatSummaryToSnapshotTreeAndBlobs": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_convertWholeFlatSummaryToSnapshotTreeAndBlobs():
    TypeOnly<typeof old.convertWholeFlatSummaryToSnapshotTreeAndBlobs>;
declare function use_current_FunctionDeclaration_convertWholeFlatSummaryToSnapshotTreeAndBlobs(
    use: TypeOnly<typeof current.convertWholeFlatSummaryToSnapshotTreeAndBlobs>): void;
use_current_FunctionDeclaration_convertWholeFlatSummaryToSnapshotTreeAndBlobs(
    get_old_FunctionDeclaration_convertWholeFlatSummaryToSnapshotTreeAndBlobs());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_convertWholeFlatSummaryToSnapshotTreeAndBlobs": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_convertWholeFlatSummaryToSnapshotTreeAndBlobs():
    TypeOnly<typeof current.convertWholeFlatSummaryToSnapshotTreeAndBlobs>;
declare function use_old_FunctionDeclaration_convertWholeFlatSummaryToSnapshotTreeAndBlobs(
    use: TypeOnly<typeof old.convertWholeFlatSummaryToSnapshotTreeAndBlobs>): void;
use_old_FunctionDeclaration_convertWholeFlatSummaryToSnapshotTreeAndBlobs(
    get_current_FunctionDeclaration_convertWholeFlatSummaryToSnapshotTreeAndBlobs());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createFluidServiceNetworkError": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_createFluidServiceNetworkError():
    TypeOnly<typeof old.createFluidServiceNetworkError>;
declare function use_current_FunctionDeclaration_createFluidServiceNetworkError(
    use: TypeOnly<typeof current.createFluidServiceNetworkError>): void;
use_current_FunctionDeclaration_createFluidServiceNetworkError(
    get_old_FunctionDeclaration_createFluidServiceNetworkError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_createFluidServiceNetworkError": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_createFluidServiceNetworkError():
    TypeOnly<typeof current.createFluidServiceNetworkError>;
declare function use_old_FunctionDeclaration_createFluidServiceNetworkError(
    use: TypeOnly<typeof old.createFluidServiceNetworkError>): void;
use_old_FunctionDeclaration_createFluidServiceNetworkError(
    get_current_FunctionDeclaration_createFluidServiceNetworkError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_dedupeSortedArray": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_dedupeSortedArray():
    TypeOnly<typeof old.dedupeSortedArray>;
declare function use_current_FunctionDeclaration_dedupeSortedArray(
    use: TypeOnly<typeof current.dedupeSortedArray>): void;
use_current_FunctionDeclaration_dedupeSortedArray(
    get_old_FunctionDeclaration_dedupeSortedArray());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_dedupeSortedArray": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_dedupeSortedArray():
    TypeOnly<typeof current.dedupeSortedArray>;
declare function use_old_FunctionDeclaration_dedupeSortedArray(
    use: TypeOnly<typeof old.dedupeSortedArray>): void;
use_old_FunctionDeclaration_dedupeSortedArray(
    get_current_FunctionDeclaration_dedupeSortedArray());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_defaultHash": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_defaultHash():
    TypeOnly<typeof old.defaultHash>;
declare function use_current_VariableDeclaration_defaultHash(
    use: TypeOnly<typeof current.defaultHash>): void;
use_current_VariableDeclaration_defaultHash(
    get_old_VariableDeclaration_defaultHash());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_defaultHash": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_defaultHash():
    TypeOnly<typeof current.defaultHash>;
declare function use_old_VariableDeclaration_defaultHash(
    use: TypeOnly<typeof old.defaultHash>): void;
use_old_VariableDeclaration_defaultHash(
    get_current_VariableDeclaration_defaultHash());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateServiceProtocolEntries": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_generateServiceProtocolEntries():
    TypeOnly<typeof old.generateServiceProtocolEntries>;
declare function use_current_FunctionDeclaration_generateServiceProtocolEntries(
    use: TypeOnly<typeof current.generateServiceProtocolEntries>): void;
use_current_FunctionDeclaration_generateServiceProtocolEntries(
    get_old_FunctionDeclaration_generateServiceProtocolEntries());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateServiceProtocolEntries": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_generateServiceProtocolEntries():
    TypeOnly<typeof current.generateServiceProtocolEntries>;
declare function use_old_FunctionDeclaration_generateServiceProtocolEntries(
    use: TypeOnly<typeof old.generateServiceProtocolEntries>): void;
use_old_FunctionDeclaration_generateServiceProtocolEntries(
    get_current_FunctionDeclaration_generateServiceProtocolEntries());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateToken": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_generateToken():
    TypeOnly<typeof old.generateToken>;
declare function use_current_FunctionDeclaration_generateToken(
    use: TypeOnly<typeof current.generateToken>): void;
use_current_FunctionDeclaration_generateToken(
    get_old_FunctionDeclaration_generateToken());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateToken": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_generateToken():
    TypeOnly<typeof current.generateToken>;
declare function use_old_FunctionDeclaration_generateToken(
    use: TypeOnly<typeof old.generateToken>): void;
use_old_FunctionDeclaration_generateToken(
    get_current_FunctionDeclaration_generateToken());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateUser": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_generateUser():
    TypeOnly<typeof old.generateUser>;
declare function use_current_FunctionDeclaration_generateUser(
    use: TypeOnly<typeof current.generateUser>): void;
use_current_FunctionDeclaration_generateUser(
    get_old_FunctionDeclaration_generateUser());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_generateUser": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_generateUser():
    TypeOnly<typeof current.generateUser>;
declare function use_old_FunctionDeclaration_generateUser(
    use: TypeOnly<typeof old.generateUser>): void;
use_old_FunctionDeclaration_generateUser(
    get_current_FunctionDeclaration_generateUser());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getAuthorizationTokenFromCredentials": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_getAuthorizationTokenFromCredentials():
    TypeOnly<typeof old.getAuthorizationTokenFromCredentials>;
declare function use_current_VariableDeclaration_getAuthorizationTokenFromCredentials(
    use: TypeOnly<typeof current.getAuthorizationTokenFromCredentials>): void;
use_current_VariableDeclaration_getAuthorizationTokenFromCredentials(
    get_old_VariableDeclaration_getAuthorizationTokenFromCredentials());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getAuthorizationTokenFromCredentials": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_getAuthorizationTokenFromCredentials():
    TypeOnly<typeof current.getAuthorizationTokenFromCredentials>;
declare function use_old_VariableDeclaration_getAuthorizationTokenFromCredentials(
    use: TypeOnly<typeof old.getAuthorizationTokenFromCredentials>): void;
use_old_VariableDeclaration_getAuthorizationTokenFromCredentials(
    get_current_VariableDeclaration_getAuthorizationTokenFromCredentials());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getGlobalTimeoutContext": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_getGlobalTimeoutContext():
    TypeOnly<typeof old.getGlobalTimeoutContext>;
declare function use_current_VariableDeclaration_getGlobalTimeoutContext(
    use: TypeOnly<typeof current.getGlobalTimeoutContext>): void;
use_current_VariableDeclaration_getGlobalTimeoutContext(
    get_old_VariableDeclaration_getGlobalTimeoutContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getGlobalTimeoutContext": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_getGlobalTimeoutContext():
    TypeOnly<typeof current.getGlobalTimeoutContext>;
declare function use_old_VariableDeclaration_getGlobalTimeoutContext(
    use: TypeOnly<typeof old.getGlobalTimeoutContext>): void;
use_old_VariableDeclaration_getGlobalTimeoutContext(
    get_current_VariableDeclaration_getGlobalTimeoutContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getNextHash": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getNextHash():
    TypeOnly<typeof old.getNextHash>;
declare function use_current_FunctionDeclaration_getNextHash(
    use: TypeOnly<typeof current.getNextHash>): void;
use_current_FunctionDeclaration_getNextHash(
    get_old_FunctionDeclaration_getNextHash());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getNextHash": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getNextHash():
    TypeOnly<typeof current.getNextHash>;
declare function use_old_FunctionDeclaration_getNextHash(
    use: TypeOnly<typeof old.getNextHash>): void;
use_old_FunctionDeclaration_getNextHash(
    get_current_FunctionDeclaration_getNextHash());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getOrCreateRepository": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getOrCreateRepository():
    TypeOnly<typeof old.getOrCreateRepository>;
declare function use_current_FunctionDeclaration_getOrCreateRepository(
    use: TypeOnly<typeof current.getOrCreateRepository>): void;
use_current_FunctionDeclaration_getOrCreateRepository(
    get_old_FunctionDeclaration_getOrCreateRepository());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getOrCreateRepository": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getOrCreateRepository():
    TypeOnly<typeof current.getOrCreateRepository>;
declare function use_old_FunctionDeclaration_getOrCreateRepository(
    use: TypeOnly<typeof old.getOrCreateRepository>): void;
use_old_FunctionDeclaration_getOrCreateRepository(
    get_current_FunctionDeclaration_getOrCreateRepository());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getQuorumTreeEntries": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getQuorumTreeEntries():
    TypeOnly<typeof old.getQuorumTreeEntries>;
declare function use_current_FunctionDeclaration_getQuorumTreeEntries(
    use: TypeOnly<typeof current.getQuorumTreeEntries>): void;
use_current_FunctionDeclaration_getQuorumTreeEntries(
    get_old_FunctionDeclaration_getQuorumTreeEntries());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getQuorumTreeEntries": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getQuorumTreeEntries():
    TypeOnly<typeof current.getQuorumTreeEntries>;
declare function use_old_FunctionDeclaration_getQuorumTreeEntries(
    use: TypeOnly<typeof old.getQuorumTreeEntries>): void;
use_old_FunctionDeclaration_getQuorumTreeEntries(
    get_current_FunctionDeclaration_getQuorumTreeEntries());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getRandomInt": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_getRandomInt():
    TypeOnly<typeof old.getRandomInt>;
declare function use_current_VariableDeclaration_getRandomInt(
    use: TypeOnly<typeof current.getRandomInt>): void;
use_current_VariableDeclaration_getRandomInt(
    get_old_VariableDeclaration_getRandomInt());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_getRandomInt": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_getRandomInt():
    TypeOnly<typeof current.getRandomInt>;
declare function use_old_VariableDeclaration_getRandomInt(
    use: TypeOnly<typeof old.getRandomInt>): void;
use_old_VariableDeclaration_getRandomInt(
    get_current_VariableDeclaration_getRandomInt());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getRandomName": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_getRandomName():
    TypeOnly<typeof old.getRandomName>;
declare function use_current_FunctionDeclaration_getRandomName(
    use: TypeOnly<typeof current.getRandomName>): void;
use_current_FunctionDeclaration_getRandomName(
    get_old_FunctionDeclaration_getRandomName());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_getRandomName": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_getRandomName():
    TypeOnly<typeof current.getRandomName>;
declare function use_old_FunctionDeclaration_getRandomName(
    use: TypeOnly<typeof old.getRandomName>): void;
use_old_FunctionDeclaration_getRandomName(
    get_current_FunctionDeclaration_getRandomName());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isNetworkError": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_isNetworkError():
    TypeOnly<typeof old.isNetworkError>;
declare function use_current_FunctionDeclaration_isNetworkError(
    use: TypeOnly<typeof current.isNetworkError>): void;
use_current_FunctionDeclaration_isNetworkError(
    get_old_FunctionDeclaration_isNetworkError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_isNetworkError": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_isNetworkError():
    TypeOnly<typeof current.isNetworkError>;
declare function use_old_FunctionDeclaration_isNetworkError(
    use: TypeOnly<typeof old.isNetworkError>): void;
use_old_FunctionDeclaration_isNetworkError(
    get_current_FunctionDeclaration_isNetworkError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_mergeAppAndProtocolTree": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_mergeAppAndProtocolTree():
    TypeOnly<typeof old.mergeAppAndProtocolTree>;
declare function use_current_FunctionDeclaration_mergeAppAndProtocolTree(
    use: TypeOnly<typeof current.mergeAppAndProtocolTree>): void;
use_current_FunctionDeclaration_mergeAppAndProtocolTree(
    get_old_FunctionDeclaration_mergeAppAndProtocolTree());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_mergeAppAndProtocolTree": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_mergeAppAndProtocolTree():
    TypeOnly<typeof current.mergeAppAndProtocolTree>;
declare function use_old_FunctionDeclaration_mergeAppAndProtocolTree(
    use: TypeOnly<typeof old.mergeAppAndProtocolTree>): void;
use_old_FunctionDeclaration_mergeAppAndProtocolTree(
    get_current_FunctionDeclaration_mergeAppAndProtocolTree());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_mergeKArrays": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_mergeKArrays():
    TypeOnly<typeof old.mergeKArrays>;
declare function use_current_FunctionDeclaration_mergeKArrays(
    use: TypeOnly<typeof current.mergeKArrays>): void;
use_current_FunctionDeclaration_mergeKArrays(
    get_old_FunctionDeclaration_mergeKArrays());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_mergeKArrays": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_mergeKArrays():
    TypeOnly<typeof current.mergeKArrays>;
declare function use_old_FunctionDeclaration_mergeKArrays(
    use: TypeOnly<typeof old.mergeKArrays>): void;
use_old_FunctionDeclaration_mergeKArrays(
    get_current_FunctionDeclaration_mergeKArrays());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_mergeSortedArrays": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_mergeSortedArrays():
    TypeOnly<typeof old.mergeSortedArrays>;
declare function use_current_FunctionDeclaration_mergeSortedArrays(
    use: TypeOnly<typeof current.mergeSortedArrays>): void;
use_current_FunctionDeclaration_mergeSortedArrays(
    get_old_FunctionDeclaration_mergeSortedArrays());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_mergeSortedArrays": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_mergeSortedArrays():
    TypeOnly<typeof current.mergeSortedArrays>;
declare function use_old_FunctionDeclaration_mergeSortedArrays(
    use: TypeOnly<typeof old.mergeSortedArrays>): void;
use_old_FunctionDeclaration_mergeSortedArrays(
    get_current_FunctionDeclaration_mergeSortedArrays());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_promiseTimeout": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_promiseTimeout():
    TypeOnly<typeof old.promiseTimeout>;
declare function use_current_FunctionDeclaration_promiseTimeout(
    use: TypeOnly<typeof current.promiseTimeout>): void;
use_current_FunctionDeclaration_promiseTimeout(
    get_old_FunctionDeclaration_promiseTimeout());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_promiseTimeout": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_promiseTimeout():
    TypeOnly<typeof current.promiseTimeout>;
declare function use_old_FunctionDeclaration_promiseTimeout(
    use: TypeOnly<typeof old.promiseTimeout>): void;
use_old_FunctionDeclaration_promiseTimeout(
    get_current_FunctionDeclaration_promiseTimeout());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_setGlobalTimeoutContext": {"forwardCompat": false}
*/
declare function get_old_VariableDeclaration_setGlobalTimeoutContext():
    TypeOnly<typeof old.setGlobalTimeoutContext>;
declare function use_current_VariableDeclaration_setGlobalTimeoutContext(
    use: TypeOnly<typeof current.setGlobalTimeoutContext>): void;
use_current_VariableDeclaration_setGlobalTimeoutContext(
    get_old_VariableDeclaration_setGlobalTimeoutContext());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "VariableDeclaration_setGlobalTimeoutContext": {"backCompat": false}
*/
declare function get_current_VariableDeclaration_setGlobalTimeoutContext():
    TypeOnly<typeof current.setGlobalTimeoutContext>;
declare function use_old_VariableDeclaration_setGlobalTimeoutContext(
    use: TypeOnly<typeof old.setGlobalTimeoutContext>): void;
use_old_VariableDeclaration_setGlobalTimeoutContext(
    get_current_VariableDeclaration_setGlobalTimeoutContext());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_throwFluidServiceNetworkError": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_throwFluidServiceNetworkError():
    TypeOnly<typeof old.throwFluidServiceNetworkError>;
declare function use_current_FunctionDeclaration_throwFluidServiceNetworkError(
    use: TypeOnly<typeof current.throwFluidServiceNetworkError>): void;
use_current_FunctionDeclaration_throwFluidServiceNetworkError(
    get_old_FunctionDeclaration_throwFluidServiceNetworkError());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_throwFluidServiceNetworkError": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_throwFluidServiceNetworkError():
    TypeOnly<typeof current.throwFluidServiceNetworkError>;
declare function use_old_FunctionDeclaration_throwFluidServiceNetworkError(
    use: TypeOnly<typeof old.throwFluidServiceNetworkError>): void;
use_old_FunctionDeclaration_throwFluidServiceNetworkError(
    get_current_FunctionDeclaration_throwFluidServiceNetworkError());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_validateTokenClaims": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_validateTokenClaims():
    TypeOnly<typeof old.validateTokenClaims>;
declare function use_current_FunctionDeclaration_validateTokenClaims(
    use: TypeOnly<typeof current.validateTokenClaims>): void;
use_current_FunctionDeclaration_validateTokenClaims(
    get_old_FunctionDeclaration_validateTokenClaims());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_validateTokenClaims": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_validateTokenClaims():
    TypeOnly<typeof current.validateTokenClaims>;
declare function use_old_FunctionDeclaration_validateTokenClaims(
    use: TypeOnly<typeof old.validateTokenClaims>): void;
use_old_FunctionDeclaration_validateTokenClaims(
    get_current_FunctionDeclaration_validateTokenClaims());

/*
* Validate forward compat by using old type in place of current type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_validateTokenClaimsExpiration": {"forwardCompat": false}
*/
declare function get_old_FunctionDeclaration_validateTokenClaimsExpiration():
    TypeOnly<typeof old.validateTokenClaimsExpiration>;
declare function use_current_FunctionDeclaration_validateTokenClaimsExpiration(
    use: TypeOnly<typeof current.validateTokenClaimsExpiration>): void;
use_current_FunctionDeclaration_validateTokenClaimsExpiration(
    get_old_FunctionDeclaration_validateTokenClaimsExpiration());

/*
* Validate back compat by using current type in place of old type
* If breaking change required, add in package.json under typeValidation.broken:
* "FunctionDeclaration_validateTokenClaimsExpiration": {"backCompat": false}
*/
declare function get_current_FunctionDeclaration_validateTokenClaimsExpiration():
    TypeOnly<typeof current.validateTokenClaimsExpiration>;
declare function use_old_FunctionDeclaration_validateTokenClaimsExpiration(
    use: TypeOnly<typeof old.validateTokenClaimsExpiration>): void;
use_old_FunctionDeclaration_validateTokenClaimsExpiration(
    get_current_FunctionDeclaration_validateTokenClaimsExpiration());
