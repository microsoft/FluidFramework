## API Report File for "@fluidframework/protocol-base"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { EventForwarder } from '@fluidframework/common-utils';
import * as git from '@fluidframework/gitresources';
import { IAttachment } from '@fluidframework/protocol-definitions';
import { IBlob } from '@fluidframework/protocol-definitions';
import { ICommittedProposal } from '@fluidframework/protocol-definitions';
import { ICreateTreeEntry } from '@fluidframework/gitresources';
import { IProcessMessageResult } from '@fluidframework/protocol-definitions';
import { IQuorum } from '@fluidframework/protocol-definitions';
import { IQuorumEvents } from '@fluidframework/protocol-definitions';
import { ISequencedClient } from '@fluidframework/protocol-definitions';
import { ISequencedDocumentMessage } from '@fluidframework/protocol-definitions';
import { ISequencedProposal } from '@fluidframework/protocol-definitions';
import { ISnapshotTreeEx } from '@fluidframework/protocol-definitions';
import { ITree } from '@fluidframework/protocol-definitions';
import { ITree as ITree_2 } from '@fluidframework/gitresources';
import { ITreeEntry } from '@fluidframework/protocol-definitions';
import { SummaryObject } from '@fluidframework/protocol-definitions';
import { TypedEventEmitter } from '@fluidframework/common-utils';

// @public (undocumented)
export function addBlobToTree(tree: ITree, blobName: string, content: object): void;

// @public
export class AttachmentTreeEntry {
    constructor(path: string, id: string);
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly mode = FileMode.File;
    // (undocumented)
    readonly path: string;
    // (undocumented)
    readonly type = TreeEntry.Attachment;
    // (undocumented)
    readonly value: IAttachment;
}

// @public
export class BlobTreeEntry {
    constructor(path: string, contents: string, encoding?: string);
    // (undocumented)
    readonly mode = FileMode.File;
    // (undocumented)
    readonly path: string;
    // (undocumented)
    readonly type = TreeEntry.Blob;
    // (undocumented)
    readonly value: IBlob;
}

// @public
export function buildHierarchy(flatTree: git.ITree, blobsShaToPathCache?: Map<string, string>): ISnapshotTreeEx;

// @public
export class CommitTreeEntry {
    constructor(path: string, value: string);
    // (undocumented)
    readonly mode = FileMode.Commit;
    // (undocumented)
    readonly path: string;
    // (undocumented)
    readonly type = TreeEntry.Commit;
    // (undocumented)
    readonly value: string;
}

// @public (undocumented)
export function generateServiceProtocolEntries(deli: string, scribe: string): ITreeEntry[];

// @public
export function getGitMode(value: SummaryObject): string;

// @public
export function getGitType(value: SummaryObject): "blob" | "tree";

// @public (undocumented)
export function getQuorumTreeEntries(documentId: string, minimumSequenceNumber: number, sequenceNumber: number, term: number, quorumSnapshot: IQuorumSnapshot): ITreeEntry[];

// @public (undocumented)
export interface IQuorumSnapshot {
    // (undocumented)
    members: [string, ISequencedClient][];
    // (undocumented)
    proposals: [number, ISequencedProposal, string[]][];
    // (undocumented)
    values: [string, ICommittedProposal][];
}

// @public (undocumented)
export interface IScribeProtocolState {
    // (undocumented)
    members: [string, ISequencedClient][];
    // (undocumented)
    minimumSequenceNumber: number;
    // (undocumented)
    proposals: [number, ISequencedProposal, string[]][];
    // (undocumented)
    sequenceNumber: number;
    // (undocumented)
    values: [string, ICommittedProposal][];
}

// @public
export const isServiceMessageType: (type: string) => boolean;

// @public (undocumented)
export function isSystemMessage(message: ISequencedDocumentMessage): boolean;

// @public (undocumented)
export function mergeAppAndProtocolTree(appSummaryTree: ITree_2, protocolTree: ITree_2): ICreateTreeEntry[];

// @public
export class ProtocolOpHandler {
    constructor(minimumSequenceNumber: number, sequenceNumber: number, term: number | undefined, members: [string, ISequencedClient][], proposals: [number, ISequencedProposal, string[]][], values: [string, ICommittedProposal][], sendProposal: (key: string, value: any) => number, sendReject: (sequenceNumber: number) => void);
    // (undocumented)
    close(): void;
    getProtocolState(): IScribeProtocolState;
    // (undocumented)
    minimumSequenceNumber: number;
    // (undocumented)
    processMessage(message: ISequencedDocumentMessage, local: boolean): IProcessMessageResult;
    // (undocumented)
    readonly quorum: Quorum;
    // (undocumented)
    sequenceNumber: number;
    // (undocumented)
    readonly term: number;
}

// @public
export class Quorum extends TypedEventEmitter<IQuorumEvents> implements IQuorum {
    constructor(members: [string, ISequencedClient][], proposals: [number, ISequencedProposal, string[]][], values: [string, ICommittedProposal][], sendProposal: (key: string, value: any) => number, sendReject: (sequenceNumber: number) => void);
    addMember(clientId: string, details: ISequencedClient): void;
    addProposal(key: string, value: any, sequenceNumber: number, local: boolean, clientSequenceNumber: number): void;
    // (undocumented)
    close(): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    get disposed(): boolean;
    get(key: string): any;
    getApprovalData(key: string): ICommittedProposal | undefined;
    getMember(clientId: string): ISequencedClient | undefined;
    getMembers(): Map<string, ISequencedClient>;
    has(key: string): boolean;
    propose(key: string, value: any): Promise<void>;
    rejectProposal(clientId: string, sequenceNumber: number): void;
    removeMember(clientId: string): void;
    // (undocumented)
    setConnectionState(connected: boolean, clientId?: string): void;
    snapshot(): IQuorumSnapshot;
    snapshotMembers(): IQuorumSnapshot["members"];
    snapshotProposals(): IQuorumSnapshot["proposals"];
    snapshotValues(): IQuorumSnapshot["values"];
    updateMinimumSequenceNumber(message: ISequencedDocumentMessage): boolean;
    }

// @public
export class QuorumProxy extends EventForwarder<IQuorumEvents> implements IQuorum {
    constructor(quorum: IQuorum);
    // (undocumented)
    readonly get: (key: string) => any;
    // (undocumented)
    readonly getApprovalData: (key: string) => ICommittedProposal | undefined;
    // (undocumented)
    readonly getMember: (clientId: string) => ISequencedClient | undefined;
    // (undocumented)
    readonly getMembers: () => Map<string, ISequencedClient>;
    // (undocumented)
    readonly has: (key: string) => boolean;
    // (undocumented)
    readonly propose: (key: string, value: any) => Promise<void>;
}

// @public
export class TreeTreeEntry {
    constructor(path: string, value: ITree);
    // (undocumented)
    readonly mode = FileMode.Directory;
    // (undocumented)
    readonly path: string;
    // (undocumented)
    readonly type = TreeEntry.Tree;
    // (undocumented)
    readonly value: ITree;
}


// (No @packageDocumentation comment for this package)

```
