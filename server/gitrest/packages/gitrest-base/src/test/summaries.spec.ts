/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import assert from "assert";
import { v4 as uuid } from "uuid";
import { ISummaryTestMode } from "./utils";
import { GitWholeSummaryManager, IsomorphicGitManagerFactory, MemFsManagerFactory } from "../utils";
import { NullExternalStorageManager } from "../externalStorageManager";
import {
	sampleChannelSummaryUpload,
	sampleContainerSummaryUpload,
	sampleContainerSummaryResponse,
	sampleInitialSummaryResponse,
	sampleInitialSummaryUpload,
	sampleChannelSummaryResult,
} from "./examples";
import { IWholeFlatSummary, LatestSummaryId } from "@fluidframework/server-services-client";

// Github Copilot wizardry.
function permuteFlags(obj: Record<string, boolean>): Record<string, boolean>[] {
	const keys = Object.keys(obj);
	const permutations: Record<string, boolean>[] = [];
	for (let i = 0; i < Math.pow(2, keys.length); i++) {
		const permutation: Record<string, boolean> = {};
		for (let j = 0; j < keys.length; j++) {
			permutation[keys[j]] = (i & (1 << j)) !== 0;
		}
		permutations.push(permutation);
	}
	return permutations;
}

function assertEqualSummaries(
	actual: IWholeFlatSummary,
	expected: IWholeFlatSummary,
	message?: string | Error,
) {
	// We cannot compare the container sha because it is generated by a commit which takes timestamp into account.
	// We also cannot compare the root tree sha because low-io write alters how the root tree is stored.
	assert.strictEqual(
		JSON.stringify(
			{
				...actual,
				id: "test-commit-sha",
				trees: [{ ...actual.trees[0], id: "test-tree-sha" }],
			},
			null,
			2,
		),
		JSON.stringify(
			{
				...expected,
				id: "test-commit-sha",
				trees: [{ ...expected.trees[0], id: "test-tree-sha" }],
			},
			null,
			2,
		),
		message,
	);
}

const testModes = permuteFlags({
	repoPerDocEnabled: false,
	enableLowIoWrite: false,
	enableOptimizedInitialSummary: false,
	enableSlimGitInit: false,
}) as unknown as ISummaryTestMode[];

testModes.forEach((testMode) => {
	describe(`Summaries (${JSON.stringify(testMode)})`, () => {
		const memfsManagerFactory = new MemFsManagerFactory();
		const tenantId = "gitrest-summaries-test";
		let documentId: string;
		let wholeSummaryManager: GitWholeSummaryManager;
		beforeEach(async () => {
			documentId = uuid();
			const repoManagerFactory = new IsomorphicGitManagerFactory(
				{
					useRepoOwner: true,
					baseDir: `/${uuid()}/tmp`,
				},
				{
					defaultFileSystemManagerFactory: memfsManagerFactory,
				},
				new NullExternalStorageManager(),
				testMode.repoPerDocEnabled,
				false /* enableRepositoryManagerMetrics */,
				testMode.enableSlimGitInit,
				undefined /* apiMetricsSamplingPeriod */,
			);
			const repoManager = await repoManagerFactory.create({
				repoOwner: tenantId,
				repoName: documentId,
				storageRoutingId: { tenantId, documentId },
			});
			wholeSummaryManager = new GitWholeSummaryManager(
				uuid(),
				repoManager,
				{ documentId, tenantId },
				false /* externalStorageEnabled */,
				{
					enableLowIoWrite: testMode.enableLowIoWrite,
					optimizeForInitialSummary: testMode.enableOptimizedInitialSummary,
				},
			);
		});

		afterEach(() => {
			process.stdout.write(
				`\nFinal storage size: ${Math.ceil(
					JSON.stringify(memfsManagerFactory.volume.toJSON()).length / 1_024,
				)}kb\n`,
			);
			memfsManagerFactory.volume.reset();
		});

		it("Can create and read an initial summary and a subsequent incremental summary", async () => {
			const initialWriteResponse = await wholeSummaryManager.writeSummary(
				sampleInitialSummaryUpload,
				true,
			);
			assert.strictEqual(
				initialWriteResponse.isNew,
				true,
				"Initial summary write `isNew` should be `true`.",
			);
			assertEqualSummaries(
				initialWriteResponse.writeSummaryResponse as IWholeFlatSummary,
				sampleInitialSummaryResponse,
				"Initial summary write response should match expected response.",
			);

			const initialReadResponse = await wholeSummaryManager.readSummary(LatestSummaryId);
			assertEqualSummaries(
				initialReadResponse,
				sampleInitialSummaryResponse,
				"Initial summary read response should match expected response.",
			);

			const channelWriteResponse = await wholeSummaryManager.writeSummary(
				sampleChannelSummaryUpload,
				false,
			);
			assert.strictEqual(
				channelWriteResponse.isNew,
				false,
				"Channel summary write `isNew` should be `false`.",
			);

			// Latest should still be the initial summary.
			const postChannelReadResponse = await wholeSummaryManager.readSummary(LatestSummaryId);
			assertEqualSummaries(
				postChannelReadResponse,
				sampleInitialSummaryResponse,
				"Channel summary read response should match expected initial container summary response.",
			);

			const containerWriteResponse = await wholeSummaryManager.writeSummary(
				// Replace the referenced channel summary with the one we just wrote.
				// This matters when low-io write is enabled, because it alters how the tree is stored.
				JSON.parse(
					JSON.stringify(sampleContainerSummaryUpload).replace(
						sampleChannelSummaryResult.id,
						channelWriteResponse.writeSummaryResponse.id,
					),
				),
				false,
			);
			assert.strictEqual(
				containerWriteResponse.isNew,
				false,
				"Container summary write `isNew` should be `false`.",
			);
			assertEqualSummaries(
				containerWriteResponse.writeSummaryResponse as IWholeFlatSummary,
				sampleContainerSummaryResponse,
				"Container summary write response should match expected response.",
			);

			const containerReadResponse = await wholeSummaryManager.readSummary(LatestSummaryId);
			assertEqualSummaries(
				containerReadResponse,
				sampleContainerSummaryResponse,
				"Container summary read response should match expected response.",
			);

			// And we should still be able to read the initial summary when referenced by ID.
			const initialLaterReadResponse = await wholeSummaryManager.readSummary(
				initialWriteResponse.writeSummaryResponse.id,
			);
			assertEqualSummaries(
				initialLaterReadResponse,
				sampleInitialSummaryResponse,
				"Later initial summary read response should match expected initial summary response.",
			);
		});
	});
});
