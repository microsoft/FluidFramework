## API Report File for "@intentional/shared-tree"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { EventEmitterWithErrorHandling } from '@fluidframework/telemetry-utils';
import { IChannel } from '@fluidframework/datastore-definitions';
import { IChannelAttributes } from '@fluidframework/datastore-definitions';
import { IChannelFactory } from '@fluidframework/datastore-definitions';
import { IChannelServices } from '@fluidframework/datastore-definitions';
import { IChannelStorageService } from '@fluidframework/datastore-definitions';
import { IDisposable } from '@fluidframework/common-definitions';
import { IErrorEvent } from '@fluidframework/common-definitions';
import { IFluidDataStoreRuntime } from '@fluidframework/datastore-definitions';
import { IFluidSerializer } from '@fluidframework/core-interfaces';
import { ISequencedDocumentMessage } from '@fluidframework/protocol-definitions';
import { ISharedObjectEvents } from '@fluidframework/shared-object-base';
import { ITelemetryBaseEvent } from '@fluidframework/common-definitions';
import { ITelemetryLogger } from '@fluidframework/common-definitions';
import { ITree } from '@fluidframework/protocol-definitions';
import { Serializable } from '@fluidframework/datastore-definitions';
import { SharedObject } from '@fluidframework/shared-object-base';

// @public
export type BadPlaceValidationResult = Exclude<PlaceValidationResult, PlaceValidationResult.Valid>;

// @public
export type BadRangeValidationResult = Exclude<RangeValidationResult, RangeValidationResultKind.Valid>;

// @public @sealed
export class BasicCheckout<TChange, TFailure = unknown> extends Checkout<TChange, TFailure> {
    constructor(tree: GenericSharedTree<TChange, TFailure>);
    // (undocumented)
    protected get latestCommittedView(): RevisionView;
    // (undocumented)
    waitForPendingUpdates(): Promise<void>;
}

// @public
export interface Build {
    // (undocumented)
    readonly destination: DetachedSequenceId;
    // (undocumented)
    readonly source: TreeNodeSequence<BuildNode>;
    // (undocumented)
    readonly type: typeof ChangeType.Build;
}

// @public
export type BuildNode = TreeNode<BuildNode> | DetachedSequenceId;

// @public
export type Change = Insert | Detach | Build | SetValue | Constraint;

// @public (undocumented)
export const Change: {
    build: (source: TreeNodeSequence<BuildNode>, destination: DetachedSequenceId) => Build;
    insert: (source: DetachedSequenceId, destination: StablePlace) => Insert;
    detach: (source: StableRange, destination?: DetachedSequenceId | undefined) => Detach;
    setPayload: (nodeToModify: NodeId, payload: Payload) => SetValue;
    clearPayload: (nodeToModify: NodeId) => SetValue;
    constraint: (toConstrain: StableRange, effect: ConstraintEffect, identityHash?: UuidString | undefined, length?: number | undefined, contentHash?: UuidString | undefined, parentNode?: NodeId | undefined, label?: TraitLabel | undefined) => Constraint;
};

// @public
export type ChangeNode = TreeNode<ChangeNode>;

// @public
export type ChangeResult<TFailure = unknown> = Result<TransactionView, TransactionFailure<TFailure>>;

// @public
export enum ChangeType {
    // (undocumented)
    Build = 2,
    // (undocumented)
    Constraint = 4,
    // (undocumented)
    Detach = 1,
    // (undocumented)
    Insert = 0,
    // (undocumented)
    SetValue = 3
}

// @public
export abstract class Checkout<TChange, TFailure = unknown> extends EventEmitterWithErrorHandling<ICheckoutEvents> implements IDisposable {
    protected constructor(tree: GenericSharedTree<TChange, TFailure>, currentView: RevisionView, onEditCommitted: EditCommittedHandler<GenericSharedTree<TChange, TFailure>>);
    abortEdit(): void;
    applyChanges(...changes: TChange[]): void;
    applyEdit(...changes: TChange[]): EditId;
    closeEdit(): EditId;
    // (undocumented)
    get currentView(): TreeView;
    dispose(error?: Error): void;
    // (undocumented)
    disposed: boolean;
    protected emitChange(): void;
    // (undocumented)
    getChangesAndRevisionBeforeInSession(id: EditId): {
        changes: readonly TChange[];
        before: RevisionView;
    };
    // (undocumented)
    getEditStatus(): EditStatus;
    protected handleNewEdit(id: EditId, result: ValidEditingResult<TChange>): void;
    // @internal (undocumented)
    hasOpenEdit(): boolean;
    protected hintKnownEditingResult(edit: Edit<TChange>, result: ValidEditingResult<TChange>): void;
    protected abstract readonly latestCommittedView: RevisionView;
    openEdit(): void;
    rebaseCurrentEdit(): EditValidationResult.Valid | EditValidationResult.Invalid;
    readonly tree: GenericSharedTree<TChange, TFailure>;
    tryApplyEdit(...changes: TChange[]): EditId | undefined;
    // (undocumented)
    abstract waitForPendingUpdates(): Promise<void>;
}

// @public
export enum CheckoutEvent {
    ViewChange = "viewChange"
}

// @public (undocumented)
export function comparePayloads(a: Payload, b: Payload): boolean;

// Warning: (ae-internal-missing-underscore) The name "CompressedId" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type CompressedId = FinalCompressedId | LocalCompressedId;

// @public
export interface Constraint {
    readonly contentHash?: UuidString;
    readonly effect: ConstraintEffect;
    readonly identityHash?: UuidString;
    readonly label?: TraitLabel;
    readonly length?: number;
    readonly parentNode?: NodeId;
    readonly toConstrain: StableRange;
    readonly type: typeof ChangeType.Constraint;
}

// @public
export enum ConstraintEffect {
    InvalidAndDiscard = 0,
    InvalidRetry = 1,
    ValidRetry = 2
}

// @public
export type Definition = UuidString & {
    readonly Definition: 'c0ef9488-2a78-482d-aeed-37fba996354c';
};

// @public
export const Delete: {
    create: (stableRange: StableRange) => Change;
};

// @public
export interface Delta<NodeId> {
    readonly added: readonly NodeId[];
    readonly changed: readonly NodeId[];
    readonly removed: readonly NodeId[];
}

// @public
export interface Detach {
    // (undocumented)
    readonly destination?: DetachedSequenceId;
    // (undocumented)
    readonly source: StableRange;
    // (undocumented)
    readonly type: typeof ChangeType.Detach;
}

// @public
export type DetachedSequenceId = number & {
    readonly DetachedSequenceId: 'f7d7903a-194e-45e7-8e82-c9ef4333577d';
};

// @public
export interface Edit<TChange> extends EditBase<TChange> {
    readonly id: EditId;
}

// @public
export type EditApplicationOutcome<TSharedTree> = {
    readonly view: RevisionView;
    readonly status: EditStatus.Applied;
} | {
    readonly failure: SharedTreeFailureType<TSharedTree>;
    readonly status: EditStatus.Invalid | EditStatus.Malformed;
};

// @public
export interface EditBase<TChange> {
    readonly changes: readonly TChange[];
    readonly pastAttemptCount?: number;
}

// Warning: (ae-internal-missing-underscore) The name "EditChunkOrHandle" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type EditChunkOrHandle<TChange> = EditHandle | readonly EditWithoutId<TChange>[];

// @public
export interface EditCommittedEventArguments<TSharedTree> {
    readonly editId: EditId;
    readonly local: boolean;
    readonly tree: TSharedTree;
}

// @public
export type EditCommittedHandler<TSharedTree> = (args: EditCommittedEventArguments<TSharedTree>) => void;

// Warning: (ae-internal-missing-underscore) The name "EditHandle" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface EditHandle {
    // (undocumented)
    readonly absolutePath: string;
    // (undocumented)
    readonly get: () => Promise<ArrayBufferLike>;
}

// @public
export type EditId = UuidString & {
    readonly EditId: '56897beb-53e4-4e66-85da-4bf5cd5d0d49';
};

// @public
export type EditingResult<TChange, TFailure = unknown> = FailedEditingResult<TChange, TFailure> | ValidEditingResult<TChange>;

// @public
export interface EditingResultBase<TChange> {
    readonly before: RevisionView;
    readonly changes: readonly TChange[];
    readonly status: EditStatus;
    readonly steps: readonly ReconciliationChange<TChange>[];
}

// Warning: (ae-internal-missing-underscore) The name "EditLogSummary" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface EditLogSummary<TChange> {
    readonly editChunks: readonly {
        readonly startRevision: number;
        readonly chunk: EditChunkOrHandle<TChange>;
    }[];
    readonly editIds: readonly EditId[];
}

// @public
export enum EditStatus {
    Applied = 2,
    Invalid = 1,
    Malformed = 0
}

// @public
export enum EditValidationResult {
    Invalid = 1,
    Malformed = 0,
    Valid = 2
}

// @public
export interface EditWithoutId<TChange> extends EditBase<TChange> {
    readonly id?: never;
}

// @public
export interface FailedEditingResult<TChange, TFailure> extends EditingResultBase<TChange> {
    readonly changes: readonly TChange[];
    readonly failure: TFailure;
    readonly status: EditStatus.Invalid | EditStatus.Malformed;
    readonly steps: readonly ReconciliationChange<TChange>[];
}

// @public
export interface FailingTransactionState<TChange, TFailure = unknown> extends TransactionFailure<TFailure> {
    readonly changes: readonly TChange[];
    readonly steps: readonly ReconciliationChange<TChange>[];
    readonly view: TransactionView;
}

// Warning: (ae-internal-missing-underscore) The name "FinalCompressedId" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type FinalCompressedId = number & {
    readonly FinalCompressedId: '5d83d1e2-98b7-4e4e-a889-54c855cfa73d';
};

// @public
export abstract class GenericSharedTree<TChange, TFailure = unknown> extends SharedObject<ISharedTreeEvents<GenericSharedTree<TChange, TFailure>>> {
    constructor(runtime: IFluidDataStoreRuntime, id: string, transactionFactory: (view: RevisionView) => GenericTransaction<TChange, TFailure>, attributes: IChannelAttributes, expensiveValidation?: boolean, summarizeHistory?: boolean, writeSummaryFormat?: SharedTreeSummaryWriteFormat, uploadEditChunks?: boolean);
    // @internal
    applyEdit(...changes: TChange[]): EditId;
    protected applyStashedOp(content: any): void;
    // (undocumented)
    get currentView(): RevisionView;
    // (undocumented)
    get edits(): OrderedEditSet<TChange>;
    equals(sharedTree: GenericSharedTree<any, any>): boolean;
    protected abstract generateSummary(editLog: OrderedEditSet<TChange>): SharedTreeSummaryBase;
    // (undocumented)
    getRuntime(): IFluidDataStoreRuntime;
    // (undocumented)
    protected loadCore(storage: IChannelStorageService): Promise<void>;
    // @internal
    loadSummary(summary: SharedTreeSummaryBase): void;
    // (undocumented)
    protected readonly logger: ITelemetryLogger;
    get logViewer(): LogViewer;
    // (undocumented)
    protected onDisconnect(): void;
    // (undocumented)
    protected processCore(message: ISequencedDocumentMessage, local: boolean): void;
    // @internal
    processLocalEdit(edit: Edit<TChange>): void;
    // (undocumented)
    protected registerCore(): void;
    // @internal
    saveSerializedSummary(summarizer?: SharedTreeSummarizer<TChange>): string;
    // @internal
    saveSummary(): SharedTreeSummaryBase;
    // (undocumented)
    protected readonly sequencedEditAppliedLogger: ITelemetryLogger;
    // (undocumented)
    snapshotCore(serializer: IFluidSerializer): ITree;
    // (undocumented)
    protected readonly summarizeHistory: boolean;
    // (undocumented)
    readonly transactionFactory: (view: RevisionView) => GenericTransaction<TChange, TFailure>;
    // (undocumented)
    protected writeSummaryFormat: SharedTreeSummaryWriteFormat;
}

// @public
export class GenericTransaction<TChange, TFailure = unknown> {
    constructor(view: RevisionView, policy: GenericTransactionPolicy<TChange, TFailure>);
    applyChange(change: TChange, path?: ReconciliationPath<TChange>): this;
    applyChanges(changes: Iterable<TChange>, path?: ReconciliationPath<TChange>): this;
    // (undocumented)
    protected readonly before: RevisionView;
    get changes(): readonly TChange[];
    // (undocumented)
    close(): EditingResult<TChange, TFailure>;
    get status(): EditStatus;
    get steps(): readonly ReconciliationChange<TChange>[];
    get view(): TransactionView;
}

// @public
export interface GenericTransactionPolicy<TChange, TFailure = unknown> {
    dispatchChange(state: SucceedingTransactionState<TChange>, change: TChange): ChangeResult<TFailure>;
    tryResolveChange(state: SucceedingTransactionState<TChange>, change: TChange, path: ReconciliationPath<TChange>): Result<TChange, TransactionFailure<TFailure>>;
    validateOnClose(state: SucceedingTransactionState<TChange>): ChangeResult<TFailure>;
}

// @public
export interface ICheckoutEvents extends IErrorEvent {
    // (undocumented)
    (event: 'viewChange', listener: (before: TreeView, after: TreeView) => void): any;
}

// @public
export const initialTree: ChangeNode;

// @public
export interface Insert {
    // (undocumented)
    readonly destination: StablePlace;
    // (undocumented)
    readonly source: DetachedSequenceId;
    // (undocumented)
    readonly type: typeof ChangeType.Insert;
}

// @public
export const Insert: {
    create: (nodes: TreeNodeSequence<BuildNode>, destination: StablePlace) => Change[];
};

// Warning: (ae-internal-missing-underscore) The name "isDetachedSequenceId" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function isDetachedSequenceId(node: BuildNode): node is DetachedSequenceId;

// @public
export interface ISharedTreeEvents<TSharedTree> extends ISharedObjectEvents {
    // (undocumented)
    (event: 'committedEdit', listener: EditCommittedHandler<TSharedTree>): any;
    // (undocumented)
    (event: 'appliedSequencedEdit', listener: SequencedEditAppliedHandler<TSharedTree>): any;
}

// @public
export function isSharedTreeEvent(event: ITelemetryBaseEvent): boolean;

// Warning: (ae-internal-missing-underscore) The name "LocalCompressedId" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type LocalCompressedId = number & {
    readonly LocalCompressedId: '6fccb42f-e2a4-4243-bd29-f13d12b9c6d1';
};

// @public
export interface LogViewer {
    getRevisionView(revision: Revision): Promise<RevisionView>;
    getRevisionViewInSession(revision: Revision): RevisionView;
}

// @public
export interface MergeHealthStats {
    badPlaceCount: number;
    badRangeCount: number;
    constraintViolationCount: number;
    deletedAncestorBadPlaceCount: number;
    deletedAncestorBadRangeCount: number;
    deletedSiblingBadPlaceCount: number;
    deletedSiblingBadRangeCount: number;
    editCount: number;
    failedEditCount: number;
    idAlreadyInUseCount: number;
    labelConstraintViolationCount: number;
    lengthConstraintViolationCount: number;
    malformedEditCount: number;
    maxAttemptCount: number;
    parentConstraintViolationCount: number;
    pathLengths: number[];
    rangeConstraintViolationCount: number;
    unknownIdCount: number;
    updatedRangeHasPlacesInDifferentTraitsCount: number;
    updatedRangeInvertedCount: number;
}

// Warning: (ae-internal-missing-underscore) The name "MinimalUuidString" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type MinimalUuidString = string & {
    readonly MinimalUuidString: '1b423880d0bb474c9207966fb613c1e2';
};

// @public
export const Move: {
    create: (source: StableRange, destination: StablePlace) => Change[];
};

// @public
export function newEdit<TEdit>(changes: readonly TEdit[]): Edit<TEdit>;

// @public
export interface NodeData {
    readonly definition: Definition;
    readonly identifier: NodeId;
    // (undocumented)
    readonly payload?: Payload;
}

// @public
export type NodeId = UuidString & {
    readonly NodeId: 'e53e7d6b-c8b9-431a-8805-4843fc639342';
};

// @public
export interface NodeInTrait {
    // (undocumented)
    readonly index: TraitNodeIndex;
    // (undocumented)
    readonly trait: TraitLocation;
}

// @public @sealed
export interface OrderedEditSet<TChange> {
    readonly editIds: readonly EditId[];
    // (undocumented)
    getEditAtIndex(index: number): Promise<Edit<TChange>>;
    // (undocumented)
    getEditInSessionAtIndex(index: number): Edit<TChange>;
    // @internal (undocumented)
    getEditLogSummary(useHandles?: boolean): EditLogSummary<TChange>;
    // (undocumented)
    getIdAtIndex(index: number): EditId;
    // (undocumented)
    getIndexOfId(editId: EditId): number;
    readonly length: number;
    // (undocumented)
    tryGetEdit(editId: EditId): Promise<Edit<TChange> | undefined>;
    // (undocumented)
    tryGetIndexOfId(editId: EditId): number | undefined;
}

// @public
export type Payload = Serializable;

// @public
export function placeFromStablePlace(view: TreeView, stablePlace: StablePlace): TreeViewPlace;

// @public
export type PlaceIndex = number & {
    readonly PlaceIndex: unique symbol;
};

// @public
export enum PlaceValidationResult {
    // (undocumented)
    Malformed = "Malformed",
    // (undocumented)
    MissingParent = "MissingParent",
    // (undocumented)
    MissingSibling = "MissingSibling",
    // (undocumented)
    SiblingIsRootOrDetached = "SiblingIsRootOrDetached",
    // (undocumented)
    Valid = "Valid"
}

// @public
export function rangeFromStableRange(view: TreeView, range: StableRange): TreeViewRange;

// @public
export type RangeValidationResult = RangeValidationResultKind.Valid | RangeValidationResultKind.PlacesInDifferentTraits | RangeValidationResultKind.Inverted | {
    kind: RangeValidationResultKind.BadPlace;
    place: StablePlace;
    placeFailure: BadPlaceValidationResult;
};

// @public
export enum RangeValidationResultKind {
    // (undocumented)
    BadPlace = "BadPlace",
    // (undocumented)
    Inverted = "Inverted",
    // (undocumented)
    PlacesInDifferentTraits = "PlacesInDifferentTraits",
    // (undocumented)
    Valid = "Valid"
}

// @public
export interface ReconciliationChange<TChange> {
    readonly after: TransactionView;
    readonly resolvedChange: TChange;
}

// @public
export interface ReconciliationEdit<TChange> {
    readonly [index: number]: ReconciliationChange<TChange>;
    readonly after: TreeView;
    readonly before: TreeView;
    readonly length: number;
}

// @public
export interface ReconciliationPath<TChange> {
    readonly [index: number]: ReconciliationEdit<TChange>;
    readonly length: number;
}

// @public
export type Result<TOk, TError> = Result.Ok<TOk> | Result.Error<TError>;

// @public (undocumented)
export namespace Result {
    export interface Error<TError> {
        // (undocumented)
        readonly error: TError;
        // (undocumented)
        readonly type: ResultType.Error;
    }
    export function error<TError>(error: TError): Error<TError>;
    export function isError<TOk, TError>(result: Result<TOk, TError>): result is Error<TError>;
    export function isOk<TOk, TError>(result: Result<TOk, TError>): result is Ok<TOk>;
    export function mapError<TOk, TErrorIn, TErrorOut>(result: Result<TOk, TErrorIn>, map: (TErrorIn: any) => TErrorOut): Result<TOk, TErrorOut>;
    export function mapOk<TOkIn, TOkOut, TError>(result: Result<TOkIn, TError>, map: (TOkIn: any) => TOkOut): Result<TOkOut, TError>;
    export interface Ok<TOk> {
        // (undocumented)
        readonly result: TOk;
        // (undocumented)
        readonly type: ResultType.Ok;
    }
    export function ok<TOk>(result: TOk): Ok<TOk>;
    export enum ResultType {
        Error = 1,
        Ok = 0
    }
}

// @public
export function revert(changes: readonly Change[], before: RevisionView): Change[];

// @public
export type Revision = number;

// @public
export class RevisionView extends TreeView {
    // (undocumented)
    equals(view: TreeView): boolean;
    static fromTree(root: ChangeNode, expensiveValidation?: boolean): RevisionView;
    openForTransaction(): TransactionView;
}

// @public
export function saveUploadedEditChunkContents<TChange>(editLog: OrderedEditSet<TChange>): Promise<UploadedEditChunkContents<TChange>[]>;

// @public
export interface SequencedEditAppliedEventArguments<TSharedTree> {
    readonly edit: Edit<SharedTreeChangeType<TSharedTree>>;
    readonly logger: ITelemetryLogger;
    readonly outcome: EditApplicationOutcome<TSharedTree>;
    readonly reconciliationPath: ReconciliationPath<SharedTreeChangeType<TSharedTree>>;
    readonly tree: TSharedTree;
    readonly wasLocal: boolean;
}

// @public
export type SequencedEditAppliedHandler<TSharedTree> = (args: SequencedEditAppliedEventArguments<TSharedTree>) => void;

// Warning: (ae-internal-missing-underscore) The name "SessionId" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type SessionId = StableId & {
    readonly SessionId: '4498f850-e14e-4be9-8db0-89ec00997e58';
};

// @public
export function setTrait(trait: TraitLocation, nodes: TreeNodeSequence<BuildNode>): readonly Change[];

// @public
export interface SetValue {
    // (undocumented)
    readonly nodeToModify: NodeId;
    readonly payload: Payload | null;
    // (undocumented)
    readonly type: typeof ChangeType.SetValue;
}

// @public @sealed
export class SharedTree extends GenericSharedTree<Change, Transaction.Failure> {
    constructor(runtime: IFluidDataStoreRuntime, id: string, expensiveValidation?: boolean, summarizeHistory?: boolean, writeSummaryFormat?: SharedTreeSummaryWriteFormat, uploadEditChunks?: boolean);
    static create(runtime: IFluidDataStoreRuntime, id?: string): SharedTree;
    protected generateSummary(editLog: OrderedEditSet<Change>): SharedTreeSummaryBase;
    static getFactory(summarizeHistory?: boolean, writeSummaryFormat?: SharedTreeSummaryWriteFormat, uploadEditChunks?: boolean): SharedTreeFactory;
}

// @public
export const sharedTreeAssertionErrorType = "SharedTreeAssertion";

// @public
export type SharedTreeChangeType<TSharedTree> = TSharedTree extends GenericSharedTree<infer TChange, any> ? TChange : never;

// @public
export enum SharedTreeDiagnosticEvent {
    AppliedEdit = "appliedEdit",
    CatchUpBlobUploaded = "uploadedCatchUpBlob",
    DroppedInvalidEdit = "droppedInvalidEdit",
    DroppedMalformedEdit = "droppedMalformedEdit",
    EditChunkUploaded = "uploadedEditChunk",
    UnexpectedHistoryChunk = "unexpectedHistoryChunk",
    VersionUpdated = "versionUpdated"
}

// @public
export enum SharedTreeEvent {
    EditCommitted = "committedEdit",
    SequencedEditApplied = "sequencedEditApplied"
}

// @public
export class SharedTreeFactory implements IChannelFactory {
    constructor(options?: SharedTreeFactoryOptions);
    // (undocumented)
    static Attributes: IChannelAttributes;
    // (undocumented)
    get attributes(): IChannelAttributes;
    create(runtime: IFluidDataStoreRuntime, id: string, expensiveValidation?: boolean): SharedTree;
    // (undocumented)
    load(runtime: IFluidDataStoreRuntime, id: string, services: IChannelServices, _channelAttributes: Readonly<IChannelAttributes>): Promise<IChannel>;
    // (undocumented)
    static Type: string;
    // (undocumented)
    get type(): string;
}

// @public
export interface SharedTreeFactoryOptions {
    expensiveValidation?: boolean;
    readonly summarizeHistory?: boolean;
    readonly uploadEditChunks?: boolean;
    readonly writeSummaryFormat?: SharedTreeSummaryWriteFormat;
}

// @public
export type SharedTreeFailureType<TSharedTree> = TSharedTree extends GenericSharedTree<any, infer TFailure> ? TFailure : never;

// @public
export class SharedTreeMergeHealthTelemetryHeartbeat {
    attachTree(tree: SharedTree): void;
    clearData(): void;
    detachAllTrees(): void;
    detachTree(tree: SharedTree): void;
    flushHeartbeat(): void;
    getStats(tree: SharedTree): MergeHealthStats;
    resetTreeData(tree: SharedTree): void;
    startHeartbeat(interval?: number): void;
    stopHeartbeat(): void;
}

// Warning: (ae-internal-missing-underscore) The name "SharedTreeSummarizer" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type SharedTreeSummarizer<TChange> = (editLog: OrderedEditSet<TChange>, currentView: RevisionView) => SharedTreeSummaryBase;

// @public
export interface SharedTreeSummary<TChange> extends SharedTreeSummaryBase {
    // (undocumented)
    readonly currentTree?: ChangeNode;
    // Warning: (ae-incompatible-release-tags) The symbol "editHistory" is marked as @public, but its signature references "EditLogSummary" which is marked as @internal
    readonly editHistory?: EditLogSummary<TChange>;
}

// @public
export interface SharedTreeSummaryBase {
    readonly version: string;
}

// @public
export enum SharedTreeSummaryWriteFormat {
    Format_0_0_2 = "0.0.2",
    Format_0_1_1 = "0.1.1"
}

// @public
export enum Side {
    // (undocumented)
    After = 1,
    // (undocumented)
    Before = 0
}

// Warning: (ae-internal-missing-underscore) The name "StableId" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type StableId = MinimalUuidString & {
    readonly StableId: '53172b0da3d541eabd75b43839c97f5a';
};

// @public
export interface StablePlace {
    readonly referenceSibling?: NodeId;
    readonly referenceTrait?: TraitLocation;
    readonly side: Side;
}

// @public (undocumented)
export const StablePlace: {
    before: (node: NodeData | NodeId) => StablePlace;
    after: (node: NodeData | NodeId) => StablePlace;
    atStartOf: (trait: TraitLocation) => StablePlace;
    atEndOf: (trait: TraitLocation) => StablePlace;
};

// @public
export interface StableRange {
    // (undocumented)
    readonly end: StablePlace;
    // (undocumented)
    readonly start: StablePlace;
}

// @public (undocumented)
export const StableRange: {
    from: (start: StablePlace) => {
        to: (end: StablePlace) => StableRange;
    };
    only: (node: NodeData | NodeId) => StableRange;
    all: (trait: TraitLocation) => StableRange;
};

// @public
export interface SucceedingTransactionState<TChange> {
    readonly changes: readonly TChange[];
    readonly status: EditStatus.Applied;
    readonly steps: readonly ReconciliationChange<TChange>[];
    readonly view: TransactionView;
}

// @public
export type TraitLabel = UuidString & {
    readonly TraitLabel: '613826ed-49cc-4df3-b2b8-bfc6866af8e3';
};

// @public
export interface TraitLocation {
    // (undocumented)
    readonly label: TraitLabel;
    // (undocumented)
    readonly parent: NodeId;
}

// @public
export interface TraitMap<TChild> {
    // (undocumented)
    readonly [key: string]: TreeNodeSequence<TChild>;
}

// @public
export type TraitNodeIndex = number & {
    readonly TraitNodeIndex: unique symbol;
};

// @public
export namespace Transaction {
    // (undocumented)
    export interface BadPlaceFailure {
        // (undocumented)
        readonly change: Change;
        // (undocumented)
        readonly kind: FailureKind.BadPlace;
        // (undocumented)
        readonly place: StablePlace;
        // (undocumented)
        readonly placeFailure: BadPlaceValidationResult;
    }
    // (undocumented)
    export interface BadRangeFailure {
        // (undocumented)
        readonly change: Change;
        // (undocumented)
        readonly kind: FailureKind.BadRange;
        // (undocumented)
        readonly range: StableRange;
        // (undocumented)
        readonly rangeFailure: BadRangeValidationResult;
    }
    // (undocumented)
    export interface ConstraintViolationFailure {
        // (undocumented)
        readonly constraint: Constraint;
        // (undocumented)
        readonly kind: FailureKind.ConstraintViolation;
        // (undocumented)
        readonly violation: ConstraintViolationResult;
    }
    // (undocumented)
    export enum ConstraintViolationKind {
        // (undocumented)
        BadLabel = "BadLabel",
        // (undocumented)
        BadLength = "BadLength",
        // (undocumented)
        BadParent = "BadParent",
        // (undocumented)
        BadRange = "BadRange"
    }
    // (undocumented)
    export type ConstraintViolationResult = {
        readonly kind: ConstraintViolationKind.BadRange;
        readonly rangeFailure: BadRangeValidationResult;
    } | {
        readonly kind: ConstraintViolationKind.BadLength;
        readonly actual: number;
    } | {
        readonly kind: ConstraintViolationKind.BadParent;
        readonly actual: NodeId;
    } | {
        readonly kind: ConstraintViolationKind.BadLabel;
        readonly actual: TraitLabel;
    };
    // (undocumented)
    export interface DetachedSequenceIdAlreadyInUseFailure {
        // (undocumented)
        readonly change: Change;
        // (undocumented)
        readonly kind: FailureKind.DetachedSequenceIdAlreadyInUse;
        // (undocumented)
        readonly sequenceId: DetachedSequenceId;
    }
    // (undocumented)
    export interface DetachedSequenceNotFoundFailure {
        // (undocumented)
        readonly change: Change;
        // (undocumented)
        readonly kind: FailureKind.DetachedSequenceNotFound;
        // (undocumented)
        readonly sequenceId: DetachedSequenceId;
    }
    // (undocumented)
    export interface DuplicateIdInBuildFailure {
        // (undocumented)
        readonly change: Change;
        // (undocumented)
        readonly id: NodeId;
        // (undocumented)
        readonly kind: FailureKind.DuplicateIdInBuild;
    }
    export function factory(view: RevisionView): GenericTransaction<Change, Failure>;
    export type Failure = UnusedDetachedSequenceFailure | DetachedSequenceIdAlreadyInUseFailure | DetachedSequenceNotFoundFailure | DuplicateIdInBuildFailure | IdAlreadyInUseFailure | UnknownIdFailure | BadPlaceFailure | BadRangeFailure | ConstraintViolationFailure;
    export enum FailureKind {
        // (undocumented)
        BadPlace = "BadPlace",
        // (undocumented)
        BadRange = "BadRange",
        // (undocumented)
        ConstraintViolation = "ConstraintViolation",
        // (undocumented)
        DetachedSequenceIdAlreadyInUse = "DetachedSequenceIdAlreadyInUse",
        // (undocumented)
        DetachedSequenceNotFound = "DetachedSequenceNotFound",
        // (undocumented)
        DuplicateIdInBuild = "DuplicateIdInBuild",
        // (undocumented)
        IdAlreadyInUse = "IdAlreadyInUse",
        // (undocumented)
        UnknownId = "UnknownId",
        // (undocumented)
        UnusedDetachedSequence = "UnusedDetachedSequence"
    }
    // (undocumented)
    export interface IdAlreadyInUseFailure {
        // (undocumented)
        readonly change: Change;
        // (undocumented)
        readonly id: NodeId;
        // (undocumented)
        readonly kind: FailureKind.IdAlreadyInUse;
    }
    export class Policy implements GenericTransactionPolicy<Change, Failure> {
        protected createViewNodesForTree(sequence: Iterable<BuildNode>, onCreateNode: (id: NodeId, node: TreeViewNode) => boolean, onInvalidDetachedId: (sequenceId: DetachedSequenceId) => void): NodeId[] | undefined;
        // (undocumented)
        protected readonly detached: Map<DetachedSequenceId, readonly NodeId[]>;
        // (undocumented)
        dispatchChange(state: ValidState, change: Change): ChangeResult<Failure>;
        // (undocumented)
        tryResolveChange(state: ValidState, change: Change): Result.Ok<Change>;
        // (undocumented)
        validateOnClose(state: ValidState): ChangeResult<Failure>;
    }
    // (undocumented)
    export interface UnknownIdFailure {
        // (undocumented)
        readonly change: Change;
        // (undocumented)
        readonly id: NodeId;
        // (undocumented)
        readonly kind: FailureKind.UnknownId;
    }
    // (undocumented)
    export interface UnusedDetachedSequenceFailure {
        // (undocumented)
        readonly kind: FailureKind.UnusedDetachedSequence;
        // (undocumented)
        readonly sequenceId: DetachedSequenceId;
    }
    // (undocumented)
    export type ValidState = SucceedingTransactionState<Change>;
        {};
}

// @public
export interface TransactionFailure<TFailure = unknown> {
    readonly failure: TFailure;
    readonly status: EditStatus.Invalid | EditStatus.Malformed;
}

// @public
export type TransactionState<TChange, TFailure = unknown> = SucceedingTransactionState<TChange> | FailingTransactionState<TChange, TFailure>;

// @public
export class TransactionView extends TreeView {
    addNodes(sequence: Iterable<TreeViewNode>): TransactionView;
    attachRange(nodesToAttach: readonly NodeId[], place: TreeViewPlace): TransactionView;
    close(): RevisionView;
    deleteNodes(nodes: Iterable<NodeId>): TransactionView;
    detachRange(rangeToDetach: TreeViewRange): {
        view: TransactionView;
        detached: readonly NodeId[];
    };
    // (undocumented)
    equals(view: TreeView): boolean;
    setNodeValue(nodeId: NodeId, value: Payload): TransactionView;
}

// @public
export interface TreeNode<TChild> extends NodeData {
    // (undocumented)
    readonly traits: TraitMap<TChild>;
}

// @public
export class TreeNodeHandle implements TreeNode<TreeNodeHandle> {
    constructor(view: TreeView, nodeId: NodeId);
    // (undocumented)
    get definition(): Definition;
    demandTree(): ChangeNode;
    // (undocumented)
    get identifier(): NodeId;
    get node(): ChangeNode;
    // (undocumented)
    get payload(): Payload | undefined;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get traits(): TraitMap<TreeNodeHandle>;
}

// @public
export type TreeNodeSequence<TChild> = readonly TChild[];

// @public
export abstract class TreeView {
    // (undocumented)
    [Symbol.iterator](): IterableIterator<TreeViewNode>;
    protected constructor(root: NodeId, forest: Forest);
    assertConsistent(): void;
    delta(view: TreeView): Delta<NodeId>;
    // (undocumented)
    abstract equals(view: TreeView): boolean;
    // (undocumented)
    findIndexWithinTrait(place: TreeViewPlace): PlaceIndex;
    // Warning: (ae-forgotten-export) The symbol "Forest" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected readonly forest: Forest;
    // @deprecated
    static fromTree(root: ChangeNode, expensiveValidation?: boolean): RevisionView;
    // (undocumented)
    getChangeNode(id: NodeId): ChangeNode;
    // (undocumented)
    getChangeNodes(nodeIds: readonly NodeId[]): ChangeNode[];
    getChangeNodeTree(): ChangeNode;
    // (undocumented)
    getIndexInTrait(node: NodeId): TraitNodeIndex;
    // (undocumented)
    getParentViewNode(id: NodeId): TreeViewNode | undefined;
    // (undocumented)
    getTrait(traitLocation: TraitLocation): readonly NodeId[];
    // (undocumented)
    getTraitLabel(id: NodeId): TraitLabel | undefined;
    // (undocumented)
    getTraitLocation(id: NodeId): TraitLocation;
    // (undocumented)
    getViewNode(id: NodeId): TreeViewNode;
    // (undocumented)
    hasEqualForest(view: TreeView, strict?: boolean): boolean;
    // (undocumented)
    hasNode(id: NodeId): boolean;
    // (undocumented)
    readonly root: NodeId;
    // (undocumented)
    get size(): number;
}

// @public
export interface TreeViewNode extends NodeData {
    // (undocumented)
    readonly traits: ReadonlyMap<TraitLabel, readonly NodeId[]>;
}

// @public
export interface TreeViewPlace {
    // (undocumented)
    readonly sibling?: NodeId;
    // (undocumented)
    readonly side: Side;
    // (undocumented)
    readonly trait: TraitLocation;
}

// @public
export interface TreeViewRange {
    // (undocumented)
    readonly end: TreeViewPlace;
    // (undocumented)
    readonly start: TreeViewPlace;
}

// @public
export interface UploadedEditChunkContents<TChange> {
    absolutePath: string;
    chunkContents: EditWithoutId<TChange>[];
}

// @public
export function useFailedSequencedEditTelemetry<TSharedTree extends GenericSharedTree<any, any>>(tree: TSharedTree): {
    disable: () => void;
};

// @public
export type UuidString = string & {
    readonly UuidString: '9d40d0ae-90d9-44b1-9482-9f55d59d5465';
};

// @public
export function validateStablePlace(view: TreeView, place: StablePlace): PlaceValidationResult;

// @public
export function validateStableRange(view: TreeView, range: StableRange): RangeValidationResult;

// @public
export interface ValidEditingResult<TChange> extends EditingResultBase<TChange> {
    readonly after: RevisionView;
    readonly status: EditStatus.Applied;
}

```
