/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * This tool/script takes the output files generated by the \@fluid-tools/benchmark package
 * for execution-time performance tests and extracts and logs relevant metrics from them.
 * When run in our internal pipelines with a dynamically injected logger, it forwards the
 * said metrics to Kusto for easier monitoring and tracking changes through time.
 */

import fs from "fs";
import path from "path";
import { ITelemetryBufferedLogger } from "@fluidframework/test-driver-definitions";
import { ConsoleLogger } from "./logger";

// Allow for dynamic injection of a logger. Leveraged in internal CI pipelines.
// The parameter to getTestLogger() is a delay to apply after flushing the buffer.
const _global: any = global;
let logger: ITelemetryBufferedLogger = _global.getTestLogger?.(5_000);

if (logger === undefined) {
    logger = new ConsoleLogger();
}

const filesToProcess: string[] = [];

// The tool expects paths with files to be processed to be passed as arguments when invoking it, e.g.
//   node dist/index.js /my/first/path/ /another/path/
// The first two entries in process.argv are the executable (node) and the executed file (dist/index.js);
// skip those two.
const dirs = process.argv.slice(2);

while (dirs.length > 0) {
    const dir: string = dirs.pop()!;
    const files = fs.readdirSync(dir, { withFileTypes: true });
    files.forEach((dirent) => {
        const direntFullPath = path.join(dir, dirent.name);
        if (dirent.isDirectory()) {
            dirs.push(direntFullPath);
            return;
        }
        // We expect the files to be processed to be .json files. Ignore everything else.
        if (!dirent.name.endsWith(".json")) {
            return;
        }
        filesToProcess.push(direntFullPath);
    });
}

filesToProcess.forEach((fullPath) => {
    try {
        console.log(`Processing file '${fullPath}'`);
        const data = JSON.parse(fs.readFileSync(fullPath, "utf8"));
        data.benchmarks.forEach((b) => {
            const props = {
                suiteName: data.suiteName,
                benchmarkName: b.benchmarkName,
                arithmeticMean: b.stats.arithmeticMean,
                marginOfError: b.stats.marginOfError,
            };

            logger.send({
                category: "performance",
                eventName: "Benchmark",
                ...props,
            });
        });
    } catch (err) {
        console.error(`Unexpected error processing file '${fullPath}'.\n${err}`);
    }
});

(async () => {
    await logger.flush();
    console.log("Done");
    process.exit(0);
})().catch((e) => {
    console.error(`ERROR: ${e.stack}`);
    process.exit(-1);
});
