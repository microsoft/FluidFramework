/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

const { PackageName } = require("@rushstack/node-core-library");

const {
	formattedGeneratedContentBody,
	formattedSectionText,
	getPackageMetadata,
	resolveRelativePackageJsonPath,
} = require("../utilities.cjs");

/**
 * Generates a simple Markdown heading and contents with information about how to import from the package's export options.
 *
 * @param {string} packageName - Name of the package (fully scoped).
 * @param {boolean} includeHeading - Whether or not to include the heading in the generated contents.
 * @param {boolean} hasAlphaExport - Whether or not the package has an `/alpha` export to be denoted.
 * @param {boolean} hasBetaExport - Whether or not the package has an `/beta` export to be denoted.
 * @param {boolean} hasLegacyExport - Whether or not the package has an `/legacy` export to be denoted.
 */
const generatePackageImportInstructionsSection = (
	packageName,
	includeHeading,
	hasAlphaExport,
	hasBetaExport,
	hasLegacyExport,
) => {
	const lines = [
		"This package leverages [package.json exports](https://devblogs.microsoft.com/typescript/announcing-typescript-4-5-beta/#packagejson-exports-imports-and-self-referencing) to separate its APIs by support level.",
		"For more information on the related support guarantees, see [API Support Levels](https://fluidframework.com/docs/build/releases-and-apitags/#api-support-levels).",
		"", // Blank line
		"To access the `public` ([SemVer](https://semver.org/)) APIs, import directly from the root of the package as normal.",
	];

	if (hasBetaExport) {
		lines.push("", `To access the \`beta\` APIs, import via \`${packageName}/beta\`.`);
	}

	if (hasAlphaExport) {
		lines.push("", `To access the \`alpha\` APIs, import via \`${packageName}/alpha\`.`);
	}

	if (hasLegacyExport) {
		lines.push("", `To access the \`legacy\` APIs, import via \`${packageName}/legacy\`.`);
	}

	const sectionBody = lines.join("\n");

	return formattedSectionText(
		sectionBody,
		includeHeading ? "Importing from this package" : undefined,
	);
};

/**
 * Generates a README section with instructions for how to import different API support levels based on
 * our standard package export paths (`/alpha`, `/beta`, `/legacy`).
 *
 * @remarks
 * The text content generated by this function assumes that export paths are used by the package.
 * If exports are not leveraged, use of this template is not recommended.
 *
 * @param {object} content - The original document file contents.
 * @param {object} options - Transform options.
 * @param {string} options.packageJsonPath - (optional) Relative file path to the package.json file for the package.
 * Default: "./package.json".
 * @param {"TRUE" | "FALSE" | undefined} options.includeHeading - (optional) Whether or not to include a Markdown heading with the generated section contents.
 * Default: `TRUE`.
 * @param {"TRUE" | "FALSE" | undefined} options.hasAlphaExport - (optional) Whether or not the package includes a `/alpha` export to be denoted.
 * Default: `FALSE`.
 * @param {"TRUE" | "FALSE" | undefined} options.hasBetaExport - (optional) Whether or not the package includes a `/beta` export to be denoted.
 * Default: `FALSE`.
 * @param {"TRUE" | "FALSE" | undefined} options.hasLegacyExport - (optional) Whether or not the package includes a `/legacy` export to be denoted.
 * Default: `FALSE`.
 *
 * @param
 * @param {object} config - Transform configuration.
 * @param {string} config.originalPath - Path to the document being modified.
 */
function packageImportInstructionsSectionTransform(content, options, config) {
	const includeHeading = options.includeHeading !== "FALSE";
	const hasAlphaExport = options.hasLegacyExport === "TRUE";
	const hasBetaExport = options.hasLegacyExport === "TRUE";
	const hasLegacyExport = options.hasLegacyExport === "TRUE";

	const resolvedPackageJsonPath = resolveRelativePackageJsonPath(
		config.originalPath,
		options.packageJsonPath,
	);
	const packageMetadata = getPackageMetadata(resolvedPackageJsonPath);
	const packageName = packageMetadata.name;

	return formattedGeneratedContentBody(
		generatePackageImportInstructionsSection(
			packageName,
			includeHeading,
			hasAlphaExport,
			hasBetaExport,
			hasLegacyExport,
		),
	);
}

module.exports = {
	generatePackageImportInstructionsSection,
	packageImportInstructionsSectionTransform,
};
