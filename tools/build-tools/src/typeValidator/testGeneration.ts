/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import * as fs from "fs";
import { PackageDetails } from "./packageJson";
import { generateTypeDataForProject, TypeData } from "./typeData";

export function generateTests(packageDetails: PackageDetails, packageDir: string) {

    const currentTypeData = generateTypeDataForProject(packageDir, undefined);

    for(const oldVersion of packageDetails.oldVersions){
            const testString: string[]=[
`/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-validator in @fluidframework/build-tools.
 */
import * as old from "${oldVersion}";
import * as current from "../index";
`
            ];
        const oldDetails = generateTypeDataForProject(packageDir, oldVersion);
        const oldTypes = new Map<string, TypeData>(oldDetails.typeData.map((v)=>[v.name,v]));
        for(const type of currentTypeData.typeData){
            // no need to test new types
            if(oldTypes.has(type.name)){
                const oldType: TestCaseTypeData = {
                    prefix: "old",
                    ... oldTypes.get(type.name)!,
                }
                const currentType: TestCaseTypeData = {
                    prefix: "current",
                    ... type,
                }

                testString.push(`/*`)
                testString.push(`* validate forward compat by using old type in place of current type`);
                testString.push(`* to disable, add in package.json under typeValidation.broken:`);
                testString.push(`* "${type.name}": {"forwardCompat": false}`);
                const forwarCompatCase = buildTestCase(oldType, currentType);
                if(currentTypeData.packageDetails.broken[type.name]?.forwardCompat !== false){
                    testString.push("*/");
                    testString.push(... forwarCompatCase);
                }else{
                    testString.push(... forwarCompatCase);
                    testString.push("*/");
                }
                testString.push("");

                testString.push(`/*`)
                testString.push(`* validate back compat by using current type in place of old type`);
                testString.push(`* to disable, add in package.json under typeValidation.broken:`);
                testString.push(`* "${type.name}": {"backCompat": false}`);
                const backCompatCase = buildTestCase(currentType, oldType);
                if(currentTypeData.packageDetails.broken[type.name]?.backCompat !== false){
                    testString.push("*/");
                    testString.push(... backCompatCase)
                }else{
                    testString.push(... backCompatCase);
                    testString.push("*/");
                }
                testString.push("");

            }
        }
        const testPath = `${packageDir}/src/test`
        if(!fs.existsSync(testPath)){
            fs.mkdirSync(testPath);
        }

        fs.writeFileSync(`${testPath}/validate${oldDetails.packageDetails.version}.ts`, testString.join("\n"));
    }
}


interface TestCaseTypeData extends TypeData{
    prefix: "old" | "current"
}

function buildTestCase(getAsType:TestCaseTypeData, useType:TestCaseTypeData){
    const getSig =`get_${getAsType.prefix}_${getAsType.name}`;
    const useSig =`use_${useType.prefix}_${useType.name}`;
    const testString: string[] =[];
    testString.push(`declare function ${getSig}(): ${getAsType.prefix}.${getAsType.name}${getAsType.typeParams ?? ""};`);
    testString.push(`declare function ${useSig}(use: ${useType.prefix}.${useType.name}${useType.typeParams ?? ""});`);
    testString.push(`${useSig}(${getSig}());`)
    return testString
}
