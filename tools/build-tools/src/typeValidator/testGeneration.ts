/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import * as fs from "fs";
import { PackageDetails } from "./packageJson";
import { generateTypeDataForProject, toTypeString, TypeData } from "./typeData";

export function generateTests(packageDetails: PackageDetails, outDir: string | undefined) {

    const currentTypeData = generateTypeDataForProject(packageDetails.packageDir, undefined);

    let indexPath = "..";
    if(outDir){
        while(!fs.existsSync(`${packageDetails.packageDir}/${outDir}/${indexPath}/index.ts`)){
            indexPath +="/.."
        }
    }

    for(const oldVersion of packageDetails.oldVersions){
            const testString: string[]=[
`/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
 * Generated by fluid-type-validator in @fluidframework/build-tools.
 */
import * as old from "${oldVersion}";
import * as current from "${indexPath}/index";
`
            ];
        const oldDetails = generateTypeDataForProject(packageDetails.packageDir, oldVersion);
        const currentTypeMap = new Map<string, TypeData>(currentTypeData.typeData.map((v)=>[getFullTypeName(v),v]));
        for(const oldTypeData of oldDetails.typeData){
            // no need to test new types
            if(currentTypeMap.has(getFullTypeName(oldTypeData))){
                const oldType: TestCaseTypeData = {
                    prefix: "old",
                    ... oldTypeData,
                }
                const currentType: TestCaseTypeData = {
                    prefix: "current",
                    ... currentTypeMap.get(getFullTypeName(oldTypeData))!,

                }
                const brokenData = currentTypeData.packageDetails.broken?.[oldDetails.packageDetails.version]?.[getFullTypeName(currentType)];

                testString.push(`/*`)
                testString.push(`* validate forward compat by using old type in place of current type`);
                testString.push(`* to disable, add in package.json under typeValidation.broken.${oldDetails.packageDetails.version}:`);
                testString.push(`* "${getFullTypeName(currentType)}": {"forwardCompat": false}`);
                const forwarCompatCase = buildTestCase(oldType, currentType);
                if(brokenData?.forwardCompat !== false){
                    testString.push("*/");
                    testString.push(... forwarCompatCase);
                }else{
                    testString.push(... forwarCompatCase);
                    testString.push("*/");
                }
                testString.push("");

                testString.push(`/*`)
                testString.push(`* validate back compat by using current type in place of old type`);
                testString.push(`* to disable, add in package.json under typeValidation.broken.${oldDetails.packageDetails.version}:`);
                testString.push(`* "${getFullTypeName(currentType)}": {"backCompat": false}`);
                const backCompatCase = buildTestCase(currentType, oldType);
                if(brokenData?.backCompat !== false){
                    testString.push("*/");
                    testString.push(... backCompatCase)
                }else{
                    testString.push(... backCompatCase);
                    testString.push("*/");
                }
                testString.push("");

            }
        }
        const testPath =`${packageDetails.packageDir}/${outDir ? outDir : "/src/test"}`;
        if(!fs.existsSync(testPath)){
            fs.mkdirSync(testPath);
        }

        fs.writeFileSync(
            `${testPath}/validate${oldDetails.packageDetails.version}.ts`,
            testString.join("\n"));
    }
}


interface TestCaseTypeData extends TypeData{
    prefix: "old" | "current"
}

function buildTestCase(getAsType:TestCaseTypeData, useType:TestCaseTypeData){
    const getSig =`get_${getAsType.prefix}_${getFullTypeName(getAsType)}`;
    const useSig =`use_${useType.prefix}_${getFullTypeName(useType)}`;
    const testString: string[] =[];
    testString.push(`declare function ${getSig}():\n    ${toTypeString(getAsType.prefix, getAsType)};`);
    testString.push(`declare function ${useSig}(\n    use: ${toTypeString(getAsType.prefix, useType)});`);
    testString.push(`${useSig}(\n    ${getSig}());`)
    return testString
}

function getFullTypeName(typeData: TypeData){
    return `${typeData.kind}_${typeData.name}`
}
