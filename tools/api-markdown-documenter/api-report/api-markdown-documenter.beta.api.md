## Beta API Report File for "@fluid-tools/api-markdown-documenter"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ApiCallSignature } from '@microsoft/api-extractor-model';
import { ApiClass } from '@microsoft/api-extractor-model';
import { ApiConstructor } from '@microsoft/api-extractor-model';
import { ApiConstructSignature } from '@microsoft/api-extractor-model';
import { ApiEntryPoint } from '@microsoft/api-extractor-model';
import { ApiEnum } from '@microsoft/api-extractor-model';
import { ApiEnumMember } from '@microsoft/api-extractor-model';
import { ApiFunction } from '@microsoft/api-extractor-model';
import { ApiIndexSignature } from '@microsoft/api-extractor-model';
import { ApiInterface } from '@microsoft/api-extractor-model';
import { ApiItem } from '@microsoft/api-extractor-model';
import { ApiItemKind } from '@microsoft/api-extractor-model';
import { ApiMethod } from '@microsoft/api-extractor-model';
import { ApiMethodSignature } from '@microsoft/api-extractor-model';
import { ApiModel } from '@microsoft/api-extractor-model';
import { ApiNamespace } from '@microsoft/api-extractor-model';
import { ApiPackage } from '@microsoft/api-extractor-model';
import { ApiProperty } from '@microsoft/api-extractor-model';
import { ApiPropertySignature } from '@microsoft/api-extractor-model';
import { ApiTypeAlias } from '@microsoft/api-extractor-model';
import { ApiVariable } from '@microsoft/api-extractor-model';
import type { BlockContent as BlockContent_2 } from 'mdast';
import type { Data } from 'unist';
import { DocSection } from '@microsoft/tsdoc';
import { Excerpt } from '@microsoft/api-extractor-model';
import type { ListItem } from 'mdast';
import type { Literal } from 'unist';
import { NewlineKind } from '@rushstack/node-core-library';
import type { Node as Node_2 } from 'unist';
import type { Nodes } from 'hast';
import type { Nodes as Nodes_2 } from 'mdast';
import { Options } from 'mdast-util-to-markdown';
import type { Parent } from 'unist';
import type { PhrasingContent } from 'mdast';
import { ReleaseTag } from '@microsoft/api-extractor-model';
import type { Root } from 'hast';
import type { Root as Root_2 } from 'mdast';
import type { RootContent } from 'mdast';
import type { TableCell } from 'mdast';
import type { TableRow } from 'mdast';
import { TypeParameter } from '@microsoft/api-extractor-model';

// @public
function ancestryHasModifierTag(apiItem: ApiItem, tagName: string): boolean;

// @public
export type ApiFunctionLike = ApiConstructSignature | ApiConstructor | ApiFunction | ApiMethod | ApiMethodSignature;

export { ApiItem }

export { ApiItemKind }

// @public
export interface ApiItemTransformationConfiguration extends ApiItemTransformationConfigurationBase, DocumentationSuiteConfiguration, Required<LoggingConfiguration> {
    readonly defaultSectionLayout: (apiItem: ApiItem, childSections: SectionNode[] | undefined, config: ApiItemTransformationConfiguration) => SectionNode[];
    readonly transformations: ApiItemTransformations;
    readonly uriRoot: string;
}

// @public @sealed
export interface ApiItemTransformationConfigurationBase {
    readonly apiModel: ApiModel;
}

// @public
export interface ApiItemTransformationOptions extends ApiItemTransformationConfigurationBase, DocumentationSuiteOptions, LoggingConfiguration {
    readonly defaultSectionLayout?: (apiItem: ApiItem, childSections: SectionNode[] | undefined, config: ApiItemTransformationConfiguration) => SectionNode[];
    readonly transformations?: Partial<ApiItemTransformations>;
    readonly uriRoot?: string | undefined;
}

// @public
export interface ApiItemTransformations {
    // (undocumented)
    readonly [ApiItemKind.CallSignature]: TransformApiItemWithoutChildren<ApiCallSignature>;
    // (undocumented)
    readonly [ApiItemKind.Class]: TransformApiItemWithChildren<ApiClass>;
    // (undocumented)
    readonly [ApiItemKind.Constructor]: TransformApiItemWithoutChildren<ApiConstructor>;
    // (undocumented)
    readonly [ApiItemKind.ConstructSignature]: TransformApiItemWithoutChildren<ApiConstructSignature>;
    readonly [ApiItemKind.EntryPoint]: TransformApiItemWithChildren<ApiEntryPoint>;
    // (undocumented)
    readonly [ApiItemKind.Enum]: TransformApiItemWithChildren<ApiEnum>;
    // (undocumented)
    readonly [ApiItemKind.EnumMember]: TransformApiItemWithoutChildren<ApiEnumMember>;
    // (undocumented)
    readonly [ApiItemKind.Function]: TransformApiItemWithoutChildren<ApiFunction>;
    // (undocumented)
    readonly [ApiItemKind.IndexSignature]: TransformApiItemWithoutChildren<ApiIndexSignature>;
    // (undocumented)
    readonly [ApiItemKind.Interface]: TransformApiItemWithChildren<ApiInterface>;
    // (undocumented)
    readonly [ApiItemKind.Method]: TransformApiItemWithoutChildren<ApiMethod>;
    // (undocumented)
    readonly [ApiItemKind.MethodSignature]: TransformApiItemWithoutChildren<ApiMethodSignature>;
    readonly [ApiItemKind.Model]: TransformApiItemWithoutChildren<ApiModel>;
    // (undocumented)
    readonly [ApiItemKind.Namespace]: TransformApiItemWithChildren<ApiNamespace>;
    // (undocumented)
    readonly [ApiItemKind.Property]: TransformApiItemWithoutChildren<ApiProperty>;
    // (undocumented)
    readonly [ApiItemKind.PropertySignature]: TransformApiItemWithoutChildren<ApiPropertySignature>;
    // (undocumented)
    readonly [ApiItemKind.TypeAlias]: TransformApiItemWithChildren<ApiTypeAlias>;
    // (undocumented)
    readonly [ApiItemKind.Variable]: TransformApiItemWithoutChildren<ApiVariable>;
}

declare namespace ApiItemUtilities {
    export {
        createQualifiedDocumentNameForApiItem,
        filterItems,
        getHeadingForApiItem,
        getLinkForApiItem,
        shouldItemBeIncluded,
        ancestryHasModifierTag,
        getCustomBlockComments,
        getDefaultValueBlock,
        getDeprecatedBlock,
        getEffectiveReleaseLevel,
        getExampleBlocks,
        getFileSafeNameForApiItem,
        getModifiers,
        getModifierTags,
        getReturnsBlock,
        getSeeBlocks,
        getSingleLineExcerptText,
        getThrowsBlocks,
        getUnscopedPackageName,
        hasModifierTag,
        isDeprecated,
        isOptional,
        isReadonly,
        isStatic
    }
}
export { ApiItemUtilities }

// @public
export type ApiMemberKind = Exclude<ValidApiItemKind, ApiItemKind.EntryPoint | ApiItemKind.Model | ApiItemKind.Package>;

export { ApiModel }

// @public
export enum ApiModifier {
    Optional = "optional",
    Readonly = "readonly",
    Sealed = "sealed",
    Static = "static",
    Virtual = "virtual"
}

// @public
export type ApiModuleLike = ApiEntryPoint | ApiNamespace;

export { ApiPackage }

// @public
export type ApiSignatureLike = ApiCallSignature | ApiIndexSignature;

// @public
export type BlockContent = BlockContentMap[keyof BlockContentMap];

// @public
export interface BlockContentMap {
    // (undocumented)
    list: ListNode;
    // (undocumented)
    markdownBlockContent: MarkdownBlockContentNode;
    // (undocumented)
    table: TableNode;
}

// @public
export function blockContentToMarkdown(node: BlockContent, context: ToMarkdownContext): [BlockContent_2];

// @public
export type BlockContentToMarkdownTransformations = {
    readonly [K in keyof BlockContentMap]: ToMarkdownTransformation<BlockContentMap[K], BlockContent_2[]>;
};

// @public
function createBreadcrumbParagraph(apiItem: ApiItem, config: ApiItemTransformationConfiguration): MarkdownBlockContentNode;

// @public
function createDeprecationNoticeSection(apiItem: ApiItem, config: ApiItemTransformationConfiguration): SectionNode | undefined;

// @public
function createExamplesSection(apiItem: ApiItem, config: ApiItemTransformationConfiguration, headingText?: string): SectionNode | undefined;

// @public
function createParametersSection(apiFunctionLike: ApiFunctionLike, config: ApiItemTransformationConfiguration): SectionNode | undefined;

// @public
function createQualifiedDocumentNameForApiItem(apiItem: ApiItem, hierarchyConfig: HierarchyConfiguration): string;

// @public
function createRemarksSection(apiItem: ApiItem, config: ApiItemTransformationConfiguration): SectionNode | undefined;

// @public
function createReturnsSection(apiItem: ApiItem, config: ApiItemTransformationConfiguration): SectionNode | undefined;

// @public
function createSeeAlsoSection(apiItem: ApiItem, config: ApiItemTransformationConfiguration): SectionNode | undefined;

// @public
function createSignatureSection(apiItem: ApiItem, config: ApiItemTransformationConfiguration): SectionNode | undefined;

// @public
function createSummarySection(apiItem: ApiItem, config: ApiItemTransformationConfiguration): SectionNode | undefined;

// @public
function createThrowsSection(apiItem: ApiItem, config: ApiItemTransformationConfiguration, headingText?: string): SectionNode | undefined;

// @public
function createTypeParametersSection(typeParameters: readonly TypeParameter[], contextApiItem: ApiItem, config: ApiItemTransformationConfiguration): SectionNode;

// @public
export const defaultConsoleLogger: Logger;

// @public
export namespace DefaultDocumentationSuiteConfiguration {
    export function defaultExclude(): boolean;
    export function defaultGetAlertsForItem(apiItem: ApiItem): string[];
    export function defaultGetHeadingTextForItem(apiItem: ApiItem): string;
    export function defaultGetLinkTextForItem(apiItem: ApiItem): string;
    export function defaultGetUriBaseOverrideForItem(): string | undefined;
}

// @public @sealed
export type DocumentationHierarchyConfiguration = SectionHierarchyConfiguration | DocumentHierarchyConfiguration | FolderHierarchyConfiguration;

// @public @sealed
export interface DocumentationHierarchyConfigurationBase {
    readonly kind: HierarchyKind;
}

// @public
export interface DocumentationLiteralNode<TValue = unknown> extends Literal<TValue>, DocumentationNode {
    readonly type: string;
    readonly value: TValue;
}

// @public
export abstract class DocumentationLiteralNodeBase<TValue = unknown> implements DocumentationLiteralNode<TValue> {
    protected constructor(value: TValue);
    abstract type: string;
    readonly value: TValue;
}

// @public
export interface DocumentationNode<TData extends object = Data> extends Node_2<TData> {
    readonly type: string;
}

// @public
export function documentationNodesToHtml(nodes: DocumentationNode[], config: ToHtmlConfiguration): Nodes[];

// @public
export function documentationNodesToHtml(nodes: DocumentationNode[], transformationContext: ToHtmlContext): Nodes[];

// @public
export function documentationNodeToHtml(node: DocumentationNode, config: ToHtmlConfiguration): Nodes;

// @public
export function documentationNodeToHtml(node: DocumentationNode, context: ToHtmlContext): Nodes;

// @public
export interface DocumentationParentNode<TDocumentationNode extends Node_2> extends Parent<TDocumentationNode, Data>, DocumentationNode {
    readonly children: TDocumentationNode[];
    readonly type: string;
}

// @public
export abstract class DocumentationParentNodeBase<TDocumentationNode extends Node_2> implements DocumentationParentNode<TDocumentationNode> {
    protected constructor(children: TDocumentationNode[]);
    readonly children: TDocumentationNode[];
    abstract type: string;
}

// @public
export interface DocumentationSuiteConfiguration {
    readonly exclude: (apiItem: ApiItem) => boolean;
    readonly getAlertsForItem: (apiItem: ApiItem) => string[];
    readonly getHeadingTextForItem: (apiItem: ApiItem) => string;
    readonly getLinkTextForItem: (apiItem: ApiItem) => string;
    readonly getUriBaseOverrideForItem: (apiItem: ApiItem) => string | undefined;
    readonly hierarchy: HierarchyConfiguration;
    readonly includeBreadcrumb: boolean;
    readonly includeTopLevelDocumentHeading: boolean;
    readonly minimumReleaseLevel: ReleaseLevel;
}

// @public
export type DocumentationSuiteOptions = Omit<Partial<DocumentationSuiteConfiguration>, "hierarchy"> & {
    readonly hierarchy?: HierarchyOptions;
};

// @public @sealed
export interface DocumentHierarchyConfiguration extends DocumentationHierarchyConfigurationBase {
    readonly kind: HierarchyKind.Document;
}

// @public @sealed
export class DocumentNode implements Parent<SectionNode>, DocumentNodeProps {
    constructor(properties: DocumentNodeProps);
    readonly apiItem?: ApiItem;
    readonly children: SectionNode[];
    readonly documentPath: string;
    readonly type = "document";
}

// @public
export interface DocumentNodeProps {
    readonly apiItem?: ApiItem;
    readonly children: SectionNode[];
    readonly documentPath: string;
}

// @public
export function documentToHtml(document: DocumentNode, config: ToHtmlConfiguration): Root;

// @public
export function documentToMarkdown(document: DocumentNode, config: ToMarkdownConfiguration): Root_2;

// @public
export interface DocumentWriter {
    decreaseIndent(): void;
    ensureNewLine(): void;
    ensureSkippedLine(): void;
    getText(): string;
    increaseIndent(indentPrefix?: string): void;
    peekLastCharacter(): string;
    peekSecondLastCharacter(): string;
    write(message: string): void;
    writeLine(message?: string): void;
}

// @public
export namespace DocumentWriter {
    export function create(): DocumentWriter;
}

// @public
export interface FileSystemConfiguration {
    readonly newlineKind?: NewlineKind;
    readonly outputDirectoryPath: string;
}

// @public
function filterItems(apiItems: readonly ApiItem[], config: ApiItemTransformationConfiguration): ApiItem[];

// @public
export enum FolderDocumentPlacement {
    Inside = "Inside",
    Outside = "Outside"
}

// @public @sealed
export interface FolderHierarchyConfiguration extends DocumentationHierarchyConfigurationBase {
    readonly documentPlacement: FolderDocumentPlacement;
    readonly kind: HierarchyKind.Folder;
}

// @public
export function getApiItemTransformationConfigurationWithDefaults(options: ApiItemTransformationOptions): ApiItemTransformationConfiguration;

// @public
function getCustomBlockComments(apiItem: ApiItem): ReadonlyMap<string, readonly DocSection[]>;

// @public
function getDefaultValueBlock(apiItem: ApiItem, logger?: Logger): DocSection | undefined;

// @public
function getDeprecatedBlock(apiItem: ApiItem): DocSection | undefined;

// @public
function getEffectiveReleaseLevel(apiItem: ApiItem): ReleaseLevel;

// @public
function getExampleBlocks(apiItem: ApiItem): readonly DocSection[] | undefined;

// @public
function getFileSafeNameForApiItem(apiItem: ApiItem): string;

// @public
function getHeadingForApiItem(apiItem: ApiItem, config: ApiItemTransformationConfiguration, headingLevel?: number): Heading;

// @public
function getLinkForApiItem(apiItem: ApiItem, config: ApiItemTransformationConfiguration, textOverride?: string): Link;

// @public
function getModifiers(apiItem: ApiItem, modifiersToOmit?: ApiModifier[]): ApiModifier[];

// @public
function getModifierTags(apiItem: ApiItem): ReadonlySet<string>;

// @public
function getReturnsBlock(apiItem: ApiItem): DocSection | undefined;

// @public
function getSeeBlocks(apiItem: ApiItem): readonly DocSection[] | undefined;

// @public
function getSingleLineExcerptText(excerpt: Excerpt): string;

// @public
function getThrowsBlocks(apiItem: ApiItem): readonly DocSection[] | undefined;

// @public
function getUnscopedPackageName(apiPackage: ApiPackage): string;

// @public
function hasModifierTag(apiItem: ApiItem, tagName: string): boolean;

// @public
export interface Heading {
    readonly id?: string;
    readonly level?: number;
    readonly title: string;
}

// @public @sealed
export class HeadingNode implements DocumentationNode, Heading {
    constructor(
    title: string,
    id?: string | undefined);
    static createFromPlainTextHeading(heading: Heading): HeadingNode;
    readonly id?: string | undefined;
    readonly title: string;
    readonly type = "heading";
}

// @public
export type HierarchyConfiguration = {
    /**
    * Hierarchy configuration for the API item kind.
    */
    readonly [Kind in Exclude<ValidApiItemKind, ApiItemKind.Model | ApiItemKind.EntryPoint | ApiItemKind.Package>]: DocumentationHierarchyConfiguration;
} & {
    readonly [ApiItemKind.Model]: DocumentHierarchyConfiguration;
    readonly [ApiItemKind.Package]: DocumentHierarchyConfiguration | FolderHierarchyConfiguration;
    readonly [ApiItemKind.EntryPoint]: DocumentHierarchyConfiguration;
    readonly getDocumentName: (apiItem: ApiItem, config: HierarchyConfiguration) => string;
    readonly getFolderName: (apiItem: ApiItem, config: HierarchyConfiguration) => string;
};

// @public
export enum HierarchyKind {
    Document = "Document",
    Folder = "Folder",
    Section = "Section"
}

// @public
export type HierarchyOptions = {
    /**
    * Hierarchy configuration for the API item kind.
    */
    readonly [Kind in Exclude<ValidApiItemKind, ApiItemKind.Model | ApiItemKind.EntryPoint | ApiItemKind.Package>]?: HierarchyKind | DocumentationHierarchyConfiguration;
} & {
    readonly [ApiItemKind.Model]?: HierarchyKind.Document | DocumentHierarchyConfiguration;
    readonly [ApiItemKind.Package]?: HierarchyKind.Document | HierarchyKind.Folder | DocumentHierarchyConfiguration | FolderHierarchyConfiguration;
    readonly [ApiItemKind.EntryPoint]?: HierarchyKind.Document | DocumentHierarchyConfiguration;
    readonly getDocumentName?: (apiItem: ApiItem, config: HierarchyConfiguration) => string;
    readonly getFolderName?: (apiItem: ApiItem, config: HierarchyConfiguration) => string;
};

declare namespace HtmlRenderer {
    export {
        RenderApiModelAsHtmlOptions as RenderApiModelOptions,
        renderApiModelAsHtml as renderApiModel,
        RenderDocumentsAsHtmlOptions as RenderDocumentsOptions,
        renderDocumentsAsHtml as renderDocuments,
        renderDocument,
        renderHtml
    }
}
export { HtmlRenderer }

// @public
function isDeprecated(apiItem: ApiItem): boolean;

// @public
function isOptional(apiItem: ApiItem): boolean;

// @public
function isReadonly(apiItem: ApiItem): boolean;

// @public
function isStatic(apiItem: ApiItem): boolean;

declare namespace LayoutUtilities {
    export {
        createBreadcrumbParagraph,
        createDeprecationNoticeSection,
        createExamplesSection,
        createParametersSection,
        createRemarksSection,
        createReturnsSection,
        createSeeAlsoSection,
        createSignatureSection,
        createSummarySection,
        createThrowsSection,
        createTypeParametersSection
    }
}
export { LayoutUtilities }

// @public
export interface Link {
    readonly target: UrlTarget;
    readonly text: string;
}

// @beta
export function lintApiModel(configuration: LintApiModelConfiguration): Promise<LinterErrors | undefined>;

// @beta
export interface LintApiModelConfiguration extends LoggingConfiguration {
    readonly apiModel: ApiModel;
}

// @beta
export interface LinterErrors {
    readonly referenceErrors: ReadonlySet<LinterReferenceError>;
}

// @beta
export interface LinterReferenceError {
    readonly linkText: string | undefined;
    readonly packageName: string;
    readonly referenceTarget: string;
    readonly sourceItem: string;
    readonly tagName: string;
}

// @public @sealed
export class ListItemNode extends DocumentationParentNodeBase<PhrasingContent> {
    constructor(children: PhrasingContent[]);
    static createFromPlainText(text: string): ListItemNode;
    static readonly Empty: ListItemNode;
    readonly type = "listItem";
}

// @public @sealed
export class ListNode extends DocumentationParentNodeBase<ListItemNode> {
    constructor(children: ListItemNode[], ordered: boolean);
    static createFromPlainTextEntries(entries: string[], ordered: boolean): ListNode;
    readonly ordered: boolean;
    readonly type = "list";
}

// @public
export function loadModel(options: LoadModelOptions): Promise<ApiModel>;

// @public
export interface LoadModelOptions extends LoggingConfiguration {
    readonly modelDirectoryPath: string;
}

// @public
export interface Logger {
    error: LoggingFunction;
    info: LoggingFunction;
    success: LoggingFunction;
    verbose: LoggingFunction;
    warning: LoggingFunction;
}

// @public
export interface LoggingConfiguration {
    readonly logger?: Logger;
}

// @public
export type LoggingFunction = (message: string | Error, ...parameters: unknown[]) => void;

// @public @sealed
export class MarkdownBlockContentNode extends DocumentationLiteralNodeBase<BlockContent_2> {
    constructor(value: BlockContent_2);
    readonly type = "markdownBlockContent";
}

declare namespace MarkdownRenderer {
    export {
        RenderApiModelAsMarkdownOptions as RenderApiModelOptions,
        renderApiModelAsMarkdown as renderApiModel,
        RenderDocumentsAsMarkdownOptions as RenderDocumentsOptions,
        renderDocumentsAsMarkdown as renderDocuments,
        renderDocument_2 as renderDocument,
        RenderDocumentAsMarkdownConfiguration,
        renderMarkdown
    }
}
export { MarkdownRenderer }

export { NewlineKind }

// @public
export type ReleaseLevel = Exclude<ReleaseTag, ReleaseTag.None>;

export { ReleaseTag }

// @public
function renderApiModelAsMarkdown(options: RenderApiModelAsMarkdownOptions): Promise<void>;

// @public
interface RenderApiModelAsMarkdownOptions extends ApiItemTransformationOptions, RenderDocumentAsMarkdownConfiguration, FileSystemConfiguration {
}

// @public
function renderDocument(document: DocumentNode, config: RenderDocumentAsHtmlConfiguration): string;

// @public
function renderDocument_2(document: DocumentNode, config: RenderDocumentAsMarkdownConfiguration): string;

// @public @sealed
export interface RenderDocumentAsHtmlConfiguration extends ToHtmlConfiguration, RenderHtmlConfiguration {
}

// @public @sealed
export interface RenderDocumentAsMarkdownConfiguration extends ToMarkdownConfiguration, RenderMarkdownConfiguration {
}

// @public
function renderDocumentsAsMarkdown(documents: readonly DocumentNode[], options: RenderDocumentsAsMarkdownOptions): Promise<void>;

// @public
interface RenderDocumentsAsMarkdownOptions extends RenderDocumentAsMarkdownConfiguration, FileSystemConfiguration {
}

// @public
function renderHtml(html: Nodes, config: RenderHtmlConfiguration): string;

// @public @sealed
export interface RenderHtmlConfiguration {
    readonly prettyFormatting?: boolean;
}

// @public
function renderMarkdown(tree: Nodes_2, config: RenderMarkdownConfiguration): string;

// @public @sealed
export interface RenderMarkdownConfiguration {
    readonly mdastToMarkdownOptions?: Partial<Options>;
}

// @public
export type SectionContent = BlockContent | SectionNode;

// @public
export function sectionContentToMarkdown(node: SectionContent, context: ToMarkdownContext): RootContent[];

// @public @sealed
export interface SectionHierarchyConfiguration extends DocumentationHierarchyConfigurationBase {
    readonly kind: HierarchyKind.Section;
}

// @public @sealed
export class SectionNode extends DocumentationParentNodeBase<SectionContent> {
    constructor(children: SectionContent[], heading?: HeadingNode);
    static readonly Empty: SectionNode;
    readonly heading?: HeadingNode;
    readonly type = "section";
}

// @public
function shouldItemBeIncluded(apiItem: ApiItem, config: ApiItemTransformationConfiguration): boolean;

// @public @sealed
export class TableBodyCellNode extends TableCellNode {
    constructor(children: TableCellContent[]);
    static createFromPlainText(text: string): TableBodyCellNode;
    static readonly Empty: TableBodyCellNode;
}

// @public @sealed
export class TableBodyRowNode extends TableRowNode {
    constructor(cells: TableCellNode[]);
    static readonly Empty: TableBodyRowNode;
}

// @public
export type TableCellContent = PhrasingContent | BlockContent;

// @public
export enum TableCellKind {
    Body = "Body",
    Header = "Header"
}

// @public @sealed
export abstract class TableCellNode extends DocumentationParentNodeBase<TableCellContent> {
    protected constructor(children: TableCellContent[], cellKind: TableCellKind);
    readonly cellKind: TableCellKind;
    readonly type = "tableCell";
}

// @public @sealed
export class TableHeaderCellNode extends TableCellNode {
    constructor(children: TableCellContent[]);
    static createFromPlainText(text: string): TableHeaderCellNode;
    static readonly Empty: TableHeaderCellNode;
}

// @public @sealed
export class TableHeaderRowNode extends TableRowNode {
    constructor(cells: TableHeaderCellNode[]);
    static readonly Empty: TableHeaderRowNode;
}

// @public @sealed
export class TableNode extends DocumentationParentNodeBase<TableBodyRowNode> {
    constructor(bodyRows: TableBodyRowNode[], headingRow?: TableHeaderRowNode);
    static readonly Empty: TableNode;
    readonly headerRow?: TableHeaderRowNode;
    readonly type = "table";
}

// @public
export enum TableRowKind {
    Body = "Body",
    Header = "Header"
}

// @public @sealed
export abstract class TableRowNode extends DocumentationParentNodeBase<TableCellNode> {
    protected constructor(cells: TableCellNode[], rowKind: TableRowKind);
    readonly rowKind: TableRowKind;
    readonly type = "tableRow";
}

// @public
export interface ToHtmlConfiguration extends LoggingConfiguration {
    readonly customTransformations?: ToHtmlTransformations;
    readonly language?: string;
    readonly startingHeadingLevel?: number;
}

// @public
export interface ToHtmlContext {
    readonly headingLevel: number;
    readonly logger: Logger;
    readonly transformations: ToHtmlTransformations;
}

// @public
export type ToHtmlTransformation = (node: DocumentationNode, context: ToHtmlContext) => Nodes;

// @public
export interface ToHtmlTransformations {
    readonly [documentationNodeKind: string]: ToHtmlTransformation;
}

// @public
export interface ToMarkdownConfiguration extends LoggingConfiguration {
    readonly customTransformations?: Partial<ToMarkdownTransformations>;
    readonly startingHeadingLevel?: number;
}

// @public
export interface ToMarkdownContext {
    readonly headingLevel: number;
    readonly logger: Logger;
    readonly transformations: ToMarkdownTransformations;
}

// @public
export type ToMarkdownTransformation<TIn extends DocumentationNode = DocumentationNode, TOut extends Nodes_2[] = [Nodes_2]> = (node: TIn, context: ToMarkdownContext) => TOut;

// @public
export type ToMarkdownTransformations = BlockContentToMarkdownTransformations & {
    readonly ["heading"]: ToMarkdownTransformation<HeadingNode, BlockContent_2[]>;
    readonly ["listItem"]: ToMarkdownTransformation<ListItemNode, [ListItem]>;
    readonly ["section"]: ToMarkdownTransformation<SectionNode, RootContent[]>;
    readonly ["tableCell"]: ToMarkdownTransformation<TableCellNode, [TableCell]>;
    readonly ["tableRow"]: ToMarkdownTransformation<TableRowNode, [TableRow]>;
};

// @public
export type TransformApiItemWithChildren<TApiItem extends ApiItem> = (apiItem: TApiItem, config: ApiItemTransformationConfiguration, generateChildSection: (apiItem: ApiItem) => SectionNode[]) => SectionNode[];

// @public
export type TransformApiItemWithoutChildren<TApiItem extends ApiItem> = (apiItem: TApiItem, config: ApiItemTransformationConfiguration) => SectionNode[];

// @public
export function transformApiModel(options: ApiItemTransformationOptions): DocumentNode[];

// @public
export function transformTsdoc(node: DocSection, contextApiItem: ApiItem, config: ApiItemTransformationConfiguration): MarkdownBlockContentNode[];

// @public
export type UrlTarget = string;

// @public
export type ValidApiItemKind = Exclude<ApiItemKind, ApiItemKind.None>;

// @public
export const verboseConsoleLogger: Logger;

```
