## API Report File for "@fluid-tools/api-markdown-documenter"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ApiCallSignature } from '@microsoft/api-extractor-model';
import { ApiClass } from '@microsoft/api-extractor-model';
import { ApiConstructor } from '@microsoft/api-extractor-model';
import { ApiConstructSignature } from '@microsoft/api-extractor-model';
import { ApiEnum } from '@microsoft/api-extractor-model';
import { ApiEnumMember } from '@microsoft/api-extractor-model';
import { ApiFunction } from '@microsoft/api-extractor-model';
import { ApiIndexSignature } from '@microsoft/api-extractor-model';
import { ApiInterface } from '@microsoft/api-extractor-model';
import { ApiItem } from '@microsoft/api-extractor-model';
import { ApiItemKind } from '@microsoft/api-extractor-model';
import { ApiMethod } from '@microsoft/api-extractor-model';
import { ApiMethodSignature } from '@microsoft/api-extractor-model';
import { ApiModel } from '@microsoft/api-extractor-model';
import { ApiNamespace } from '@microsoft/api-extractor-model';
import { ApiPackage } from '@microsoft/api-extractor-model';
import { ApiPropertyItem } from '@microsoft/api-extractor-model';
import { ApiTypeAlias } from '@microsoft/api-extractor-model';
import { ApiVariable } from '@microsoft/api-extractor-model';
import type { Data } from 'unist';
import { DocSection } from '@microsoft/tsdoc';
import { IndentedWriter as DocumentWriter } from '@microsoft/api-documenter/lib/utils/IndentedWriter';
import type { Literal } from 'unist';
import { NewlineKind } from '@rushstack/node-core-library';
import type { Node as Node_2 } from 'unist';
import type { Parent } from 'unist';

// @public
export enum AlertKind {
    // (undocumented)
    Danger = "Danger",
    // (undocumented)
    Important = "Important",
    // (undocumented)
    Note = "Note",
    // (undocumented)
    Tip = "Tip",
    // (undocumented)
    Warning = "Warning"
}

// Warning: (ae-forgotten-export) The symbol "ParentNodeBase" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class AlertNode extends ParentNodeBase {
    constructor(children: DocumentationNode[], alertKind: AlertKind, title?: string);
    readonly alertKind: AlertKind;
    static createFromPlainText(text: string, alertKind: AlertKind, title?: string): AlertNode;
    // (undocumented)
    readonly title?: string;
    readonly type = DocumentationNodeType.Alert;
}

// @public
export type ApiFunctionLike = ApiConstructSignature | ApiConstructor | ApiFunction | ApiMethod | ApiMethodSignature;

export { ApiItem }

export { ApiItemKind }

// @public
export interface ApiItemTransformationConfiguration {
    createChildContentSections?: CreateChildContentSections;
    transformApiCallSignature?: TransformApiItemWithoutChildren<ApiCallSignature>;
    transformApiClass?: TransformApiItemWithChildren<ApiClass>;
    transformApiConstructor?: TransformApiItemWithoutChildren<ApiConstructSignature | ApiConstructor>;
    transformApiEnum?: TransformApiItemWithChildren<ApiEnum>;
    transformApiEnumMember?: TransformApiItemWithoutChildren<ApiEnumMember>;
    transformApiFunction?: TransformApiItemWithoutChildren<ApiFunction>;
    transformApiIndexSignature?: TransformApiItemWithoutChildren<ApiIndexSignature>;
    transformApiInterface?: TransformApiItemWithChildren<ApiInterface>;
    transformApiMethod?: TransformApiItemWithoutChildren<ApiMethod | ApiMethodSignature>;
    transformApiModel?: TransformApiItemWithoutChildren<ApiModel>;
    transformApiNamespace?: TransformApiItemWithChildren<ApiNamespace>;
    transformApiPackage?: TransformApiItemWithChildren<ApiPackage>;
    transformApiProperty?: TransformApiItemWithoutChildren<ApiPropertyItem>;
    transformApiTypeAlias?: TransformApiItemWithoutChildren<ApiTypeAlias>;
    transformApiVariable?: TransformApiItemWithoutChildren<ApiVariable>;
}

// @public
export type ApiMemberKind = Omit<ApiItemKind, ApiItemKind.EntryPoint | ApiItemKind.Model | ApiItemKind.None | ApiItemKind.Package>;

export { ApiModel }

// @public
export enum ApiModifier {
    Optional = "optional",
    Readonly = "readonly",
    Sealed = "sealed",
    Static = "static",
    Virtual = "virtual"
}

// @public
export type ApiModuleLike = ApiPackage | ApiNamespace;

export { ApiPackage }

// @public
export type ApiSignatureLike = ApiCallSignature | ApiIndexSignature;

// @public
export class BlockQuoteNode extends ParentNodeBase {
    constructor(children: DocumentationNode[]);
    static createFromPlainText(text: string): BlockQuoteNode;
    static readonly Empty: BlockQuoteNode;
    readonly type = DocumentationNodeType.BlockQuote;
}

// @public
export class CodeSpanNode extends ParentNodeBase<SingleLineElementNode> implements SingleLineElementNode {
    constructor(children: SingleLineElementNode[]);
    static createFromPlainText(text: string): CodeSpanNode;
    static readonly Empty: CodeSpanNode;
    readonly type = DocumentationNodeType.CodeSpan;
}

// @public
export type CreateChildContentSections = (apiItem: ApiItem, childSections: SectionNode[] | undefined, config: Required<MarkdownDocumenterConfiguration>) => SectionNode[];

// @public
export function createDocuments(partialConfig: MarkdownDocumenterConfiguration): DocumentNode[];

// @public
export const defaultApiItemTransformations: Required<ApiItemTransformationConfiguration>;

// @public
export const defaultConsoleLogger: Logger;

// @public (undocumented)
export namespace DefaultPolicies {
    const defaultDocumentBoundaries: ApiMemberKind[];
    const defaultHierarchyBoundaries: ApiMemberKind[];
    export function defaultFileNamePolicy(apiItem: ApiItem): string;
    export function defaultHeadingTitlePolicy(apiItem: ApiItem): string;
    export function defaultLinkTextPolicy(apiItem: ApiItem): string;
    export function defaultPackageFilterPolicy(): boolean;
    export function defaultUriBaseOverridePolicy(): string | undefined;
}

// @public
export const defaultPolicyOptions: Required<PolicyOptions>;

// @public
export interface DocumentationNode<TData extends object = Data> extends Node_2<TData> {
    readonly type: string;
}

// @public
export enum DocumentationNodeType {
    // (undocumented)
    Alert = "Alert",
    // (undocumented)
    BlockQuote = "BlockQuote",
    // (undocumented)
    CodeSpan = "CodeSpan",
    // (undocumented)
    Document = "Document",
    // (undocumented)
    FencedCode = "FencedCode",
    // (undocumented)
    Heading = "Heading",
    // (undocumented)
    HorizontalRule = "HorizontalRule",
    // (undocumented)
    LineBreak = "LineBreak",
    // (undocumented)
    Link = "Link",
    // (undocumented)
    OrderedList = "OrderedList",
    // (undocumented)
    Paragraph = "Paragraph",
    // (undocumented)
    PlainText = "PlainText",
    // (undocumented)
    Section = "Section",
    // (undocumented)
    Span = "Span",
    // (undocumented)
    Table = "Table",
    // (undocumented)
    TableCell = "TableCell",
    // (undocumented)
    TableRow = "TableRow",
    // (undocumented)
    UnorderedList = "UnorderedList"
}

// @public
export type DocumentBoundaries = ApiMemberKind[];

// Warning: (ae-forgotten-export) The symbol "DocumentNodeProps" needs to be exported by the entry point index.d.ts
//
// @public
export class DocumentNode implements Parent<SectionNode>, DocumentNodeProps {
    constructor(props: DocumentNodeProps);
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: The package "@fluid-tools/api-markdown-documenter" does not have an export "DocumentNodeProps"
    //
    // (undocumented)
    readonly children: SectionNode[];
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: The package "@fluid-tools/api-markdown-documenter" does not have an export "DocumentNodeProps"
    //
    // (undocumented)
    readonly filePath: string;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: The package "@fluid-tools/api-markdown-documenter" does not have an export "DocumentNodeProps"
    //
    // (undocumented)
    readonly footer?: ParagraphNode;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: The package "@fluid-tools/api-markdown-documenter" does not have an export "DocumentNodeProps"
    //
    // (undocumented)
    readonly frontMatter?: string;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: The package "@fluid-tools/api-markdown-documenter" does not have an export "DocumentNodeProps"
    //
    // (undocumented)
    readonly header?: ParagraphNode;
    readonly type = DocumentationNodeType.Document;
}

export { DocumentWriter }

// @public
export function doesItemGenerateHierarchy(apiItem: ApiItem, hierarchyBoundaries: HierarchyBoundaries): boolean;

// @public
export function doesItemKindGenerateHierarchy(kind: ApiItemKind, hierarchyBoundaries: HierarchyBoundaries): boolean;

// @public
export function doesItemKindRequireOwnDocument(kind: ApiItemKind, documentBoundaries: DocumentBoundaries): boolean;

// @public
export function doesItemRequireOwnDocument(apiItem: ApiItem, documentBoundaries: DocumentBoundaries): boolean;

// @public
export type FencedCodeBlockChildren = LineBreakNode | SingleLineElementNode;

// @public (undocumented)
export class FencedCodeBlockNode extends ParentNodeBase<FencedCodeBlockChildren> {
    constructor(children: FencedCodeBlockChildren[], language?: string);
    static createFromPlainText(text: string, language?: string): FencedCodeBlockNode;
    readonly language?: string;
    readonly type = DocumentationNodeType.FencedCode;
}

// @public
export type FileNamePolicy = (apiItem: ApiItem) => string;

// @public
export function filterByKind(apiItems: readonly ApiItem[], kinds: ApiItemKind[]): ApiItem[];

// @public
export function getAncestralHierarchy(apiItem: ApiItem, includePredecate: (apiItem: ApiItem) => boolean, breakPredicate?: (apiItem: ApiItem) => boolean): ApiItem[];

// @public
export function getDefaultValueBlock(apiItem: ApiItem, config: Required<MarkdownDocumenterConfiguration>): DocSection | undefined;

// @public
export function getDeprecatedBlock(apiItem: ApiItem): DocSection | undefined;

// @public
export function getExampleBlocks(apiItem: ApiItem): DocSection[] | undefined;

// @public
export function getFileNameForApiItem(apiItem: ApiItem, config: Required<MarkdownDocumenterConfiguration>, includeExtension: boolean): string;

// @public
export function getFilePathForApiItem(apiItem: ApiItem, config: Required<MarkdownDocumenterConfiguration>): string;

// @public
export function getFilteredParent(apiItem: ApiItem): ApiItem | undefined;

// @public
export function getFirstAncestorWithOwnDocument(apiItem: ApiItem, documentBoundaries: DocumentBoundaries): ApiItem;

// @public
export function getHeadingForApiItem(apiItem: ApiItem, config: Required<MarkdownDocumenterConfiguration>, headingLevel?: number): Heading;

// @public
export function getHeadingIdForApiItem(apiItem: ApiItem, config: Required<MarkdownDocumenterConfiguration>): string;

// @public
export function getLinkForApiItem(apiItem: ApiItem, config: Required<MarkdownDocumenterConfiguration>, textOverride?: string): Link;

// @public
export function getLinkUrlForApiItem(apiItem: ApiItem, config: Required<MarkdownDocumenterConfiguration>): string;

// @public
export function getModifiers(apiItem: ApiItem, modifiersToOmit?: ApiModifier[]): ApiModifier[];

// @public
export function getQualifiedApiItemName(apiItem: ApiItem): string;

// @public
export function getReturnsBlock(apiItem: ApiItem): DocSection | undefined;

// @public
export function getSeeBlocks(apiItem: ApiItem): DocSection[] | undefined;

// @public
export function getThrowsBlocks(apiItem: ApiItem): DocSection[] | undefined;

// @public
export function getUnscopedPackageName(apiPackage: ApiPackage): string;

// @public
export interface Heading {
    readonly id?: string;
    readonly level?: number;
    readonly title: string;
}

// @public (undocumented)
export class HeadingNode extends ParentNodeBase<SingleLineElementNode> implements Omit<Heading, "title"> {
    constructor(content: SingleLineElementNode[], id?: string);
    static createFromPlainText(text: string, id?: string): HeadingNode;
    static createFromPlainTextHeading(heading: Heading): HeadingNode;
    readonly id?: string;
    readonly type = DocumentationNodeType.Heading;
}

// @public
export type HeadingTitlePolicy = (apiItem: ApiItem) => string;

// @public
export type HierarchyBoundaries = ApiMemberKind[];

// @public
export class HorizontalRuleNode implements DocumentationNode {
    static readonly Singleton: HorizontalRuleNode;
    readonly type = DocumentationNodeType.HorizontalRule;
}

// @public
export function injectSeparator<T>(array: T[], separator: T): T[];

// @public
export function isDeprecated(apiItem: ApiItem): boolean;

// @public
export function isOptional(apiItem: ApiItem): boolean;

// @public
export function isReadonly(apiItem: ApiItem): boolean;

// @public
export function isStatic(apiItem: ApiItem): boolean;

// @public
export class LineBreakNode implements DocumentationNode {
    constructor();
    // (undocumented)
    static readonly Singleton: LineBreakNode;
    readonly type = DocumentationNodeType.LineBreak;
}

// @public
export interface Link {
    readonly target: UrlTarget;
    readonly text: string;
}

// @public (undocumented)
export class LinkNode extends ParentNodeBase<SingleLineElementNode> implements SingleLineElementNode, Omit<Link, "text"> {
    constructor(content: SingleLineElementNode[], target: UrlTarget);
    static createFromPlainText(text: string, target: UrlTarget): LinkNode;
    // (undocumented)
    static createFromPlainTextLink(link: Link): LinkNode;
    readonly target: UrlTarget;
    readonly type = DocumentationNodeType.Link;
}

// @public
export type LinkTextPolicy = (apiItem: ApiItem) => string;

// @public
export interface LiteralNode<T = unknown> extends Literal<T>, DocumentationNode {
    readonly type: string;
}

// @public
export function loadModel(reportsDirectoryPath: string, logger?: Logger): Promise<ApiModel>;

// @public
export interface Logger {
    error: LoggingFunction;
    info: LoggingFunction;
    success: LoggingFunction;
    verbose: LoggingFunction;
    warning: LoggingFunction;
}

// @public
export type LoggingFunction = (message: string | Error, ...args: unknown[]) => void;

// @public
export interface MarkdownDocumenterConfiguration extends PolicyOptions, ApiItemTransformationConfiguration {
    apiModel: ApiModel;
    readonly logger?: Logger;
    readonly newlineKind?: NewlineKind;
    readonly uriRoot: string;
}

// @public
export function markdownDocumenterConfigurationWithDefaults(partialConfig: MarkdownDocumenterConfiguration): Required<MarkdownDocumenterConfiguration>;

// @public
export interface MarkdownRenderContext extends TextFormatting {
    headingLevel: number;
    readonly insideCodeBlock: boolean;
    readonly insideHtml: boolean;
    readonly insideTable: boolean;
    // Warning: (ae-forgotten-export) The symbol "DocumentationNodeRenderers" needs to be exported by the entry point index.d.ts
    renderers: DocumentationNodeRenderers;
}

// @public (undocumented)
export class OrderedListNode extends ParentNodeBase<SingleLineElementNode> {
    constructor(children: SingleLineElementNode[]);
    // (undocumented)
    static createFromPlainTextEntries(entries: string[]): OrderedListNode;
    static readonly Empty: OrderedListNode;
    readonly type = DocumentationNodeType.OrderedList;
}

// @public
export type PackageFilterPolicy = (apiPackage: ApiPackage) => boolean;

// @public (undocumented)
export type ParagraphChildren = LineBreakNode | SingleLineElementNode | SpanNode<LineBreakNode | SingleLineElementNode>;

// @public (undocumented)
export class ParagraphNode extends ParentNodeBase<ParagraphChildren> {
    constructor(children: ParagraphChildren[]);
    static combine(...nodes: ParagraphNode[]): ParagraphNode;
    static createFromPlainText(text: string): ParagraphNode;
    static readonly Empty: ParagraphNode;
    readonly type = DocumentationNodeType.Paragraph;
}

// @public
interface ParentNode_2<TDocumentationNode extends DocumentationNode = DocumentationNode> extends Parent<TDocumentationNode, Data>, DocumentationNode {
    readonly children: TDocumentationNode[];
    get hasChildren(): boolean;
    readonly type: string;
}
export { ParentNode_2 as ParentNode }

// @public
export class PlainTextNode implements LiteralNode<string>, SingleLineElementNode {
    constructor(value: string);
    static readonly Empty: PlainTextNode;
    readonly type = DocumentationNodeType.PlainText;
    readonly value: string;
}

// @public
export interface PolicyOptions {
    documentBoundaries?: DocumentBoundaries;
    emptyTableCellText?: string;
    fileNamePolicy?: FileNamePolicy;
    headingTitlePolicy?: HeadingTitlePolicy;
    hierarchyBoundaries?: HierarchyBoundaries;
    includeBreadcrumb?: boolean;
    includeTopLevelDocumentHeading?: boolean;
    linkTextPolicy?: LinkTextPolicy;
    packageFilterPolicy?: PackageFilterPolicy;
    uriBaseOverridePolicy?: UriBaseOverridePolicy;
}

// @public
export function renderDocumentAsMarkdown(document: DocumentNode, customRenderers?: DocumentationNodeRenderers): string;

// @public
export function renderFiles(partialConfig: MarkdownDocumenterConfiguration, outputDirectoryPath: string, customRenderers?: DocumentationNodeRenderers): Promise<void>;

// @public
export function renderNodeAsMarkdown(node: DocumentationNode, writer: DocumentWriter, context: MarkdownRenderContext): void;

// @public
export function renderNodesAsMarkdown(children: DocumentationNode[], writer: DocumentWriter, childContext: MarkdownRenderContext): void;

// @public
export class SectionNode extends ParentNodeBase {
    constructor(children: DocumentationNode[], heading?: HeadingNode);
    static combine(...sections: SectionNode[]): SectionNode;
    static readonly Empty: SectionNode;
    readonly heading?: HeadingNode;
    readonly type = DocumentationNodeType.Section;
}

// @public
export type SingleLineElementNode = DocumentationNode;

// @public (undocumented)
export class SpanNode<TDocumentationNode extends DocumentationNode = DocumentationNode> extends ParentNodeBase<TDocumentationNode> {
    constructor(children: TDocumentationNode[], formatting?: TextFormatting);
    static createFromPlainText(text: string, formatting?: TextFormatting): SpanNode;
    static readonly Empty: SpanNode;
    // (undocumented)
    readonly textFormatting?: TextFormatting;
    readonly type = DocumentationNodeType.Span;
}

// @public (undocumented)
export class TableCellNode extends ParentNodeBase {
    constructor(children: DocumentationNode[]);
    static createFromPlainText(text: string): TableCellNode;
    static readonly Empty: TableCellNode;
    readonly type = DocumentationNodeType.TableCell;
}

// @public (undocumented)
export class TableNode extends ParentNodeBase<TableRowNode> {
    constructor(bodyRows: TableRowNode[], headingRow?: TableRowNode);
    static readonly Empty: TableNode;
    // (undocumented)
    readonly headingRow?: TableRowNode;
    readonly type = DocumentationNodeType.Table;
}

// @public (undocumented)
export class TableRowNode extends ParentNodeBase<TableCellNode> {
    constructor(cells: TableCellNode[]);
    static readonly Empty: TableRowNode;
    readonly type = DocumentationNodeType.TableRow;
}

// @public
export interface TextFormatting {
    // (undocumented)
    readonly bold?: boolean;
    // (undocumented)
    readonly italic?: boolean;
    // (undocumented)
    readonly strikethrough?: boolean;
}

// @public
export type TransformApiItemWithChildren<TApiItem extends ApiItem> = (apiItem: TApiItem, config: Required<MarkdownDocumenterConfiguration>, generateChildSection: (apiItem: ApiItem) => SectionNode[]) => SectionNode[];

// @public
export type TransformApiItemWithoutChildren<TApiItem extends ApiItem> = (apiItem: TApiItem, config: Required<MarkdownDocumenterConfiguration>) => SectionNode[];

// @public (undocumented)
export class UnorderedListNode extends ParentNodeBase<SingleLineElementNode> {
    constructor(children: SingleLineElementNode[]);
    // (undocumented)
    static createFromPlainTextEntries(entries: string[]): UnorderedListNode;
    static readonly Empty: UnorderedListNode;
    readonly type = DocumentationNodeType.UnorderedList;
}

// @public
export type UriBaseOverridePolicy = (apiItem: ApiItem) => string | undefined;

// @public
export type UrlTarget = string;

// @public
export const verboseConsoleLogger: Logger;

```
