/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
import { ApiItem } from "@microsoft/api-extractor-model";
import {
	DocCodeSpan,
	DocDeclarationReference,
	DocEscapedText,
	DocFencedCode,
	DocHtmlEndTag,
	DocHtmlStartTag,
	DocLinkTag,
	DocNode,
	DocNodeKind,
	DocParagraph,
	DocPlainText,
	DocSection,
} from "@microsoft/tsdoc";

import { Link } from "../Link";
import {
	CodeSpanNode,
	DocumentationNode,
	DocumentationNodeType,
	FencedCodeBlockNode,
	LineBreakNode,
	LinkNode,
	ParagraphNode,
	PlainTextNode,
	SingleLineDocumentationNode,
	SingleLineSpanNode,
} from "../documentation-domain";
import { ConfigurationBase } from "../ConfigurationBase";
import { getDocNodeTransformationOptions } from "./Utilities";
import { ApiItemTransformationConfiguration } from "./configuration";

/**
 * Library of transformations from {@link https://github.com/microsoft/tsdoc/blob/main/tsdoc/src/nodes/DocNode.ts| DocNode}s
 * to {@link DocumentationNode}s.
 */

/**
 * Converts a {@link https://github.com/microsoft/tsdoc/blob/main/tsdoc/src/nodes/DocNode.ts| DocNode} to a
 * {@link DocumentationNode}.
 *
 * @remarks
 *
 * The set of supported `DocNode` kinds here is based on what appears in `ApiItem`s generated by API-Extractor.
 * This set may need to be updated if/when API-Extractor changes its output format.
 *
 * @returns The transformed `DocNode`, if it was of a kind we support.
 * Else, an error will be logged, and `undefined` will be returned.
 */
export function transformDocNode(
	docNode: DocNode,
	contextApiItem: ApiItem,
	config: Required<ApiItemTransformationConfiguration>,
): DocumentationNode | undefined {
	const transformOptions = getDocNodeTransformationOptions(contextApiItem, config);
	return _transformDocNode(docNode, transformOptions);
}

/**
 * Options for {@link @microsoft/tsdoc#DocNode} transformations.
 */
export interface DocNodeTransformOptions extends ConfigurationBase {
	/**
	 * The API item with which the documentation node(s) are associated.
	 */
	readonly contextApiItem: ApiItem;

	/**
	 * Callback for resolving symbolic links to API items.
	 *
	 * @param codeDestination - The referenced target.
	 * @param contextApiItem -
	 *
	 * @returns The appropriate URL target if the reference can be resolved. Otherwise, `undefined`.
	 */
	readonly resolveApiReference: (codeDestination: DocDeclarationReference) => Link | undefined;
}

/**
 * Converts a {@link @microsoft/tsdoc#DocNode} to a {@link DocumentationNode}.
 *
 * @remarks
 *
 * The set of supported `DocNode` kinds here is based on what appears in `ApiItem`s generated by API-Extractor.
 * This set may need to be updated if/when API-Extractor changes its output format.
 *
 * @returns The transformed `DocNode`, if it was of a kind we support.
 * Else, an error will be logged, and `undefined` will be returned.
 */
export function _transformDocNode(
	node: DocNode,
	options: DocNodeTransformOptions,
): DocumentationNode | undefined {
	switch (node.kind) {
		case DocNodeKind.CodeSpan:
			return transformDocCodeSpan(node as DocCodeSpan, options);
		case DocNodeKind.EscapedText:
			return transformDocEscapedText(node as DocEscapedText, options);
		case DocNodeKind.FencedCode:
			return transformDocFencedCode(node as DocFencedCode, options);
		case DocNodeKind.HtmlStartTag:
			return transformDocHtmlTag(node as DocHtmlStartTag, options);
		case DocNodeKind.HtmlEndTag:
			return transformDocHtmlTag(node as DocHtmlEndTag, options);
		case DocNodeKind.LinkTag:
			return transformDocLinkTag(node as DocLinkTag, options);
		case DocNodeKind.Paragraph:
			return transformDocParagraph(node as DocParagraph, options);
		case DocNodeKind.PlainText:
			return transformDocPlainText(node as DocPlainText, options);
		case DocNodeKind.Section:
			return transformDocSection(node as DocSection, options);
		case DocNodeKind.SoftBreak:
			return LineBreakNode.Singleton;
		default:
			options.logger?.error(`Unsupported DocNode kind: "${node.kind}".`, node);
			return undefined;
	}
}

/**
 * Converts a {@link @microsoft/tsdoc#DocCodeSpan} to a {@link CodeSpanNode}.
 */
export function transformDocCodeSpan(
	node: DocCodeSpan,
	options: DocNodeTransformOptions,
): CodeSpanNode {
	return CodeSpanNode.createFromPlainText(node.code.trim());
}

/**
 * Converts a {@link @microsoft/tsdoc#DocParagraph} to a {@link ParagraphNode}.
 */
export function transformDocParagraph(
	node: DocParagraph,
	options: DocNodeTransformOptions,
): ParagraphNode {
	return createParagraph(node.nodes, options);
}

/**
 * Converts a {@link @microsoft/tsdoc#DocSection} to a {@link ParagraphNode}.
 *
 * @remarks
 *
 * We define "section" a bit differently from TSDoc's definition.
 * We align the concept of "section" with a level of hierarchy in the document, where TSDoc does not.
 * For that reason, their "section" concept gets mapped to a paragraph, rather than a section.
 * Consumers can wrap this in a section node as desired based on context.
 */
export function transformDocSection(
	node: DocSection,
	options: DocNodeTransformOptions,
): ParagraphNode {
	return createParagraph(node.nodes, options);
}

/**
 * Converts a {@link @microsoft/tsdoc#DocPlainText} to a {@link PlainTextNode}.
 */
export function transformDocPlainText(
	node: DocPlainText,
	options: DocNodeTransformOptions,
): PlainTextNode {
	return new PlainTextNode(node.text);
}

/**
 * Converts a {@link @microsoft/tsdoc#DocEscapedText} to a {@link PlainTextNode}.
 */
export function transformDocEscapedText(
	node: DocEscapedText,
	options: DocNodeTransformOptions,
): PlainTextNode {
	return new PlainTextNode(node.encodedText, /* escaped: */ true);
}

/**
 * Converts a {@link @microsoft/tsdoc#DocHtmlStartTag} | {@link @microsoft/tsdoc#DocHtmlEndTag} to a {@link PlainTextNode}.
 */
export function transformDocHtmlTag(
	node: DocHtmlStartTag | DocHtmlEndTag,
	options: DocNodeTransformOptions,
): PlainTextNode {
	return new PlainTextNode(node.emitAsHtml(), /* escaped: */ true);
}

/**
 * Converts a {@link @microsoft/tsdoc#DocPlainText} to a {@link PlainTextNode}.
 */
export function transformDocFencedCode(
	node: DocFencedCode,
	options: DocNodeTransformOptions,
): FencedCodeBlockNode {
	return FencedCodeBlockNode.createFromPlainText(node.code.trim(), node.language);
}

/**
 * Converts a {@link @microsoft/tsdoc#DocPlainText} to a {@link PlainTextNode}.
 */
export function transformDocLinkTag(
	input: DocLinkTag,
	options: DocNodeTransformOptions,
): SingleLineDocumentationNode {
	if (input.codeDestination !== undefined) {
		const link = options.resolveApiReference(input.codeDestination);

		if (link === undefined) {
			// If the code link could not be resolved, print the unresolved text in italics.
			const linkText = input.linkText?.trim() ?? input.codeDestination.emitAsTsdoc().trim();
			return SingleLineSpanNode.createFromPlainText(linkText, { italic: true });
		} else {
			const linkText = input.linkText?.trim() ?? link.text;
			const linkTarget = link.target;
			return LinkNode.createFromPlainText(linkText, linkTarget);
		}
	}

	if (input.urlDestination !== undefined) {
		// If link text was not provided, use the name of the referenced element.
		const linkText = input.linkText ?? input.urlDestination;

		return LinkNode.createFromPlainText(linkText, input.urlDestination);
	}

	throw new Error(
		`DocLinkTag contained neither a URL destination nor a code destination, which is not expected.`,
	);
}

/**
 * Helper function for creating {@link ParagraphNode}s from input nodes that simply wrap child contents.
 *
 * Also performs the following cleanup steps:
 *
 * 1. Remove leading and trailing line breaks within the paragraph (see
 * {@link trimLeadingAndTrailingLineBreaks}).
 *
 * 2. Trim leading whitespace from first child if it is plain-text, and trim trailing whitespace from
 * last child if it is plain-text.
 *
 * 3. If there is only a single resulting child and it is a paragraph, return it rather than wrapping
 * it in another paragraph.
 */
function createParagraph(
	children: readonly DocNode[],
	options: DocNodeTransformOptions,
): ParagraphNode {
	// Note: transformChildren does some of its own cleanup on the initial transformed contents
	let transformedChildren = transformChildren(children, options);

	// Trim leading and trailing line breaks, which are effectively redundant
	transformedChildren = trimLeadingAndTrailingLineBreaks(transformedChildren);

	// Trim leading whitespace from first child if it is plain text,
	// and trim trailing whitespace from last child if it is plain text.
	if (transformedChildren.length > 0) {
		if (transformedChildren[0].type === DocumentationNodeType.PlainText) {
			transformedChildren[0] = new PlainTextNode(
				(transformedChildren[0] as PlainTextNode).value.trimStart(),
			);
		}
		if (
			transformedChildren[transformedChildren.length - 1].type ===
			DocumentationNodeType.PlainText
		) {
			transformedChildren[transformedChildren.length - 1] = new PlainTextNode(
				(
					transformedChildren[transformedChildren.length - 1] as PlainTextNode
				).value.trimEnd(),
			);
		}
	}

	// To reduce unecessary hierarchy, if the only child of this paragraph is a single paragraph,
	// return it, rather than wrapping it.
	if (
		transformedChildren.length === 1 &&
		transformedChildren[0].type === DocumentationNodeType.Paragraph
	) {
		return transformedChildren[0] as ParagraphNode;
	}

	return new ParagraphNode(transformedChildren);
}

/**
 * Transforms the provided list of child elements, and performs the following cleanup steps:
 *
 * 1. Collapses groups of adjacent newline nodes to reduce clutter.
 *
 * 2. Remove line break nodes adjacent to paragraph nodes.
 */
function transformChildren(
	children: readonly DocNode[],
	options: DocNodeTransformOptions,
): DocumentationNode[] {
	// Transform child items into Documentation domain
	const transformedChildren = children.map((child) => _transformDocNode(child, options));

	// Filter out `undefined` values resulting from transformation errors.
	let filteredChildren = transformedChildren.filter(
		(child) => child !== undefined,
	) as DocumentationNode[];

	// Collapse groups of adjacent line breaks to reduce unnecessary clutter in the output.
	filteredChildren = collapseAdjacentLineBreaks(filteredChildren);

	// Remove line breaks adjacent to paragraphs, as they are redundant
	filteredChildren = filterNewlinesAdjacentToParagraphs(filteredChildren);

	return filteredChildren;
}

/**
 * Collapses adjacent groups of 1+ line break nodes into a single line break node to reduce clutter
 * in output tree.
 */
function collapseAdjacentLineBreaks(nodes: readonly DocumentationNode[]): DocumentationNode[] {
	if (nodes.length === 0) {
		return [];
	}

	const result: DocumentationNode[] = [];
	let onNewline = false;
	for (const node of nodes) {
		if (node.type === DocumentationNodeType.LineBreak) {
			if (onNewline) {
				continue;
			} else {
				onNewline = true;
				result.push(node);
			}
		} else {
			onNewline = false;
			result.push(node);
		}
	}

	return result;
}

/**
 * Trims an line break nodes found at the beginning or end of the list.
 *
 * @remarks Useful for cleaning up {@link ParagraphNode} child contents, since leading and trailing
 * newlines are effectively redundant.
 */
function trimLeadingAndTrailingLineBreaks(
	nodes: readonly DocumentationNode[],
): DocumentationNode[] {
	if (nodes.length === 0) {
		return [];
	}

	let startIndex = 0;
	let endIndex = nodes.length - 1;

	for (const node of nodes) {
		if (node.type === DocumentationNodeType.LineBreak) {
			startIndex++;
		} else {
			break;
		}
	}

	for (let i = nodes.length - 1; i > startIndex; i--) {
		if (nodes[i].type === DocumentationNodeType.LineBreak) {
			endIndex--;
		} else {
			break;
		}
	}

	return nodes.slice(startIndex, endIndex + 1);
}

/**
 * Filters out line break nodes that are adjacent to paragraph nodes.
 * Since paragraph nodes inherently create line breaks on either side, these nodes are redundant and
 * clutter the output tree.
 */
function filterNewlinesAdjacentToParagraphs(
	nodes: readonly DocumentationNode[],
): DocumentationNode[] {
	if (nodes.length === 0) {
		return [];
	}

	const result: DocumentationNode[] = [];
	for (let i = 0; i < nodes.length; i++) {
		if (nodes[i].type === DocumentationNodeType.LineBreak) {
			const previousIsParagraph =
				i > 0 ? nodes[i - 1].type === DocumentationNodeType.Paragraph : false;
			const nextIsParagraph =
				i < nodes.length - 1
					? nodes[i + 1].type === DocumentationNodeType.Paragraph
					: false;
			if (previousIsParagraph || nextIsParagraph) {
				continue;
			}
		}
		result.push(nodes[i]);
	}
	return result;
}
