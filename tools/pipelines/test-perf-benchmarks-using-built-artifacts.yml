# Copyright (c) Microsoft Corporation and contributors. All rights reserved.
# Licensed under the MIT License.

name: $(Build.BuildId)

pr: none

resources:
  pipelines:
  - pipeline: client   # Name of the pipeline resource
    source: Build - client packages
    trigger:
      branches:
      - release/*
      - main
      - next
      - lts

trigger:
  branches:
    include:
    - release/*
    - main
    - next
    - lts
  paths:
    include:
    - tools/benchmark
    - tools/telemetry-generator
    - tools/pipelines/test-perf-benchmarks.yml  # update with this files name

parameters:
- name: taskBuild
  type: string
  default: ci:build

- name: poolBuild
  type: object
  default: Small

- name: checkoutSubmodules
  type: boolean
  default: false

- name: buildNumberInPatch
  type: string
  default: "false"

- name: tagName
  type: string
  default: client

- name: testPackage
  type: string
  default: "@fluidframework/test-end-to-end-tests"

- name: testWorkspace
  value: $(Pipeline.Workspace)/test

variables:
  # We use 'chalk' to colorize output, which auto-detects color support in the
  # running terminal.  The log output shown in Azure DevOps job runs only has
  # basic ANSI color support though, so force that in the pipeline
  - name: FORCE_COLOR
    value: 1
  - name: buildDirectory
    value: "."

stages:
  # Install / Build / Test Stage
  # end-to-end tests local server
  - stage: build
    displayName: Run tests
    jobs:
      - job: build
        displayName: Run performance tests
        pool: ${{ parameters.poolBuild }}
        variables:
          releaseBuildVar: $[variables.releaseBuild]
          toolAbsolutePath: $(Build.SourcesDirectory)/tools/telemetry-generator
          artifactPipeline: Build - client packages
          testPackageDir: '${{ parameters.testWorkspace }}/node_modules/${{ parameters.testPackage }}'
          testPackageFilePattern: ${{ replace(replace(parameters.testPackage, '@', '' ), '/', '-') }}-*.tgz
          testPackagePathPattern: $(Pipeline.Workspace)/client/pack/scoped/${{ variables.testPackageFilePattern }}

        steps:
        # Setup
        - checkout: self
          clean: true

        - task: Bash@3
          displayName: Parameters
          inputs:
            targetType: 'inline'
            script: |
              # Show all task group conditions

              echo "
              Pipeline Parameters:
                poolBuild=${{ parameters.poolBuild }}
                testPackage=${{ parameters.testPackage }}
                testWorkspace=${{ parameters.testWorkspace }}

              Task Variables:
                releaseBuild=$(releaseBuildVar)
                toolAbsolutePath=$(toolAbsolutePath)
                artifactPipeline=$(artifactPipeline)
                testPackageDir=$(testPackageDir)
                testPackageFilePattern=$(testPackageFilePattern)
                testPackagePathPattern=$(testPackagePathPattern)

              Pipeline Parameters:
                BuildDir=${{ variables.buildDirectory }}
                Build=${{ parameters.taskBuild }}
              "

        # Install
        - task: UseNode@1
          displayName: Use Node 14.x
          inputs:
            version: 14.x

        # Download package artifacts
        - task: DownloadPipelineArtifact@2
          displayName: Download test package
          inputs:
            source: specific
            project: internal
            pipeline: ${{ variables.artifactPipeline }}
            preferTriggeringPipeline: true
            allowPartiallySucceededBuilds: true
            runVersion: latestFromBranch
            runBranch: $(Build.SourceBranch)
            artifact: pack
            patterns: "**/${{ variables.testPackageFilePattern }}"
            path: $(Pipeline.Workspace)/client/pack

        - task: Bash@3
          displayName: Create test directory
          inputs:
            targetType: 'inline'
            script: |
              mkdir ${{ parameters.testWorkspace }}

        - task: Bash@3
          name: Initialize
          displayName: Initialize
          inputs:
            targetType: 'inline'
            workingDirectory: ${{ parameters.testWorkspace }}
            script: |
              echo Initialize package
              npm init --yes

              echo Generating .npmrc
              echo "registry=https://registry.npmjs.org" >> ./.npmrc
              echo "always-auth=false" >> ./.npmrc

              echo "@ff-internal:registry=https://pkgs.dev.azure.com/fluidframework/internal/_packaging/build/npm/registry/" >> ./.npmrc
              echo "@microsoft:registry=https://office.pkgs.visualstudio.com/_packaging/Office/npm/registry/" >> ./.npmrc
              echo "always-auth=true" >> ./.npmrc
              cat .npmrc

              if [[ `ls -1 ${{ variables.testPackagePathPattern }} | wc -l` -eq 1 ]]; then
                echo "##vso[task.setvariable variable=testPackageTgz;isOutput=true]`ls ${{ variables.testPackagePathPattern }}`"
              else
                ls -1 ${{ variables.testPackagePathPattern }}
                echo "##vso[task.logissue type=error]Test package '${{ parameters.testPackage }}' not found, or there are more then one found"
              fi

        # Install test and logger package
        - task: Npm@1
          displayName: 'npm install'
          inputs:
            command: 'custom'
            workingDir: ${{ parameters.testWorkspace }}
            customCommand: 'install $(Initialize.testPackageTgz)'
            customRegistry: 'useNpmrc'

        # Download Test Files
        # Download Artifact - Test Files
        - task: DownloadPipelineArtifact@2
          displayName: Download test files
          inputs:
            source: specific
            project: internal
            pipeline: ${{ variables.artifactPipeline }}
            preferTriggeringPipeline: true
            allowPartiallySucceededBuilds: true
            runVersion: latestFromBranch
            runBranch: $(Build.SourceBranch)
            artifact: test-files
            path: $(Pipeline.Workspace)/test-files

        # Unpack test files
        - task: Bash@3
          displayName: Unpack test files
          inputs:
            targetType: 'inline'
            script: |
              mkdir ${{ parameters.testWorkspace }}/node_modules/${{ parameters.testPackage }}/dist/test
              tar -xvf $(Pipeline.Workspace)/test-files/${{ parameters.testFileTarName }}.test-files.tar -C $(Pipeline.Workspace)/test-files
              mv $(Pipeline.Workspace)/test-files/test/* ${{ parameters.testWorkspace }}/node_modules/${{ parameters.testPackage }}/dist/test

        # Run performance tests
        # - Add custom npm feeds to the tool's .npmrc file
        # - Authenticate to the custom npm feeds
        # - Install the aria-logger package from the custom npm feeds
        # - Run execution-time tests
        # - Run memory-usage tests
        # - Process output files and send telemetry to Kusto
        - task: Bash@3
          displayName: 'Add custom feeds to .npmrc'
          inputs:
            targetType: 'inline'
            workingDirectory: $(toolAbsolutePath)
            script: |
              echo "Adding custom npm feeds to .npmrc"
              cat << EOF >> .npmrc
                registry=https://registry.npmjs.org
                always-auth=false
                @ff-internal:registry=https://pkgs.dev.azure.com/fluidframework/internal/_packaging/build/npm/registry/
                @microsoft:registry=https://office.pkgs.visualstudio.com/_packaging/Office/npm/registry/
                always-auth=true
              EOF
              echo "Contents of .npmrc:"
              cat .npmrc

        - task: npmAuthenticate@0
          displayName: 'npm authenticate (internal feed)'
          inputs:
            workingFile: ${{ parameters.testWorkspace }}/.npmrc

        - task: npmAuthenticate@0
          displayName: 'npm authenticate (office feed)'
          inputs:
            workingFile: ${{ parameters.testWorkspace }}/.npmrc
            customEndpoint: 'Office Packages - Readonly'

        - task: Npm@1
          displayName: 'Install @ff-internal/aria-logger'
          inputs:
            command: 'custom'
            workingDir: ${{ parameters.testWorkspace }}
            customCommand: 'install @ff-internal/aria-logger'
            customRegistry: 'useNpmrc'

        - task: Npm@1
          displayName: 'Run performance test - execution time'
          inputs:
            command: 'custom'
            workingDir: ${{ parameters.testWorkspace }}/node_modules/${{ parameters.testPackage }}
            customCommand: 'run test:benchmark:report'

        - task: Npm@1
          displayName: 'Consolidate output files - execution time'
          inputs:
            command: 'custom'
            workingDir: ${{ variables.buildDirectory }}
            customCommand: 'run test:benchmark:copyresults' # grab this script and write it as a bash file and then manually call that script
        # modification is probably "look at node_modules for blah"
        - task: Bash@3
          displayName: 'Write measurements to Aria/Kusto - execution time'
          inputs:
            targetType: 'inline'
            workingDirectory: $(toolAbsolutePath)
            script: |
              npm i;
              npm run build:compile;
              node --require @ff-internal/aria-logger bin/run --handlerModule $(toolAbsolutePath)/dist/handlers/executionTimeTestHandler.js --dir '../../benchmarkOutput';

        - task: PublishPipelineArtifact@1
          displayName: 'Publish Artifact - Perf tests output - execution time'
          inputs:
            targetPath: '${{ variables.buildDirectory }}/benchmarkOutput'
            artifactName: 'perf-test-outputs_execution-time'
            condition: succeededOrFailed()

        - task: Npm@1
          displayName: 'Run performance test - memory usage'
          inputs:
            command: 'custom'
            workingDir: ${{ variables.buildDirectory }}
            customCommand: 'run test:memory-profiling:report'

        - task: Npm@1
          displayName: 'Consolidate output files - memory usage'
          inputs:
            command: 'custom'
            workingDir: ${{ variables.buildDirectory }}
            customCommand: 'run test:memory-profiling:copyresults'

        - task: Bash@3
          displayName: 'Write measurements to Aria/Kusto - memory usage'
          inputs:
            targetType: 'inline'
            workingDirectory: $(toolAbsolutePath)
            script: |
              npm i;
              npm run build:compile;
              node --require @ff-internal/aria-logger bin/run --handlerModule $(toolAbsolutePath)/dist/handlers/memoryUsageTestHandler.js --dir '../../memoryProfilingOutput';

        - task: PublishPipelineArtifact@1
          displayName: 'Publish Artifact - Perf tests output - memory usage'
          inputs:
            targetPath: '${{ variables.buildDirectory }}/memoryProfilingOutput'
            artifactName: 'perf-test-outputs_memory-usage'
            condition: succeededOrFailed()
