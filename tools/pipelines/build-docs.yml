# Copyright (c) Microsoft Corporation and contributors. All rights reserved.
# Licensed under the MIT License.

# build-docs pipeline
# This pipeline builds the main branch docs as well as previous major release branch docs each time the client packages are built.
# Note that the method for getting the api json for main differs from previous versions. For main, the pipeline bundles
# the published artifacts from other pipeline resources and publishes an artifact to the pipeline which can be later downloaded.
# However, for previous version branches (in this case: 1.0) cannot run on the pipeline to generate resources. Thus, api-extractor
# was run on 1.0 locally and manually published to the azure storage as "lts-1.0.tar.gz" which is later downloaded using
# the AzureCLI@2 task.
# For now, the only previous version which is manually uploaded is lts. However, for any previous versions which cannot run on the
# pipeline, we assume that the api json content would be uploaded to the azure storage in the format: latest-${{version}}.tar.gz

name: $(Build.BuildId)

parameters:
  - name: deployOverride
    displayName: Deployment Override (default = based on branch)
    type: string
    default: default
    values:
      - default
      - skip
      - force
  - name: deployEnvironment
    displayName: Static web app environment to deploy to
    type: string
    default: new
    values:
      - new
      - old
  - name: guardianAssetRetentionOverride
    displayName: Guardian Asset Retention Override (default = based on branch)
    type: string
    default: default
    values:
      - default
      - skip
      - force
  - name: publishGuardianBaselines
    displayName: Publish Guardian Baseline Files
    type: boolean
    default: false

variables:
  - group: doc-versions
  - group: storage-vars
  - name: repoToTrigger
    value: microsoft/FluidFramework
  - name: latestPipeline
    value: ${{ or(
      eq(variables['Build.SourceBranchName'], 'main'),
      eq(variables['Build.SourceBranchName'], 'pl-test')
      )}}
  - name: n1Branch
    value: ${{ join('/refs/heads/release/', variables['N1_BRANCH']) }}
  - name: n1Pipeline
    value: ${{ eq(variables['Build.SourceBranchName'], variables['N1_BRANCH']) }}
  - name: releasePipeline
    value: ${{ eq(variables['Build.SourceBranchName'], variables['RELEASE_BRANCH']) }}
  - name: validRun
    value: ${{ or(variables.releasePipeline, variables.n1Pipeline, variables.latestPipeline) }}
  - name: Packaging.EnableSBOMSigning
    value: true
  - name: isMain
    value: ${{ eq(variables['Build.SourceBranchName'], 'main') }}
  - name: shouldDeploy
    value: ${{ or(
      eq(parameters.deployOverride, 'force'),
      and(eq(variables.isMain, true), eq(parameters.deployOverride, 'default'))
      )}}
  - name: shouldRetainGuardianAssets
    value: ${{ or(
      eq(parameters.guardianAssetRetentionOverride, 'force'),
      and(eq(variables.isMain, true), eq(parameters.guardianAssetRetentionOverride, 'default'))
      )}}
  - name: arrow.releasedtoproduction
    value: eq(variables.shouldDeploy, true)
  - name: deploymentToken
    ${{ if eq( parameters['deployEnvironment'], 'new' ) }}:
      value: "$(FLUID_WEBSITE_TORUS_API_TOKEN)"
    ${{ if eq( parameters['deployEnvironment'], 'old') }}:
      value: "$(AZURE_STATIC_WEB_APPS_API_TOKEN)"
  # skip injected CG detection as we manually trigger it in a parallel job
  - name: skipComponentGovernanceDetection
    value: true
  - name: pnpmStorePath
    value: $(Pipeline.Workspace)/.pnpm-store

# TODO: Move trigger to pipeline designated for artifact model generation. Currently,
# the website docs builds and deploys on each commit. However, inconsistencies between
# the release branches and main is causing the website to change unexpectedly we can
# move the release/* trigger after separating the deploy step to another pipeline
# no PR triggers
trigger: none
pr: none

resources:
  pipelines:
    - pipeline: 14
      source: build-build-tools
      trigger: true
      branch: test/michaelzhen-1.0
  repositories:
    - repository: FluidFramework
      ref: refs/heads/test/michaelzhen

stages:
- stage: check_branch_version
  displayName: 'Check Version Deployment Condition'
  pool: Small
  jobs:
    - job: check_branch_version
      displayName: 'Check Version Deployment Condition'
      steps:
        - checkout: FluidFramework
        - template: /tools/pipelines/templates/include-install-build-tools.yml
          parameters:
            buildDirectory: $(Build.SourcesDirectory)
        - task: Bash@3
          name: SetVersion
          displayName: 'Set Build Version'
          env:
            VERSION_BUILDNUMBER: $(Build.BuildNumber)
          inputs:
            targetType: 'inline'
            workingDirectory: $(Build.SourcesDirectory)
            script: |
              # Generate the build version. Sets the environment variables version, codeVersion, and isLatest.
              flub generate buildVersion
        - task: Bash@3
          name: SetShouldDeploy
          displayName: 'Check Version Deployment Condition'
          inputs:
            targetType: 'inline'
            workingDirectory: $(Build.SourcesDirectory)
            script: |
              echo "generated buildVersion: $(SetVersion.version)"
              # Check if the version is the latest minor of its corresponding major version series, if not, return error and  skip deployment
              flub check latestVersions

- stage: test_deploy
  dependsOn: check_branch_version
  condition: eq(dependencies.check_branch_version.outputs['check_branch_version.SetShouldDeploy.shouldDeploy'], 'true') # Only run if shouldDeploy is true
  jobs:
  - job: DeployJob
    steps:
    - script: echo "Deploying application because shouldDeploy is true."
