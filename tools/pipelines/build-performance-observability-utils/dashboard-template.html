<!-- Copyright (c) Microsoft Corporation and contributors. All rights reserved. -->
<!-- Licensed under the MIT License. -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FF Build Dashboard</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üìä</text></svg>">
    <!-- Chart.js versions pinned for stability. Update periodically: https://www.chartjs.org/docs/latest/ -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body { font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { color: #323130; margin-bottom: 8px; }
        .header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; }
        .tabs { display: flex; gap: 4px; background: #e1dfdd; padding: 4px; border-radius: 8px; }
        .tab { padding: 10px 24px; border: none; background: transparent; cursor: pointer; font-size: 14px; font-weight: 500; color: #605e5c; border-radius: 6px; transition: all 0.2s; }
        .tab:hover { background: rgba(255,255,255,0.5); }
        .tab.active { background: white; color: #323130; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .tab.public.active { color: #42a5f5; }
        .tab.internal.active { color: #1565c0; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .loading { text-align: center; padding: 60px 20px; color: #605e5c; }
        .loading-spinner { width: 40px; height: 40px; border: 3px solid #e1dfdd; border-top-color: #0078d4; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 16px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .no-data { text-align: center; padding: 60px 20px; color: #605e5c; background: white; border-radius: 8px; box-shadow: 0 1.6px 3.6px rgba(0,0,0,.132); }
        .no-data h3 { margin: 0 0 8px; color: #323130; }
        .timestamp { color: #605e5c; font-size: 14px; margin-bottom: 24px; }
        .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 24px; }
        .metric-card { background: white; padding: 20px; border-radius: 4px; box-shadow: 0 1.6px 3.6px rgba(0,0,0,.132); }
        .metric-label { font-size: 12px; color: #605e5c; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; display: flex; align-items: center; gap: 4px; }
        .metric-value { font-size: 32px; font-weight: 600; color: #323130; }
        .metric-subtext { font-size: 14px; color: #605e5c; margin-top: 4px; }
        .info-icon { position: relative; cursor: help; }
        .info-icon .tooltip { visibility: hidden; width: 220px; background-color: #323130; color: #fff; text-align: center; border-radius: 4px; padding: 8px; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -110px; opacity: 0; transition: opacity 0.3s; font-size: 11px; text-transform: none; letter-spacing: normal; font-weight: normal; }
        .info-icon .tooltip::after { content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: #323130 transparent transparent transparent; }
        .info-icon:hover .tooltip { visibility: visible; opacity: 1; }
        .chart-container { background: white; padding: 16px; border-radius: 4px; box-shadow: 0 1.6px 3.6px rgba(0,0,0,.132); margin-bottom: 24px; position: relative; }
        .chart-title-overlay { text-align: center; font-size: 14px; font-weight: bold; color: #666; margin-bottom: 8px; display: flex; align-items: center; justify-content: center; gap: 6px; }
        .chart-container:has(.chart-title-overlay) { padding-bottom: 28px; }
        .chart-legend-info { position: absolute; top: 66px; left: 50%; margin-left: 95px; font-size: 14px; color: #605e5c; line-height: 1; }
        .chart-container.duration-chart { height: 320px; }
        .chart-container.stage-chart { height: 420px; }
        h2 { color: #323130; font-size: 18px; margin-top: 32px; margin-bottom: 16px; }
        .chart-header { display: flex; justify-content: space-between; align-items: center; margin-top: 32px; margin-bottom: 16px; }
        .chart-header h2 { margin: 0; }
        .chart-header select { padding: 6px 12px; border: 1px solid #8a8886; border-radius: 4px; font-size: 14px; background: white; cursor: pointer; }
        .chart-header select:hover { border-color: #605e5c; }
        .chart-header select:focus { outline: none; border-color: #0078d4; }
        .table-container { background: white; padding: 16px; border-radius: 4px; box-shadow: 0 1.6px 3.6px rgba(0,0,0,.132); margin-bottom: 24px; overflow-x: auto; }
        .builds-table { width: 100%; border-collapse: collapse; font-size: 14px; }
        .builds-table th, .builds-table td { padding: 12px 16px; text-align: left; border-bottom: 1px solid #edebe9; }
        .builds-table th { background: #faf9f8; font-weight: 600; color: #323130; cursor: pointer; user-select: none; white-space: nowrap; }
        .builds-table th:hover { background: #f3f2f1; }
        .builds-table th .sort-icon { margin-left: 4px; opacity: 0.5; }
        .builds-table th.sort-asc .sort-icon, .builds-table th.sort-desc .sort-icon { opacity: 1; }
        .builds-table tbody tr:hover { background: #faf9f8; }
        .builds-table a { color: #0078d4; text-decoration: none; }
        .builds-table a:hover { text-decoration: underline; }
        .pagination { display: flex; justify-content: space-between; align-items: center; margin-top: 16px; padding-top: 16px; border-top: 1px solid #edebe9; }
        .pagination-info { color: #605e5c; font-size: 14px; }
        .pagination-controls { display: flex; gap: 8px; }
        .pagination-btn { padding: 8px 16px; border: 1px solid #8a8886; background: white; border-radius: 4px; cursor: pointer; font-size: 14px; color: #323130; }
        .pagination-btn:hover:not(:disabled) { background: #f3f2f1; }
        .pagination-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .info { background: white; padding: 16px; border-radius: 4px; box-shadow: 0 1.6px 3.6px rgba(0,0,0,.132); margin-bottom: 24px; }
        .info h3 { margin-top: 0; color: #323130; }
        .info p, .info ul { color: #605e5c; line-height: 1.6; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-row">
            <h1>Fluid Framework Build Performance Dashboard</h1>
            <div class="tabs">
                <button class="tab public active" onclick="switchTab('public')">PR Builds</button>
                <button class="tab internal" onclick="switchTab('internal')">Internal Builds</button>
            </div>
        </div>
        <div id="public-content" class="tab-content active">
            <div class="loading" id="public-loading"><div class="loading-spinner"></div><p>Loading PR build data...</p></div>
            <div id="public-dashboard" style="display: none;"></div>
            <div class="no-data" id="public-no-data" style="display: none;"><h3>No PR Build Data Available</h3><p>PR build metrics will appear here once the public pipeline runs.</p></div>
        </div>
        <div id="internal-content" class="tab-content">
            <div class="loading" id="internal-loading"><div class="loading-spinner"></div><p>Loading internal build data...</p></div>
            <div id="internal-dashboard" style="display: none;"></div>
            <div class="no-data" id="internal-no-data" style="display: none;"><h3>No Internal Build Data Available</h3><p>Internal build metrics will appear here once the internal pipeline runs.</p></div>
        </div>
    </div>
    <script>
        // Dashboard state
        const dashboardData = { public: null, internal: null };
        const chartInstances = { public: {}, internal: {} };
        const tableState = {
            public: { recent: { sort: { column: 'date', direction: 'desc' }, page: 1 }, longest: { sort: { column: 'duration', direction: 'desc' }, page: 1 } },
            internal: { recent: { sort: { column: 'date', direction: 'desc' }, page: 1 }, longest: { sort: { column: 'duration', direction: 'desc' }, page: 1 } }
        };
        const itemsPerPage = 5;
        const colors = {
            public: { primary: 'rgba(66, 165, 245, 1)', background: 'rgba(66, 165, 245, 0.1)', tasks: ['rgba(76, 175, 80, 0.8)', 'rgba(66, 165, 245, 0.8)', 'rgba(255, 167, 38, 0.8)', 'rgba(171, 71, 188, 0.8)', 'rgba(38, 166, 154, 0.8)', 'rgba(236, 64, 122, 0.8)'] },
            internal: { primary: 'rgba(21, 101, 192, 1)', background: 'rgba(21, 101, 192, 0.1)', tasks: ['rgba(27, 94, 32, 0.8)', 'rgba(21, 101, 192, 0.8)', 'rgba(230, 81, 0, 0.8)', 'rgba(106, 27, 154, 0.8)', 'rgba(0, 105, 92, 0.8)', 'rgba(183, 28, 28, 0.8)'] }
        };

        // Configuration
        const config = {
            githubRepo: 'microsoft/FluidFramework',
            org: 'fluidframework'
        };

        // ============================================
        // UI Functions
        // ============================================

        function switchTab(mode) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.querySelector('.tab.' + mode).classList.add('active');
            document.getElementById(mode + '-content').classList.add('active');
            if (dashboardData[mode]) setTimeout(() => renderDashboard(mode, dashboardData[mode]), 50);
        }

        async function loadData() {
            const [prResult, internalResult] = await Promise.allSettled([
                fetch('data/public-data.json').then(r => r.ok ? r.json() : null),
                fetch('data/internal-data.json').then(r => r.ok ? r.json() : null)
            ]);
            if (prResult.status === 'fulfilled' && prResult.value) {
                // Data is pre-processed by the pipeline, use directly
                dashboardData.public = prResult.value;
                document.getElementById('public-loading').style.display = 'none';
                document.getElementById('public-dashboard').style.display = 'block';
                renderDashboard('public', dashboardData.public);
            } else {
                document.getElementById('public-loading').style.display = 'none';
                document.getElementById('public-no-data').style.display = 'block';
            }
            if (internalResult.status === 'fulfilled' && internalResult.value) {
                // Data is pre-processed by the pipeline, use directly
                dashboardData.internal = internalResult.value;
                document.getElementById('internal-loading').style.display = 'none';
                document.getElementById('internal-dashboard').style.display = 'block';
                renderDashboard('internal', dashboardData.internal);
            } else {
                document.getElementById('internal-loading').style.display = 'none';
                document.getElementById('internal-no-data').style.display = 'block';
            }
        }

        function renderDashboard(mode, data) {
            const container = document.getElementById(mode + '-dashboard');
            const colorScheme = colors[mode];
            const modeLabel = mode === 'public' ? 'PR' : 'internal';
            const trendDays = mode === 'public' ? 3 : 7;
            const trendDate = new Date(); trendDate.setDate(trendDate.getDate() - trendDays);
            const trendDateStr = trendDate.toISOString().split('T')[0];
            let durationChange = 0, durationChangeMinutes = 0;
            if (data.durationTrend && data.durationTrend.length > 0) {
                const recentBuilds = data.durationTrend.filter(d => d.date >= trendDateStr);
                const previousBuilds = data.durationTrend.filter(d => d.date < trendDateStr);
                if (recentBuilds.length > 0 && previousBuilds.length > 0) {
                    const recentAvg = recentBuilds.reduce((sum, d) => sum + d.avgDuration, 0) / recentBuilds.length;
                    const previousAvg = previousBuilds.reduce((sum, d) => sum + d.avgDuration, 0) / previousBuilds.length;
                    durationChange = ((recentAvg - previousAvg) / previousAvg) * 100;
                    durationChangeMinutes = recentAvg - previousAvg;
                }
            }
            const trendColor = durationChange < 0 ? '#107c10' : durationChange > 0 ? '#d13438' : '#605e5c';
            const trendSign = durationChange > 0 ? '+' : durationChange < 0 ? '' : '';
            const timestamp = data.generatedAt ? (() => { const d = new Date(data.generatedAt); return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) + ' ' + d.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', timeZoneName: 'short' }); })() : 'Unknown';
            const pipelineUrl = mode === 'public' ? 'https://dev.azure.com/fluidframework/public/_build?definitionId=190' : 'https://dev.azure.com/fluidframework/internal/_build?definitionId=191';
            const buildPipelineUrl = mode === 'public' ? 'https://dev.azure.com/fluidframework/public/_build?definitionId=11' : 'https://dev.azure.com/fluidframework/internal/_build?definitionId=12';
            container.innerHTML = '<div class="info"><h3>About This Dashboard</h3><p style="margin-bottom: 4px;">Last updated: <strong>' + timestamp + '</strong></p><p style="font-size: 13px; margin-top: 0; margin-bottom: 16px;">Run the <a href="' + pipelineUrl + '" target="_blank">Build Performance Observability Pipeline (' + mode + ')</a> to manually update the dashboard.</p><p>This dashboard shows metrics for <strong>' + modeLabel + ' builds</strong>.</p><ul>' + (mode === 'public' ? '<li>Target branch: <code>main</code></li>' : '<li>Branch: <code>main</code></li>') + '<li>Status: <code>completed</code> and <code>succeeded</code> or <code>partiallySucceeded</code></li><li>Pipeline: <a href="' + buildPipelineUrl + '" target="_blank">Build - client packages (' + mode + ')</a></li><li>Data source: <a href="https://learn.microsoft.com/en-us/rest/api/azure/devops/build/?view=azure-devops-rest-7.1" target="_blank">Azure DevOps Build API (v7.1)</a></li></ul></div>' +
                '<div class="metrics"><div class="metric-card"><div class="metric-label">Total Builds</div><div class="metric-value">' + (data.summary?.totalBuilds || 0) + '</div></div>' +
                '<div class="metric-card"><div class="metric-label">Avg Duration</div><div class="metric-value">' + (data.summary?.avgDuration || 0).toFixed(1) + 'm</div></div>' +
                '<div class="metric-card"><div class="metric-label">' + trendDays + '-Day Trend <span class="info-icon">‚ìò<span class="tooltip">Compares average duration of last ' + trendDays + ' days vs the average of all builds before that</span></span></div>' +
                '<div class="metric-value" style="color: ' + trendColor + '">' + trendSign + Math.abs(durationChangeMinutes).toFixed(1) + 'm <span style="font-size: 18px; opacity: 0.8;">(' + trendSign + Math.abs(durationChange).toFixed(1) + '%)</span></div></div></div>' +
                '<h2>Duration Trend</h2><div class="chart-container duration-chart"><canvas id="' + mode + '-duration-chart"></canvas><span class="chart-legend-info info-icon">‚ìò<span class="tooltip">Outliers of ¬±20% from daily average are highlighted with clickable markers</span></span></div>' +
                '<div class="chart-header"><h2>Stage Breakdown</h2><select id="' + mode + '-stage-view-select" onchange="switchStageView(\'' + mode + '\')"><option value="by-stage">By Stage</option><option value="over-time">By Day</option></select></div>' +
                '<div class="chart-container stage-chart" id="' + mode + '-stage-container"><div class="chart-title-overlay" id="' + mode + '-stage-title-overlay" style="display: none;">Stage Duration by Day <span class="info-icon">‚ìò<span class="tooltip">Click a legend item to isolate it. Click again to show all.</span></span></div><canvas id="' + mode + '-stage-chart"></canvas></div>' +
                '<div class="chart-header"><h2>Task Breakdown</h2><select id="' + mode + '-task-view-select" onchange="switchTaskView(\'' + mode + '\')"><option value="by-task">By Task</option><option value="over-time">By Day</option></select></div>' +
                '<div class="chart-container stage-chart" id="' + mode + '-task-container"><div class="chart-title-overlay" id="' + mode + '-task-title-overlay" style="display: none;">Average Task Duration by Day <span class="info-icon">‚ìò<span class="tooltip">Click a legend item to isolate it. Click again to show all.</span></span></div><canvas id="' + mode + '-task-chart"></canvas></div>' +
                '<h2>Recent Builds</h2><div class="table-container"><table class="builds-table" id="' + mode + '-recent-table"><thead><tr><th data-sort="id">Build ID <span class="sort-icon">‚Üï</span></th><th data-sort="date" class="sort-desc">Date <span class="sort-icon">‚Üì</span></th><th data-sort="duration">Duration <span class="sort-icon">‚Üï</span></th><th data-sort="source">Source <span class="sort-icon">‚Üï</span></th></tr></thead><tbody id="' + mode + '-recent-body"></tbody></table><div class="pagination"><div class="pagination-info">Showing <span id="' + mode + '-recent-start">1</span>-<span id="' + mode + '-recent-end">5</span> of <span id="' + mode + '-recent-total">' + (data.recentBuilds || []).length + '</span></div><div class="pagination-controls"><button class="pagination-btn" id="' + mode + '-recent-prev" onclick="prevPage(\'' + mode + '\', \'recent\')">‚Üê Previous</button><button class="pagination-btn" id="' + mode + '-recent-next" onclick="nextPage(\'' + mode + '\', \'recent\')">Next ‚Üí</button></div></div></div>' +
                '<h2>Longest Builds</h2><div class="table-container"><table class="builds-table" id="' + mode + '-longest-table"><thead><tr><th data-sort="id">Build ID <span class="sort-icon">‚Üï</span></th><th data-sort="date">Date <span class="sort-icon">‚Üï</span></th><th data-sort="duration" class="sort-desc">Duration <span class="sort-icon">‚Üì</span></th><th data-sort="source">Source <span class="sort-icon">‚Üï</span></th></tr></thead><tbody id="' + mode + '-longest-body"></tbody></table><div class="pagination"><div class="pagination-info">Showing <span id="' + mode + '-longest-start">1</span>-<span id="' + mode + '-longest-end">5</span> of <span id="' + mode + '-longest-total">' + (data.longestBuilds || []).length + '</span></div><div class="pagination-controls"><button class="pagination-btn" id="' + mode + '-longest-prev" onclick="prevPage(\'' + mode + '\', \'longest\')">‚Üê Previous</button><button class="pagination-btn" id="' + mode + '-longest-next" onclick="nextPage(\'' + mode + '\', \'longest\')">Next ‚Üí</button></div></div></div>';
            createDurationChart(mode, data, colorScheme);
            createStageChart(mode, data, colorScheme);
            createTaskChart(mode, data, colorScheme);
            renderTable(mode, 'recent', data.recentBuilds || []);
            renderTable(mode, 'longest', data.longestBuilds || []);
            setupTableSorting(mode, 'recent', data.recentBuilds || []);
            setupTableSorting(mode, 'longest', data.longestBuilds || []);
        }

        function createDurationChart(mode, data, colorScheme) {
            const ctx = document.getElementById(mode + '-duration-chart');
            if (!ctx) return;
            if (chartInstances[mode].duration) chartInstances[mode].duration.destroy();
            if (!data.durationTrend || data.durationTrend.length === 0) { ctx.parentElement.innerHTML = '<p style="padding: 20px; text-align: center; color: #605e5c;">No duration data available</p>'; return; }
            const minData = data.durationTrend.map(d => ({ x: new Date(d.date), y: d.minDuration, isOutlier: d.minDuration <= d.avgDuration * 0.8, buildId: d.minBuildId }));
            const avgData = data.durationTrend.map(d => ({ x: new Date(d.date), y: d.avgDuration }));
            const maxData = data.durationTrend.map(d => ({ x: new Date(d.date), y: d.maxDuration, isOutlier: d.maxDuration >= d.avgDuration * 1.2, buildId: d.maxBuildId }));
            const project = mode === 'public' ? 'public' : 'internal';
            chartInstances[mode].duration = new Chart(ctx, {
                type: 'line', data: { datasets: [
                    { label: 'Max', data: maxData, borderColor: 'rgba(211, 52, 56, 0.6)', backgroundColor: 'rgba(211, 52, 56, 0.6)', borderWidth: 1.5, borderDash: [4, 4], fill: false, tension: 0.4, pointRadius: (ctx) => ctx.raw && ctx.raw.isOutlier ? 4 : 0, pointHoverRadius: (ctx) => ctx.raw && ctx.raw.isOutlier ? 5 : 0, pointStyle: 'circle', clip: 8 },
                    { label: 'Avg', data: avgData, borderColor: colorScheme.primary, backgroundColor: colorScheme.background, borderWidth: 2, fill: true, tension: 0.4, pointRadius: 3, pointHoverRadius: 4, pointStyle: 'circle' },
                    { label: 'Min', data: minData, borderColor: 'rgba(16, 124, 16, 0.6)', backgroundColor: 'rgba(16, 124, 16, 0.6)', borderWidth: 1.5, borderDash: [4, 4], fill: false, tension: 0.4, pointRadius: (ctx) => ctx.raw && ctx.raw.isOutlier ? 4 : 0, pointHoverRadius: (ctx) => ctx.raw && ctx.raw.isOutlier ? 5 : 0, pointStyle: 'circle' }
                ] },
                options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { onClick: null, position: 'top', labels: { boxWidth: 20, padding: 15, generateLabels: function(chart) { return chart.data.datasets.map((dataset, i) => ({ text: dataset.label, fillStyle: 'transparent', strokeStyle: dataset.borderColor, lineWidth: dataset.borderWidth, lineDash: dataset.borderDash || [], hidden: !chart.isDatasetVisible(i), datasetIndex: i })); } } }, title: { display: true, text: 'Build Duration Trend', font: { size: 14, weight: 'bold' } }, tooltip: { callbacks: { title: function(context) { const date = context[0].raw.x; return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }); }, label: function(context) { const label = context.dataset.label || ''; const value = context.parsed.y.toFixed(1) + 'm'; if (context.raw && context.raw.buildId && context.raw.isOutlier) { return label + ': ' + value + ' (Build #' + context.raw.buildId + ')'; } return label + ': ' + value; }, afterLabel: function(context) { if (context.raw && context.raw.isOutlier && context.raw.buildId) { return 'Click to view build'; } return ''; } }, filter: function(tooltipItem) { if (tooltipItem.datasetIndex === 0 || tooltipItem.datasetIndex === 2) { return tooltipItem.raw && tooltipItem.raw.isOutlier; } return true; } } }, scales: { x: { type: 'time', time: { unit: 'day' }, title: { display: true, text: 'Date' } }, y: { beginAtZero: true, title: { display: true, text: 'Duration (minutes)' } } }, onClick: function(event, elements) { if (elements.length > 0) { const el = elements[0]; const dataPoint = this.data.datasets[el.datasetIndex].data[el.index]; if (dataPoint && dataPoint.buildId) { window.open('https://dev.azure.com/' + config.org + '/' + project + '/_build/results?buildId=' + dataPoint.buildId, '_blank'); } } } }
            });
        }

        function createStageDurationTrendChart(mode, data, colorScheme) {
            const ctx = document.getElementById(mode + '-stage-chart');
            if (!ctx) return;
            if (chartInstances[mode].stage) chartInstances[mode].stage.destroy();
            const trendData = data.stageDurationTrend?.trendData || [];
            const stageNames = data.stageDurationTrend?.stageNames || [];
            if (trendData.length === 0 || stageNames.length === 0) {
                ctx.parentElement.innerHTML = '<p style="padding: 20px; text-align: center; color: #605e5c;">No stage trend data available</p>';
                return;
            }
            const project = mode === 'public' ? 'public' : 'internal';
            const formatDate = (dateStr) => {
                const [y, m, d] = dateStr.split('-');
                return m + '/' + d + '/' + y;
            };
            const labels = trendData.map(d => formatDate(d.date));
            const datasets = stageNames.map((stageName, index) => ({
                label: stageName,
                data: trendData.map(d => d[stageName] || 0),
                backgroundColor: colorScheme.tasks[index % colorScheme.tasks.length],
                borderWidth: 0
            }));
            chartInstances[mode].stage = new Chart(ctx, {
                type: 'bar',
                data: { labels, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: { boxWidth: 12, padding: 8 },
                            onClick: function(e, legendItem, legend) {
                                const chart = legend.chart;
                                const clickedIndex = legendItem.datasetIndex;
                                const allHiddenExceptClicked = chart.data.datasets.every((ds, i) =>
                                    i === clickedIndex ? chart.isDatasetVisible(i) : !chart.isDatasetVisible(i)
                                );
                                if (allHiddenExceptClicked) {
                                    // Show all datasets
                                    chart.data.datasets.forEach((ds, i) => { chart.setDatasetVisibility(i, true); });
                                } else {
                                    // Hide all except clicked
                                    chart.data.datasets.forEach((ds, i) => { chart.setDatasetVisibility(i, i === clickedIndex); });
                                }
                                chart.update();
                            }
                        },
                        title: { display: false },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const idx = context[0].dataIndex;
                                    const dataPoint = trendData[idx];
                                    const buildCount = dataPoint ? dataPoint.buildCount : 0;
                                    const date = new Date(dataPoint.date);
                                    const formatted = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                                    return formatted + ' (' + buildCount + ' build' + (buildCount !== 1 ? 's' : '') + ')';
                                },
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(1) + 'm';
                                },
                                afterBody: function(context) {
                                    const idx = context[0].dataIndex;
                                    const dataPoint = trendData[idx];
                                    if (dataPoint && dataPoint.buildIds && dataPoint.buildIds.length === 1) {
                                        return 'Click to view build #' + dataPoint.buildIds[0];
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        x: { stacked: true, title: { display: true, text: 'Date' } },
                        y: { stacked: true, beginAtZero: true, title: { display: true, text: 'Duration (minutes)' } }
                    },
                    onClick: function(event, elements) {
                        if (elements.length > 0) {
                            const el = elements[0];
                            const dataPoint = trendData[el.index];
                            if (dataPoint && dataPoint.buildIds && dataPoint.buildIds.length === 1) {
                                window.open('https://dev.azure.com/' + config.org + '/' + project + '/_build/results?buildId=' + dataPoint.buildIds[0], '_blank');
                            }
                        }
                    }
                }
            });
        }

        function createTaskDurationTrendChart(mode, data, colorScheme) {
            const ctx = document.getElementById(mode + '-task-chart');
            if (!ctx) return;
            if (chartInstances[mode].task) chartInstances[mode].task.destroy();
            const trendData = data.taskDurationTrend?.trendData || [];
            const taskNames = data.taskDurationTrend?.taskNames || [];
            if (trendData.length === 0 || taskNames.length === 0) {
                ctx.parentElement.innerHTML = '<p style="padding: 20px; text-align: center; color: #605e5c;">No task trend data available</p>';
                return;
            }
            const project = mode === 'public' ? 'public' : 'internal';
            const formatDate = (dateStr) => {
                const [y, m, d] = dateStr.split('-');
                return m + '/' + d + '/' + y;
            };
            const labels = trendData.map(d => formatDate(d.date));
            const datasets = taskNames.map((taskName, index) => ({
                label: taskName,
                data: trendData.map(d => d[taskName] || 0),
                backgroundColor: colorScheme.tasks[index % colorScheme.tasks.length],
                borderWidth: 0
            }));
            chartInstances[mode].task = new Chart(ctx, {
                type: 'bar',
                data: { labels, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: { boxWidth: 12, padding: 8 },
                            onClick: function(e, legendItem, legend) {
                                const chart = legend.chart;
                                const clickedIndex = legendItem.datasetIndex;
                                const allHiddenExceptClicked = chart.data.datasets.every((ds, i) =>
                                    i === clickedIndex ? chart.isDatasetVisible(i) : !chart.isDatasetVisible(i)
                                );
                                if (allHiddenExceptClicked) {
                                    // Show all datasets
                                    chart.data.datasets.forEach((ds, i) => { chart.setDatasetVisibility(i, true); });
                                } else {
                                    // Hide all except clicked
                                    chart.data.datasets.forEach((ds, i) => { chart.setDatasetVisibility(i, i === clickedIndex); });
                                }
                                chart.update();
                            }
                        },
                        title: { display: false },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const idx = context[0].dataIndex;
                                    const dataPoint = trendData[idx];
                                    const buildCount = dataPoint ? dataPoint.buildCount : 0;
                                    const date = new Date(dataPoint.date);
                                    const formatted = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                                    return formatted + ' (' + buildCount + ' build' + (buildCount !== 1 ? 's' : '') + ')';
                                },
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(1) + 'm';
                                },
                                afterBody: function(context) {
                                    const idx = context[0].dataIndex;
                                    const dataPoint = trendData[idx];
                                    if (dataPoint && dataPoint.buildIds && dataPoint.buildIds.length === 1) {
                                        return 'Click to view build #' + dataPoint.buildIds[0];
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        x: { stacked: true, title: { display: true, text: 'Date' } },
                        y: { stacked: true, beginAtZero: true, title: { display: true, text: 'Duration (minutes)' } }
                    },
                    onClick: function(event, elements) {
                        if (elements.length > 0) {
                            const el = elements[0];
                            const dataPoint = trendData[el.index];
                            if (dataPoint && dataPoint.buildIds && dataPoint.buildIds.length === 1) {
                                window.open('https://dev.azure.com/' + config.org + '/' + project + '/_build/results?buildId=' + dataPoint.buildIds[0], '_blank');
                            }
                        }
                    }
                }
            });
        }

        function createStageChart(mode, data, colorScheme) {
            const ctx = document.getElementById(mode + '-stage-chart');
            if (!ctx) return;
            if (chartInstances[mode].stage) chartInstances[mode].stage.destroy();
            const stageData = data.stageTaskBreakdown || {};
            const stagePerf = data.stagePerformance || [];
            const stages = Object.keys(stageData).sort();
            if (stages.length === 0) { ctx.parentElement.innerHTML = '<p style="padding: 20px; text-align: center; color: #605e5c;">No stage data available</p>'; return; }
            const stageAvgDurations = {}; stagePerf.forEach(s => { stageAvgDurations[s.name] = s.avgDuration; });
            const allTasks = new Set();
            stages.forEach(stage => { const tasks = stageData[stage] || []; if (tasks.length === 0) allTasks.add(stage); else tasks.forEach(task => allTasks.add(task.name)); });
            const taskNames = Array.from(allTasks).sort();
            const datasets = taskNames.map((taskName, index) => ({ label: taskName, data: stages.map(stage => { const tasks = stageData[stage] || []; if (tasks.length === 0 && taskName === stage) return stageAvgDurations[stage] || 0; const task = tasks.find(t => t.name === taskName); return task ? task.avgDuration : 0; }), backgroundColor: colorScheme.tasks[index % colorScheme.tasks.length], borderWidth: 1 }));
            chartInstances[mode].stage = new Chart(ctx, { type: 'bar', data: { labels: stages, datasets }, options: { indexAxis: 'y', responsive: true, maintainAspectRatio: false, plugins: { legend: { onClick: null, position: 'bottom', labels: { boxWidth: 12, padding: 8 } }, title: { display: true, text: 'Average Duration by Stage', font: { size: 14, weight: 'bold' } } }, scales: { x: { stacked: true, beginAtZero: true, title: { display: true, text: 'Duration (minutes)' } }, y: { stacked: true, title: { display: true, text: 'Stage' } } } } });
        }

        function switchStageView(mode) {
            const select = document.getElementById(mode + '-stage-view-select');
            const titleOverlay = document.getElementById(mode + '-stage-title-overlay');
            const container = document.getElementById(mode + '-stage-container');
            const view = select.value;
            const data = dashboardData[mode];
            const colorScheme = colors[mode];

            // Show/hide title overlay based on view
            if (view === 'over-time') {
                titleOverlay.style.display = 'flex';
                container.style.paddingBottom = '28px';
                createStageDurationTrendChart(mode, data, colorScheme);
            } else {
                titleOverlay.style.display = 'none';
                container.style.paddingBottom = '16px';
                createStageChart(mode, data, colorScheme);
            }
        }

        function switchTaskView(mode) {
            const select = document.getElementById(mode + '-task-view-select');
            const titleOverlay = document.getElementById(mode + '-task-title-overlay');
            const container = document.getElementById(mode + '-task-container');
            const view = select.value;
            const data = dashboardData[mode];
            const colorScheme = colors[mode];

            // Show/hide title overlay based on view
            if (view === 'over-time') {
                titleOverlay.style.display = 'flex';
                container.style.paddingBottom = '28px';
                createTaskDurationTrendChart(mode, data, colorScheme);
            } else {
                titleOverlay.style.display = 'none';
                container.style.paddingBottom = '16px';
                createTaskChart(mode, data, colorScheme);
            }
        }

        function createTaskChart(mode, data, colorScheme) {
            const ctx = document.getElementById(mode + '-task-chart');
            if (!ctx) return;
            if (chartInstances[mode].task) chartInstances[mode].task.destroy();
            const stageData = data.stageTaskBreakdown || {};
            const stagePerf = data.stagePerformance || [];
            if (Object.keys(stageData).length === 0) { ctx.parentElement.innerHTML = '<p style="padding: 20px; text-align: center; color: #605e5c;">No task data available</p>'; return; }
            const allTasks = [];
            const stageAvgDurations = {}; stagePerf.forEach(s => { stageAvgDurations[s.name] = s.avgDuration; });
            const stages = Object.keys(stageData).sort();
            const stageColorMap = {}; stages.forEach((stage, idx) => { stageColorMap[stage] = idx; });
            stages.forEach(stage => { const tasks = stageData[stage] || []; if (tasks.length === 0) allTasks.push({ label: stage, duration: stageAvgDurations[stage] || 0, stageIndex: stageColorMap[stage] }); else tasks.forEach(task => { allTasks.push({ label: stage + ' ‚Ä∫ ' + task.name, duration: task.avgDuration, stageIndex: stageColorMap[stage] }); }); });
            allTasks.sort((a, b) => b.duration - a.duration);
            chartInstances[mode].task = new Chart(ctx, { type: 'bar', data: { labels: allTasks.map(t => t.label), datasets: [{ label: 'Avg Duration (minutes)', data: allTasks.map(t => t.duration), backgroundColor: allTasks.map(t => colorScheme.tasks[t.stageIndex % colorScheme.tasks.length]), borderWidth: 1 }] }, options: { indexAxis: 'y', responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false }, title: { display: true, text: 'Longest Average Individual Tasks', font: { size: 14, weight: 'bold' } } }, scales: { x: { beginAtZero: true, title: { display: true, text: 'Duration (minutes)' } }, y: { title: { display: true, text: 'Task' } } } } });
        }

        function renderTable(mode, tableType, builds) {
            const state = tableState[mode][tableType];
            const tbody = document.getElementById(mode + '-' + tableType + '-body');
            if (!tbody) return;
            const sortedBuilds = sortBuilds(builds, state.sort.column, state.sort.direction);
            const startIdx = (state.page - 1) * itemsPerPage;
            const endIdx = Math.min(startIdx + itemsPerPage, sortedBuilds.length);
            const pageBuilds = sortedBuilds.slice(startIdx, endIdx);
            tbody.innerHTML = pageBuilds.map(build => {
                const date = new Date(build.startTime);
                const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                const timeStr = date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', timeZoneName: 'short' });
                const sourceCell = build.sourceUrl ? '<a href="' + build.sourceUrl + '" target="_blank">' + build.source + '</a>' : build.source;
                return '<tr><td><a href="' + build.url + '" target="_blank">' + build.id + '</a></td><td>' + dateStr + ' ' + timeStr + '</td><td>' + build.duration.toFixed(1) + 'm</td><td>' + sourceCell + '</td></tr>';
            }).join('');
            document.getElementById(mode + '-' + tableType + '-start').textContent = sortedBuilds.length > 0 ? startIdx + 1 : 0;
            document.getElementById(mode + '-' + tableType + '-end').textContent = endIdx;
            updatePaginationControls(mode, tableType, builds.length);
        }

        function sortBuilds(builds, column, direction) {
            return [...builds].sort((a, b) => { let aVal, bVal; switch (column) { case 'id': aVal = a.id; bVal = b.id; break; case 'date': aVal = new Date(a.startTime); bVal = new Date(b.startTime); break; case 'duration': aVal = a.duration; bVal = b.duration; break; case 'source': aVal = a.source; bVal = b.source; break; default: return 0; } if (aVal < bVal) return direction === 'asc' ? -1 : 1; if (aVal > bVal) return direction === 'asc' ? 1 : -1; return 0; });
        }

        function setupTableSorting(mode, tableType, builds) {
            const headers = document.querySelectorAll('#' + mode + '-' + tableType + '-table th[data-sort]');
            headers.forEach(header => { header.addEventListener('click', () => { const column = header.dataset.sort; const state = tableState[mode][tableType]; if (state.sort.column === column) state.sort.direction = state.sort.direction === 'asc' ? 'desc' : 'asc'; else { state.sort.column = column; state.sort.direction = 'desc'; } headers.forEach(h => { h.classList.remove('sort-asc', 'sort-desc'); h.querySelector('.sort-icon').textContent = '‚Üï'; }); header.classList.add('sort-' + state.sort.direction); header.querySelector('.sort-icon').textContent = state.sort.direction === 'asc' ? '‚Üë' : '‚Üì'; state.page = 1; renderTable(mode, tableType, builds); }); });
        }

        function updatePaginationControls(mode, tableType, totalItems) { const state = tableState[mode][tableType]; const totalPages = Math.ceil(totalItems / itemsPerPage); document.getElementById(mode + '-' + tableType + '-prev').disabled = state.page <= 1; document.getElementById(mode + '-' + tableType + '-next').disabled = state.page >= totalPages; }
        function prevPage(mode, tableType) { const state = tableState[mode][tableType]; if (state.page > 1) { state.page--; renderTable(mode, tableType, dashboardData[mode][tableType === 'recent' ? 'recentBuilds' : 'longestBuilds'] || []); } }
        function nextPage(mode, tableType) { const state = tableState[mode][tableType]; const builds = dashboardData[mode][tableType === 'recent' ? 'recentBuilds' : 'longestBuilds'] || []; const totalPages = Math.ceil(builds.length / itemsPerPage); if (state.page < totalPages) { state.page++; renderTable(mode, tableType, builds); } }

        document.addEventListener('DOMContentLoaded', loadData);
    </script>
</body>
</html>
