# Copyright (c) Microsoft Corporation and contributors. All rights reserved.
# Licensed under the MIT License.

# build-performance-observability pipeline
# This pipeline collects build metrics using ADO REST APIs and generates an HTML dashboard
# When run from the "public" project: collects PR build metrics
# When run from the "internal" project: collects post-merge build metrics

name: $(Build.BuildId)

# Schedule to run daily at 2 AM UTC
# schedules:
# - cron: "0 2 * * *"
#   displayName: Daily build metrics collection
#   branches:
#     include:
#     - main
#   always: true

trigger: none

pr: none

variables:
  # Number of recent builds to fetch
  - name: buildCount
    value: 500
  # Organization
  - name: organization
    value: fluidframework
  # Mode: public = PR builds, internal = post-merge builds
  - name: isPublicProject
    value: ${{ eq(variables['System.TeamProject'], 'public') }}
  # Build definition IDs
  - name: publicPRBuildDefinitionId
    value: 11
  - name: internalBuildDefinitionId
    value: 12
  # Project to query (same as where pipeline runs)
  - name: targetProject
    value: $(System.TeamProject)

resources:
  repositories:
  - repository: m365Pipelines
    type: git
    name: 1ESPipelineTemplates/M365GPT
    ref: refs/tags/release

extends:
  ${{ if eq(variables['System.TeamProject'], 'internal') }}:
    template: v1/M365.Official.PipelineTemplate.yml@m365Pipelines
  ${{ else }}:
    template: v1/M365.Unofficial.PipelineTemplate.yml@m365Pipelines
  parameters:
    customBuildTags:
    - ES365AIMigrationTooling
    pool:
      name: Small-eastus2
      os: linux
    sdl:
      sourceAnalysisPool:
        name: Azure-Pipelines-1ESPT-ExDShared
        image: windows-2022
        os: windows

    stages:
    - stage: collect_metrics
      displayName: Collect Build Metrics
      jobs:
      - job: fetch_and_publish
        displayName: Fetch and Publish Build Metrics
        templateContext:
          outputs:
          - output: pipelineArtifact
            targetPath: $(Build.ArtifactStagingDirectory)
            artifactName: dashboard
            displayName: Publish dashboard as artifact
        steps:
        - checkout: none

        - task: Bash@3
          displayName: Fetch build data
          env:
            ADO_API_TOKEN: $(System.AccessToken)
            PR_BUILD_DEF_ID: $(publicPRBuildDefinitionId)
            INTERNAL_BUILD_DEF_ID: $(internalBuildDefinitionId)
            BUILD_COUNT: $(buildCount)
            ORG: $(organization)
            PROJECT: $(targetProject)
            IS_PUBLIC: $(isPublicProject)
          inputs:
            targetType: 'inline'
            script: |
              set -eu -o pipefail

              # Determine mode based on project
              if [ "$IS_PUBLIC" = "True" ]; then
                MODE="pr"
                BUILD_DEF_ID="$PR_BUILD_DEF_ID"
              else
                MODE="postmerge"
                BUILD_DEF_ID="$INTERNAL_BUILD_DEF_ID"
              fi

              echo "=========================================="
              echo "Fetching build metrics"
              echo "=========================================="
              echo "Mode: $MODE"
              echo "Organization: $ORG"
              echo "Project: $PROJECT"
              echo "Build Definition: $BUILD_DEF_ID"
              echo "Build Count: $BUILD_COUNT"
              echo ""

              # Create output directory
              mkdir -p $(Build.ArtifactStagingDirectory)/metrics

              # Save mode for subsequent tasks
              echo "$MODE" > $(Build.ArtifactStagingDirectory)/metrics/mode.txt

              if [ "$MODE" = "pr" ]; then
                # Fetch PR builds with reasonFilter and statusFilter
                echo "Fetching last $BUILD_COUNT PR builds (reason=pullRequest, succeeded/partiallySucceeded, completed)..."

                curl -u ":$ADO_API_TOKEN" \
                  "https://dev.azure.com/$ORG/$PROJECT/_apis/build/builds?definitions=$BUILD_DEF_ID&reasonFilter=pullRequest&resultFilter=succeeded,partiallySucceeded&statusFilter=completed&\$top=$BUILD_COUNT&api-version=7.1" \
                  -o $(Build.ArtifactStagingDirectory)/metrics/builds-raw.json
              else
                # Fetch post-merge builds from main branch
                echo "Fetching last $BUILD_COUNT post-merge builds (branch=main, succeeded/partiallySucceeded, completed)..."

                curl -u ":$ADO_API_TOKEN" \
                  "https://dev.azure.com/$ORG/$PROJECT/_apis/build/builds?definitions=$BUILD_DEF_ID&branchName=refs/heads/main&resultFilter=succeeded,partiallySucceeded&statusFilter=completed&\$top=$BUILD_COUNT&api-version=7.1" \
                  -o $(Build.ArtifactStagingDirectory)/metrics/builds-raw.json
              fi

              echo "Build data fetched successfully!"

        - task: Bash@3
          displayName: Filter builds (PR mode only)
          inputs:
            targetType: 'inline'
            script: |
              set -eu -o pipefail

              MODE=$(cat $(Build.ArtifactStagingDirectory)/metrics/mode.txt)

              if [ "$MODE" = "pr" ]; then
                echo "=========================================="
                echo "Filtering PR builds by target branch (main)"
                echo "=========================================="

                # Filter PR builds to only include those targeting main branch
                # The target branch is in the parameters field as JSON string: "system.pullRequest.targetBranch"

                cat $(Build.ArtifactStagingDirectory)/metrics/builds-raw.json | jq '
                  .value |= map(select(
                    .parameters != null and
                    (.parameters | fromjson | .["system.pullRequest.targetBranch"] == "main")
                  ))
                ' > $(Build.ArtifactStagingDirectory)/metrics/builds.json

                TOTAL_AFTER=$(cat $(Build.ArtifactStagingDirectory)/metrics/builds.json | jq '.value | length')
                echo "Filtered to $TOTAL_AFTER PR builds targeting main branch"
              else
                echo "=========================================="
                echo "Post-merge mode - no filtering needed"
                echo "=========================================="

                # Just copy the raw file to builds.json
                cp $(Build.ArtifactStagingDirectory)/metrics/builds-raw.json $(Build.ArtifactStagingDirectory)/metrics/builds.json

                TOTAL=$(cat $(Build.ArtifactStagingDirectory)/metrics/builds.json | jq '.value | length')
                echo "Total post-merge builds: $TOTAL"
              fi

        - task: Bash@3
          displayName: Fetch timeline data for builds
          env:
            ADO_API_TOKEN: $(System.AccessToken)
            ORG: $(organization)
            PROJECT: $(targetProject)
          inputs:
            targetType: 'inline'
            script: |
              set -eu -o pipefail

              MODE=$(cat $(Build.ArtifactStagingDirectory)/metrics/mode.txt)

              echo "=========================================="
              echo "Fetching timeline data for builds ($MODE mode)"
              echo "=========================================="

              # Extract build IDs from filtered builds
              BUILD_IDS=$(cat $(Build.ArtifactStagingDirectory)/metrics/builds.json | jq -r '.value[] | .id')

              TOTAL_COUNT=$(echo "$BUILD_IDS" | wc -l | tr -d ' ')
              echo "Found $TOTAL_COUNT builds to fetch timeline data for"
              echo ""

              mkdir -p $(Build.ArtifactStagingDirectory)/metrics/timelines

              # Fetch in parallel using background jobs (20 at a time to avoid overwhelming the API)
              PARALLEL_JOBS=20
              count=0

              fetch_timeline() {
                local build_id=$1
                local output_file=$2
                curl -s -u ":$ADO_API_TOKEN" \
                  "https://dev.azure.com/$ORG/$PROJECT/_apis/build/builds/$build_id/timeline?api-version=7.1-preview.2" \
                  -o "$output_file" 2>/dev/null
              }

              for BUILD_ID in $BUILD_IDS; do
                count=$((count + 1))

                # Start background job
                fetch_timeline "$BUILD_ID" "$(Build.ArtifactStagingDirectory)/metrics/timelines/timeline_$BUILD_ID.json" &

                # Limit concurrent jobs
                if (( count % PARALLEL_JOBS == 0 )); then
                  wait  # Wait for current batch to complete
                  echo "[$count/$TOTAL_COUNT] Fetched timeline data..."
                fi
              done

              wait  # Wait for remaining jobs
              echo "Timeline data fetched for $count builds."

        - task: Bash@3
          displayName: Generate HTML dashboard
          env:
            PR_BUILD_DEF_ID: $(publicPRBuildDefinitionId)
            INTERNAL_BUILD_DEF_ID: $(internalBuildDefinitionId)
            ORG: $(organization)
            PROJECT: $(targetProject)
          inputs:
            targetType: 'inline'
            script: |
              set -eu -o pipefail

              METRICS_PATH="$(Build.ArtifactStagingDirectory)/metrics"
              MODE=$(cat "$METRICS_PATH/mode.txt")

              echo "=========================================="
              echo "Generating Build Dashboard HTML ($MODE mode)"
              echo "=========================================="

              BUILDS_FILE="$METRICS_PATH/builds.json"
              HTML_FILE="$(Build.ArtifactStagingDirectory)/index.html"

              # Check if jq is available
              if ! command -v jq &> /dev/null; then
                echo "Error: jq is required but not installed"
                echo "Install with: apt-get install jq (Ubuntu) or brew install jq (macOS)"
                exit 1
              fi

              # Set mode-specific variables
              if [ "$MODE" = "pr" ]; then
                BUILD_DEF_ID="$PR_BUILD_DEF_ID"
                TREND_DAYS=3
                TREND_LABEL="3-Day Trend"
                DASHBOARD_TITLE="FluidFramework PR Build Dashboard"
                SECTION_TITLE="Public PR Builds (Targeting main)"
                SECTION_ICON="üîÄ"
                CHART_COLOR="rgba(138, 43, 226, 1)"
                CHART_BG_COLOR="rgba(138, 43, 226, 0.1)"
                BUILD_TYPE="Pull Request"
                REASON_FILTER="pullRequest"
                BRANCH_INFO="Target Branch: <code>main</code>"
              else
                BUILD_DEF_ID="$INTERNAL_BUILD_DEF_ID"
                TREND_DAYS=7
                TREND_LABEL="7-Day Trend"
                DASHBOARD_TITLE="FluidFramework Post-Merge Build Dashboard"
                SECTION_TITLE="Internal Post-Merge Builds (main branch)"
                SECTION_ICON="üî®"
                CHART_COLOR="rgba(0, 120, 212, 1)"
                CHART_BG_COLOR="rgba(0, 120, 212, 0.1)"
                BUILD_TYPE="Post-Merge"
                REASON_FILTER="individualCI, batchedCI"
                BRANCH_INFO="Branch: <code>refs/heads/main</code>"
              fi

              echo "Processing build data..."

              # Process builds
              FILTERED_BUILDS=$(cat "$BUILDS_FILE" | jq '.value')
              TOTAL_BUILDS=$(echo "$FILTERED_BUILDS" | jq 'length')
              SUCCEEDED=$(echo "$FILTERED_BUILDS" | jq '[.[] | select(.result == "succeeded")] | length')
              PARTIAL=$(echo "$FILTERED_BUILDS" | jq '[.[] | select(.result == "partiallySucceeded")] | length')

              if [ "$TOTAL_BUILDS" -eq 0 ]; then
                SUCCESS_RATE="0.0"
                AVG_DURATION="0.0"
              else
                SUCCESS_RATE=$(awk "BEGIN {printf \"%.1f\", $SUCCEEDED * 100 / $TOTAL_BUILDS}")
                AVG_DURATION=$(echo "$FILTERED_BUILDS" | jq '[.[] | select(.startTime and .finishTime) |
                  (((.finishTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601) -
                    (.startTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601)) / 60)] |
                  add / length')
              fi

              echo "Builds - Total: $TOTAL_BUILDS, Success rate: $SUCCESS_RATE%, Avg duration: $AVG_DURATION minutes"

              # Calculate trend based on mode (3-day for PR, 7-day for post-merge)
              TREND_DATE=$(date -u -d "$TREND_DAYS days ago" +%Y-%m-%d 2>/dev/null || date -u -v-${TREND_DAYS}d +%Y-%m-%d)

              # Check if we have valid build data before processing
              if [ -z "$FILTERED_BUILDS" ] || [ "$FILTERED_BUILDS" = "null" ]; then
                echo "Warning: No valid build data available for trend calculation"
                DURATION_CHANGE="0.0"
                DURATION_CHANGE_MINUTES="0.0"
              else
                # Recent average (last N days)
                RECENT_AVG=$(echo "$FILTERED_BUILDS" | jq --arg date "$TREND_DATE" \
                  '[.[] | select(.startTime >= $date and .startTime and .finishTime) |
                   (((.finishTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601) -
                     (.startTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601)) / 60)] |
                   if length > 0 then add / length else 0 end' 2>/dev/null || echo "0")

                # All builds before the trend period
                PREVIOUS_AVG=$(echo "$FILTERED_BUILDS" | jq --arg date "$TREND_DATE" \
                  '[.[] | select(.startTime < $date and .startTime and .finishTime) |
                   (((.finishTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601) -
                     (.startTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601)) / 60)] |
                   if length > 0 then add / length else 0 end' 2>/dev/null || echo "0")

                if [ "$(awk -v prev="$PREVIOUS_AVG" 'BEGIN {print (prev > 0)}')" -eq 1 ]; then
                  DURATION_CHANGE=$(awk "BEGIN {printf \"%.1f\", (($RECENT_AVG - $PREVIOUS_AVG) / $PREVIOUS_AVG) * 100}")
                  DURATION_CHANGE_MINUTES=$(awk "BEGIN {printf \"%.1f\", $RECENT_AVG - $PREVIOUS_AVG}")
                else
                  DURATION_CHANGE="0.0"
                  DURATION_CHANGE_MINUTES="0.0"
                fi
              fi

              echo ""

              # Generate HTML dashboard with charts
              cat > "$HTML_FILE" << 'HTMLEOF'
              <!DOCTYPE html>
              <html lang="en">
              <head>
                  <meta charset="UTF-8">
                  <meta name="viewport" content="width=device-width, initial-scale=1.0">
                  <title>DASHBOARD_TITLE_PLACEHOLDER</title>
                  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üìä</text></svg>">

                  <!-- Load Chart.js -->
                  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
                  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

                  <style>
                      body {
                          font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif;
                          margin: 0;
                          padding: 20px;
                          background: #f5f5f5;
                      }
                      .container {
                          max-width: 1200px;
                          margin: 0 auto;
                      }
                      h1 {
                          color: #323130;
                          margin-bottom: 8px;
                      }
                      .timestamp {
                          color: #605e5c;
                          font-size: 14px;
                          margin-bottom: 24px;
                      }
                      .metrics {
                          display: grid;
                          grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                          gap: 16px;
                          margin-bottom: 24px;
                      }
                      .metric-card {
                          background: white;
                          padding: 20px;
                          border-radius: 4px;
                          box-shadow: 0 1.6px 3.6px rgba(0,0,0,.132);
                      }
                      .metric-label {
                          font-size: 12px;
                          color: #605e5c;
                          text-transform: uppercase;
                          letter-spacing: 0.5px;
                          margin-bottom: 8px;
                      }
                      .metric-value {
                          font-size: 32px;
                          font-weight: 600;
                          color: #323130;
                      }
                      .metric-card.success .metric-value {
                          color: #107c10;
                      }
                      .metric-card.warning .metric-value {
                          color: #ff8c00;
                      }
                      .metric-card {
                          position: relative;
                      }
                      .metric-label {
                          position: relative;
                          display: inline-block;
                      }
                      .info-icon {
                          display: inline;
                          color: #605e5c;
                          font-size: 14px;
                          margin-left: 4px;
                          position: relative;
                      }
                      .info-icon .tooltip {
                          visibility: hidden;
                          width: 220px;
                          background-color: #323130;
                          color: #fff;
                          text-align: center;
                          border-radius: 4px;
                          padding: 8px;
                          position: absolute;
                          z-index: 1;
                          bottom: 125%;
                          left: 50%;
                          margin-left: -110px;
                          opacity: 0;
                          transition: opacity 0.3s;
                          font-size: 11px;
                          text-transform: none;
                          letter-spacing: normal;
                          font-weight: normal;
                      }
                      .info-icon .tooltip::after {
                          content: "";
                          position: absolute;
                          top: 100%;
                          left: 50%;
                          margin-left: -5px;
                          border-width: 5px;
                          border-style: solid;
                          border-color: #323130 transparent transparent transparent;
                      }
                      .info-icon:hover .tooltip {
                          visibility: visible;
                          opacity: 1;
                      }
                      .metric-subtext {
                          font-size: 14px;
                          color: #605e5c;
                          margin-top: 4px;
                      }
                      .metric-percent {
                          font-size: 18px;
                          margin-left: 8px;
                          opacity: 0.8;
                      }
                      .info {
                          background: white;
                          padding: 16px;
                          border-radius: 4px;
                          box-shadow: 0 1.6px 3.6px rgba(0,0,0,.132);
                          margin-top: 24px;
                      }
                      .info h3 {
                          margin-top: 0;
                          color: #323130;
                      }
                      .info p {
                          color: #605e5c;
                          line-height: 1.6;
                      }
                      .info ul {
                          color: #605e5c;
                          line-height: 1.8;
                      }
                      .badge {
                          display: inline-block;
                          padding: 4px 12px;
                          background: #e1f5fe;
                          color: #0078d4;
                          border-radius: 12px;
                          font-size: 12px;
                          font-weight: 600;
                          margin-right: 8px;
                      }
                      .chart-container {
                          background: white;
                          padding: 16px;
                          border-radius: 4px;
                          box-shadow: 0 1.6px 3.6px rgba(0,0,0,.132);
                          margin-bottom: 24px;
                          position: relative;
                      }
                      .chart-container.duration-chart {
                          height: 320px;
                      }
                      .chart-container.stage-chart {
                          height: 420px;
                      }
                      h2 {
                          color: #323130;
                          font-size: 18px;
                          margin-top: 32px;
                          margin-bottom: 16px;
                      }
                  </style>
              </head>
              <body>
                  <div class="container">
                      <h1>DASHBOARD_TITLE_PLACEHOLDER</h1>
                      <div class="timestamp">
                          Generated: <span id="timestamp">TIMESTAMP_PLACEHOLDER</span>
                      </div>

                      <h2>SECTION_ICON_PLACEHOLDER SECTION_TITLE_PLACEHOLDER</h2>
                      <div class="timestamp">
                          <span class="badge">Build BUILD_DEF_ID_PLACEHOLDER</span>
                          <span class="badge">BUILD_TYPE_PLACEHOLDER</span>
                      </div>
                      <div class="metrics">
                          <div class="metric-card">
                              <div class="metric-label">Total Builds</div>
                              <div class="metric-value" id="totalBuilds">TOTAL_BUILDS_PLACEHOLDER</div>
                          </div>
                          <div class="metric-card">
                              <div class="metric-label">Avg Duration</div>
                              <div class="metric-value" id="avgDuration">AVG_DURATION_PLACEHOLDERm</div>
                          </div>
                          <div class="metric-card">
                              <div class="metric-label">
                                  TREND_LABEL_PLACEHOLDER
                                  <span class="info-icon">‚ìò
                                      <span class="tooltip">Compares average duration of last TREND_DAYS_PLACEHOLDER days vs the average of all builds before that</span>
                                  </span>
                              </div>
                              <div class="metric-value" id="durationChange" style="color: DURATION_CHANGE_COLOR">
                                  DURATION_CHANGE_SIGN_PLACEHOLDERDURATION_CHANGE_MINUTES_PLACEHOLDERm
                                  <span class="metric-percent">(DURATION_CHANGE_SIGN_PLACEHOLDERDURATION_CHANGE_PLACEHOLDER%)</span>
                              </div>
                          </div>
                      </div>

                      <h2>üìà Duration Trend</h2>
                      <div class="chart-container duration-chart">
                          <canvas id="durationTrendChart"></canvas>
                      </div>

                      <h2>üèóÔ∏è Duration by Stage</h2>
                      <div class="chart-container stage-chart">
                          <canvas id="stageBreakdownChart"></canvas>
                      </div>

                      <h2>üîç Individual Task Duration</h2>
                      <div class="chart-container stage-chart">
                          <canvas id="buildStageDetailChart"></canvas>
                      </div>

                      <div class="info">
                          <h3>üìä About This View</h3>
                          <p>
                              This view shows metrics for <strong>BUILD_TYPE_PLACEHOLDER builds</strong> from the PROJECT_PLACEHOLDER project.
                          </p>
                          <h4>Filters Applied:</h4>
                          <ul>
                              <li>Reason: <code>REASON_FILTER_PLACEHOLDER</code></li>
                              <li>BRANCH_INFO_PLACEHOLDER</li>
                              <li>Results: <code>succeeded</code> or <code>partiallySucceeded</code></li>
                              <li>Status: <code>completed</code></li>
                          </ul>
                          <h4>Data Source:</h4>
                          <ul>
                              <li>Azure DevOps Build API (v7.1)</li>
                              <li>Organization: <code>ORG_PLACEHOLDER</code></li>
                              <li>Project: <code>PROJECT_PLACEHOLDER</code></li>
                              <li>Pipeline ID: <code>BUILD_DEF_ID_PLACEHOLDER</code></li>
                          </ul>
                      </div>
                  </div>

                  <script>
                      // chartData will be injected here as: const chartData = {...};
                      // It contains: summary, durationTrend, stagePerformance, buildStageTasks

                      // Format timestamp nicely
                      function formatTimestamp() {
                          const timestampEl = document.getElementById('timestamp');
                          const isoString = timestampEl.textContent;
                          const date = new Date(isoString);

                          // Format: MM/DD/YYYY hh:mm AM/PM Timezone
                          const month = String(date.getMonth() + 1).padStart(2, '0');
                          const day = String(date.getDate()).padStart(2, '0');
                          const year = date.getFullYear();

                          let hours = date.getHours();
                          const minutes = String(date.getMinutes()).padStart(2, '0');
                          const ampm = hours >= 12 ? 'PM' : 'AM';
                          hours = hours % 12 || 12;

                          const timezone = date.toLocaleTimeString('en-us', {timeZoneName:'short'}).split(' ').pop();

                          timestampEl.textContent = `${month}/${day}/${year} ${hours}:${minutes} ${ampm} ${timezone}`;
                      }

                      // Color palette for stacked bar chart segments
                      const taskColors = [
                          'rgba(16, 124, 16, 0.8)',    // Green
                          'rgba(0, 120, 212, 0.8)',    // Blue
                          'rgba(138, 43, 226, 0.8)',   // Purple
                          'rgba(255, 140, 0, 0.8)',    // Orange
                          'rgba(209, 52, 56, 0.8)',    // Red
                          'rgba(0, 183, 195, 0.8)',    // Teal
                          'rgba(234, 67, 53, 0.8)',    // Coral
                          'rgba(52, 168, 83, 0.8)',    // Mint
                          'rgba(251, 188, 4, 0.8)',    // Yellow
                          'rgba(103, 58, 183, 0.8)',   // Deep Purple
                          'rgba(0, 150, 136, 0.8)',    // Dark Teal
                          'rgba(233, 30, 99, 0.8)',    // Pink
                      ];

                      function getTaskColor(index) {
                          return taskColors[index % taskColors.length];
                      }

                      function getTaskBorderColor(index) {
                          return getTaskColor(index).replace('0.8', '1');
                      }

                      // Create all charts once DOM is loaded
                      document.addEventListener('DOMContentLoaded', function() {
                          formatTimestamp();
                          createDurationTrendChart();
                          createStageBreakdownChart();
                          createBuildStageDetailChart();
                      });

                      function createDurationTrendChart() {
                          if (!chartData.durationTrend || chartData.durationTrend.length === 0) {
                              document.getElementById('durationTrendChart').parentElement.innerHTML = '<p style="padding: 20px; text-align: center; color: #605e5c;">No build data available</p>';
                              return;
                          }

                          const data = chartData.durationTrend.map(d => ({
                              x: new Date(d.date),
                              y: d.avgDuration
                          }));

                          const ctx = document.getElementById('durationTrendChart').getContext('2d');
                          new Chart(ctx, {
                              type: 'line',
                              data: {
                                  datasets: [{
                                      label: 'Avg Duration (minutes)',
                                      data: data,
                                      borderColor: chartData.chartColor || 'rgba(0, 120, 212, 1)',
                                      backgroundColor: chartData.chartBgColor || 'rgba(0, 120, 212, 0.1)',
                                      borderWidth: 2,
                                      fill: true,
                                      tension: 0.4
                                  }]
                              },
                              options: {
                                  responsive: true,
                                  maintainAspectRatio: false,
                                  plugins: {
                                      legend: {
                                          onClick: null
                                      },
                                      title: {
                                          display: true,
                                          text: 'Average Build Duration Per Day',
                                          font: { size: 14, weight: 'bold' }
                                      },
                                      tooltip: {
                                          callbacks: {
                                              title: function(context) {
                                                  const date = new Date(context[0].parsed.x);
                                                  return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                                              }
                                          }
                                      }
                                  },
                                  scales: {
                                      x: {
                                          type: 'time',
                                          time: { unit: 'day' },
                                          title: { display: true, text: 'Date' }
                                      },
                                      y: {
                                          beginAtZero: true,
                                          title: { display: true, text: 'Duration (minutes)' }
                                      }
                                  }
                              }
                          });
                      }

                      function createStageBreakdownChart() {
                          // Create stacked horizontal bar chart with task breakdown per stage
                          const stageData = chartData.stageTaskBreakdown || {};
                          const stagePerf = chartData.stagePerformance || [];
                          const stages = Object.keys(stageData).sort();

                          if (stages.length === 0) {
                              document.getElementById('stageBreakdownChart').parentElement.innerHTML = '<p style="padding: 20px; text-align: center; color: #605e5c;">No stage data available</p>';
                              return;
                          }

                          // For stages with no tasks, use stage total duration as single segment
                          const stageAvgDurations = {};
                          stagePerf.forEach(s => { stageAvgDurations[s.name] = s.avgDuration; });

                          // Collect all unique task names across all stages
                          const allTasks = new Set();
                          stages.forEach(stage => {
                              const tasks = stageData[stage] || [];
                              if (tasks.length === 0) {
                                  allTasks.add(stage);
                              } else {
                                  tasks.forEach(task => allTasks.add(task.name));
                              }
                          });
                          const taskNames = Array.from(allTasks).sort();

                          // Create datasets - one per task
                          const datasets = taskNames.map((taskName, index) => ({
                              label: taskName,
                              data: stages.map(stage => {
                                  const tasks = stageData[stage] || [];
                                  if (tasks.length === 0 && taskName === stage) {
                                      return stageAvgDurations[stage] || 0;
                                  }
                                  const task = tasks.find(t => t.name === taskName);
                                  return task ? task.avgDuration : 0;
                              }),
                              backgroundColor: getTaskColor(index),
                              borderColor: getTaskBorderColor(index),
                              borderWidth: 1
                          }));

                          const ctx = document.getElementById('stageBreakdownChart').getContext('2d');
                          new Chart(ctx, {
                              type: 'bar',
                              data: { labels: stages, datasets },
                              options: {
                                  indexAxis: 'y',
                                  responsive: true,
                                  maintainAspectRatio: false,
                                  plugins: {
                                      legend: {
                                          onClick: null,
                                          position: 'bottom',
                                          labels: { boxWidth: 12, padding: 8 }
                                      },
                                      title: {
                                          display: true,
                                          text: 'Average Duration by Stage/Task',
                                          font: { size: 14, weight: 'bold' }
                                      },
                                      tooltip: {
                                          callbacks: {
                                              label: function(context) {
                                                  const value = context.parsed.x;
                                                  if (value === 0) return null;
                                                  return `${context.dataset.label}: ${value.toFixed(1)}m`;
                                              }
                                          }
                                      }
                                  },
                                  scales: {
                                      x: {
                                          stacked: true,
                                          beginAtZero: true,
                                          title: { display: true, text: 'Duration (minutes)' }
                                      },
                                      y: {
                                          stacked: true,
                                          title: { display: true, text: 'Stage' }
                                      }
                                  }
                              }
                          });
                      }

                      function createBuildStageDetailChart() {
                          // Create detailed breakdown chart showing all individual tasks from all stages
                          const stageData = chartData.stageTaskBreakdown || {};
                          const stagePerf = chartData.stagePerformance || [];

                          if (Object.keys(stageData).length === 0) {
                              document.getElementById('buildStageDetailChart').parentElement.innerHTML = '<p style="padding: 20px; text-align: center; color: #605e5c;">No task data available</p>';
                              return;
                          }

                          // Flatten all tasks with their stage prefix and track which stage each task belongs to
                          const allTasks = [];
                          const stageAvgDurations = {};
                          stagePerf.forEach(s => { stageAvgDurations[s.name] = s.avgDuration; });

                          // Assign a color index to each stage
                          const stages = Object.keys(stageData).sort();
                          const stageColorMap = {};
                          stages.forEach((stage, idx) => {
                              stageColorMap[stage] = idx;
                          });

                          Object.keys(stageData).sort().forEach(stage => {
                              const tasks = stageData[stage] || [];
                              if (tasks.length === 0) {
                                  // Stage with no tasks - add the stage itself
                                  allTasks.push({
                                      label: stage,
                                      duration: stageAvgDurations[stage] || 0,
                                      stageIndex: stageColorMap[stage]
                                  });
                              } else {
                                  // Add each task with stage prefix for context
                                  tasks.forEach(task => {
                                      allTasks.push({
                                          label: `${stage} ‚Ä∫ ${task.name}`,
                                          duration: task.avgDuration,
                                          stageIndex: stageColorMap[stage]
                                      });
                                  });
                              }
                          });

                          // Sort by duration descending
                          allTasks.sort((a, b) => b.duration - a.duration);

                          const labels = allTasks.map(t => t.label);
                          const durations = allTasks.map(t => t.duration);
                          const backgroundColors = allTasks.map(t => getTaskColor(t.stageIndex));
                          const borderColors = allTasks.map(t => getTaskBorderColor(t.stageIndex));

                          const ctx = document.getElementById('buildStageDetailChart').getContext('2d');
                          new Chart(ctx, {
                              type: 'bar',
                              data: {
                                  labels: labels,
                                  datasets: [{
                                      label: 'Avg Duration (minutes)',
                                      data: durations,
                                      backgroundColor: backgroundColors,
                                      borderColor: borderColors,
                                      borderWidth: 1
                                  }]
                              },
                              options: {
                                  indexAxis: 'y',
                                  responsive: true,
                                  maintainAspectRatio: false,
                                  plugins: {
                                      legend: {
                                          display: false
                                      },
                                      title: {
                                          display: true,
                                          text: 'Longest Average Individual Tasks',
                                          font: { size: 14, weight: 'bold' }
                                      },
                                      tooltip: {
                                          callbacks: {
                                              label: function(context) {
                                                  return context.parsed.x.toFixed(1) + 'm';
                                              }
                                          }
                                      }
                                  },
                                  scales: {
                                      x: {
                                          beginAtZero: true,
                                          title: { display: true, text: 'Duration (minutes)' }
                                      },
                                      y: {
                                          title: { display: true, text: 'Task' }
                                      }
                                  }
                              }
                          });
                      }
                  </script>
              </body>
              </html>
              HTMLEOF

              # Replace placeholders with actual values
              sed -i "s/TIMESTAMP_PLACEHOLDER/$(date +%Y-%m-%dT%H:%M:%S%z | sed 's/\([0-9][0-9]\)$/:\1/')/g" "$HTML_FILE"
              sed -i "s/ORG_PLACEHOLDER/$ORG/g" "$HTML_FILE"
              sed -i "s/PROJECT_PLACEHOLDER/$PROJECT/g" "$HTML_FILE"
              sed -i "s/BUILD_DEF_ID_PLACEHOLDER/$BUILD_DEF_ID/g" "$HTML_FILE"
              sed -i "s/AVG_DURATION_PLACEHOLDER/$(printf '%.1f' $AVG_DURATION)/g" "$HTML_FILE"
              sed -i "s/TOTAL_BUILDS_PLACEHOLDER/$TOTAL_BUILDS/g" "$HTML_FILE"
              sed -i "s/DASHBOARD_TITLE_PLACEHOLDER/$DASHBOARD_TITLE/g" "$HTML_FILE"
              sed -i "s/SECTION_TITLE_PLACEHOLDER/$SECTION_TITLE/g" "$HTML_FILE"
              sed -i "s/SECTION_ICON_PLACEHOLDER/$SECTION_ICON/g" "$HTML_FILE"
              sed -i "s/BUILD_TYPE_PLACEHOLDER/$BUILD_TYPE/g" "$HTML_FILE"
              sed -i "s/TREND_LABEL_PLACEHOLDER/$TREND_LABEL/g" "$HTML_FILE"
              sed -i "s/TREND_DAYS_PLACEHOLDER/$TREND_DAYS/g" "$HTML_FILE"
              sed -i "s/REASON_FILTER_PLACEHOLDER/$REASON_FILTER/g" "$HTML_FILE"
              sed -i "s|BRANCH_INFO_PLACEHOLDER|$BRANCH_INFO|g" "$HTML_FILE"

              # Replace duration change placeholders with color coding
              if [ "$(awk -v val="$DURATION_CHANGE" 'BEGIN {print (val < 0)}')" -eq 1 ]; then
                DURATION_CHANGE_COLOR="#107c10"
                DURATION_CHANGE_SIGN="-"
              elif [ "$(awk -v val="$DURATION_CHANGE" 'BEGIN {print (val > 0)}')" -eq 1 ]; then
                DURATION_CHANGE_COLOR="#d13438"
                DURATION_CHANGE_SIGN="+"
              else
                DURATION_CHANGE_COLOR="#605e5c"
                DURATION_CHANGE_SIGN=""
              fi
              sed -i "s/DURATION_CHANGE_SIGN_PLACEHOLDER/$DURATION_CHANGE_SIGN/g" "$HTML_FILE"
              sed -i "s/DURATION_CHANGE_MINUTES_PLACEHOLDER/$(echo $DURATION_CHANGE_MINUTES | sed 's/-//')/g" "$HTML_FILE"
              sed -i "s/DURATION_CHANGE_PLACEHOLDER/$(echo $DURATION_CHANGE | sed 's/-//')/g" "$HTML_FILE"
              sed -i "s/DURATION_CHANGE_COLOR/$DURATION_CHANGE_COLOR/g" "$HTML_FILE"

              # Generate chart-ready data (aggregated metrics only)
              echo "Generating chart data..."

              # Create chart data JSON with pre-aggregated metrics
              echo "$FILTERED_BUILDS" | jq --arg chartColor "$CHART_COLOR" --arg chartBgColor "$CHART_BG_COLOR" '
                # Build duration trend (avg per day)
                (group_by(.startTime | split("T")[0]) | map({
                  date: .[0].startTime | split("T")[0],
                  avgDuration: (map((.finishTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601) - (.startTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601)) | add / length / 60)
                })) as $durationTrend |

                {
                  summary: {
                    totalBuilds: (. | length),
                    succeeded: (map(select(.result == "succeeded")) | length),
                    successRate: ((map(select(.result == "succeeded")) | length) * 100 / (. | length)),
                    avgDuration: (map((.finishTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601) - (.startTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601)) | add / length / 60)
                  },
                  durationTrend: $durationTrend,
                  buildIds: (map(.id)),
                  chartColor: $chartColor,
                  chartBgColor: $chartBgColor
                }
              ' > "$(Build.ArtifactStagingDirectory)/chart-data.json"

              # Process timeline data to extract stage and task metrics
              # STAGE_DATA: { "StageName": [duration1, duration2, ...] }
              # STAGE_TASKS_DATA: { "StageName": { "TaskName": [duration1, duration2, ...] } }
              STAGE_DATA="{}"
              STAGE_TASKS_DATA="{}"

              # Process build timelines
              for timeline_file in "$METRICS_PATH/timelines"/*.json; do
                if [ -f "$timeline_file" ]; then
                  # Extract stage durations (with null check)
                  stage_metrics=$(jq -c 'if .records == null then [] else [.records[] | select(.type == "Stage" and .startTime and .finishTime) | {name: .name, duration: (((.finishTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601) - (.startTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601)) / 60), id: .id}] end' "$timeline_file" 2>/dev/null || echo "[]")

                  # Aggregate stage data
                  if [ "$stage_metrics" != "[]" ]; then
                    STAGE_DATA=$(echo "$STAGE_DATA" | jq --argjson stages "$stage_metrics" '
                      reduce $stages[] as $s (.; .[$s.name] += [$s.duration])
                    ')
                  fi

                  # Extract tasks for ALL stages (grouped by stage name)
                  # Note: .records must be captured as $records before reduce, since inside reduce `.` is the accumulator
                  stage_task_metrics=$(jq -c '
                    if .records == null then {} else
                    .records as $records |
                    [.records[] | select(.type == "Stage" and .startTime and .finishTime)] as $stages |
                    reduce $stages[] as $stage ({};
                      .[$stage.name] = [
                        $records[] | select(.type == "Phase" and .parentId == $stage.id and .startTime and .finishTime) | {
                          name: .name,
                          duration: (((.finishTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601) - (.startTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601)) / 60)
                        }
                      ]
                    )
                    end
                  ' "$timeline_file" 2>/dev/null || echo "{}")

                  # Aggregate stage task data
                  if [ "$stage_task_metrics" != "{}" ]; then
                    STAGE_TASKS_DATA=$(echo "$STAGE_TASKS_DATA" | jq --argjson stageTaskData "$stage_task_metrics" '
                      reduce ($stageTaskData | to_entries[]) as $stage (.;
                        reduce $stage.value[] as $task (.;
                          .[$stage.key][$task.name] += [$task.duration]
                        )
                      )
                    ')
                  fi
                fi
              done

              # Calculate averages and add to chart data
              # stageTaskBreakdown: { "StageName": [{ "name": "TaskName", "avgDuration": X }, ...] }
              jq --argjson stages "$STAGE_DATA" --argjson stageTasks "$STAGE_TASKS_DATA" '
                .stagePerformance = ($stages | to_entries | map({name: .key, avgDuration: ((.value | add) / (.value | length))})) |
                .stageTaskBreakdown = ($stageTasks | to_entries | map({
                  key: .key,
                  value: (.value | to_entries | map({name: .key, avgDuration: ((.value | add) / (.value | length))}))
                }) | from_entries)
              ' "$(Build.ArtifactStagingDirectory)/chart-data.json" > "$(Build.ArtifactStagingDirectory)/chart-data.tmp.json"
              mv "$(Build.ArtifactStagingDirectory)/chart-data.tmp.json" "$(Build.ArtifactStagingDirectory)/chart-data.json"

              # Embed chart data into HTML by injecting it right after the opening <script> tag
              CHART_DATA=$(cat "$(Build.ArtifactStagingDirectory)/chart-data.json" | jq -c '.')

              # Create the data script that will be injected
              DATA_SCRIPT="const chartData = $CHART_DATA;"

              # Inject the chartData into the HTML after the opening <script> tag
              sed -i "s|// chartData will be injected here as: const chartData = {...};|$DATA_SCRIPT|" "$HTML_FILE"

              # Remove intermediate chart-data.json file
              rm "$(Build.ArtifactStagingDirectory)/chart-data.json"

              echo "Dashboard generated successfully."
              echo "Data size: $(echo "$CHART_DATA" | wc -c) bytes"
              echo ""
              echo "üì¶ Published Artifact:"
              echo "  ‚Ä¢ index.html"
              echo ""
              echo "View: https://dev.azure.com/$ORG/$PROJECT/_build/results?buildId=$(Build.BuildId)&view=artifacts"
        - task: Bash@3
          displayName: Clean up extraneous files
          inputs:
            targetType: 'inline'
            script: |
              echo "Cleaning up extraneous files..."
              rm -rf $(Build.ArtifactStagingDirectory)/metrics
              echo "Extraneous files cleaned up!"
