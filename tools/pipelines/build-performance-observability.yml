# Copyright (c) Microsoft Corporation and contributors. All rights reserved.
# Licensed under the MIT License.

# build-performance-observability pipeline
# This pipeline collects build metrics using ADO REST APIs and generates an HTML dashboard
# When run from the "public" project: collects PR build metrics
# When run from the "internal" project: collects post-merge build metrics

name: $(Build.BuildId)

# Schedule to run daily at 2 AM UTC
# schedules:
# - cron: "0 2 * * *"
#   displayName: Daily build metrics collection
#   branches:
#     include:
#     - main
#   always: true

trigger: none

pr: none

variables:
  # Contains keys to upload dashboard to ASWA
  - group: build-perf-dashboard-vars
  # Number of recent builds to fetch
  - name: buildCount
    value: 500
  # Organization
  - name: organization
    value: fluidframework
  # Mode: public = PR builds, internal = post-merge builds
  - name: isPublicProject
    value: ${{ eq(variables['System.TeamProject'], 'public') }}
  # Build definition IDs
  - name: publicPRBuildDefinitionId
    value: 11
  - name: internalBuildDefinitionId
    value: 12
  # Project to query (same as where pipeline runs)
  - name: targetProject
    value: $(System.TeamProject)

resources:
  repositories:
  - repository: m365Pipelines
    type: git
    name: 1ESPipelineTemplates/M365GPT
    ref: refs/tags/release

extends:
  ${{ if eq(variables['System.TeamProject'], 'internal') }}:
    template: v1/M365.Official.PipelineTemplate.yml@m365Pipelines
  ${{ else }}:
    template: v1/M365.Unofficial.PipelineTemplate.yml@m365Pipelines
  parameters:
    customBuildTags:
    - ES365AIMigrationTooling
    pool:
      name: Small-eastus2
      os: linux
    sdl:
      sourceAnalysisPool:
        name: Azure-Pipelines-1ESPT-ExDShared
        image: windows-2022
        os: windows

    stages:
    - stage: collect_metrics
      displayName: Collect Build Metrics
      jobs:
      - job: fetch_and_publish
        displayName: Fetch and Publish Build Metrics
        steps:
        - checkout: none

        - task: Bash@3
          displayName: Fetch build data
          env:
            ADO_API_TOKEN: $(System.AccessToken)
            PR_BUILD_DEF_ID: $(publicPRBuildDefinitionId)
            INTERNAL_BUILD_DEF_ID: $(internalBuildDefinitionId)
            BUILD_COUNT: $(buildCount)
            ORG: $(organization)
            PROJECT: $(targetProject)
            IS_PUBLIC: $(isPublicProject)
          inputs:
            targetType: 'inline'
            script: |
              set -eu -o pipefail

              # Determine mode based on project
              if [ "$IS_PUBLIC" = "True" ]; then
                MODE="pr"
                BUILD_DEF_ID="$PR_BUILD_DEF_ID"
              else
                MODE="postmerge"
                BUILD_DEF_ID="$INTERNAL_BUILD_DEF_ID"
              fi

              echo "=========================================="
              echo "Fetching build metrics"
              echo "=========================================="
              echo "Mode: $MODE"
              echo "Organization: $ORG"
              echo "Project: $PROJECT"
              echo "Build Definition: $BUILD_DEF_ID"
              echo "Build Count: $BUILD_COUNT"
              echo ""

              # Create output directory
              mkdir -p $(Build.ArtifactStagingDirectory)/metrics

              # Save mode for subsequent tasks
              echo "$MODE" > $(Build.ArtifactStagingDirectory)/metrics/mode.txt

              if [ "$MODE" = "pr" ]; then
                # Fetch PR builds with reasonFilter and statusFilter
                echo "Fetching last $BUILD_COUNT PR builds (reason=pullRequest, succeeded/partiallySucceeded, completed)..."

                curl -u ":$ADO_API_TOKEN" \
                  "https://dev.azure.com/$ORG/$PROJECT/_apis/build/builds?definitions=$BUILD_DEF_ID&reasonFilter=pullRequest&resultFilter=succeeded,partiallySucceeded&statusFilter=completed&\$top=$BUILD_COUNT&api-version=7.1" \
                  -o $(Build.ArtifactStagingDirectory)/metrics/builds-raw.json
              else
                # Fetch post-merge builds from main branch
                echo "Fetching last $BUILD_COUNT post-merge builds (branch=main, succeeded/partiallySucceeded, completed)..."

                curl -u ":$ADO_API_TOKEN" \
                  "https://dev.azure.com/$ORG/$PROJECT/_apis/build/builds?definitions=$BUILD_DEF_ID&branchName=refs/heads/main&resultFilter=succeeded,partiallySucceeded&statusFilter=completed&\$top=$BUILD_COUNT&api-version=7.1" \
                  -o $(Build.ArtifactStagingDirectory)/metrics/builds-raw.json
              fi

              echo "Build data fetched successfully!"

        - task: Bash@3
          displayName: Filter builds (PR mode only)
          inputs:
            targetType: 'inline'
            script: |
              set -eu -o pipefail

              MODE=$(cat $(Build.ArtifactStagingDirectory)/metrics/mode.txt)

              if [ "$MODE" = "pr" ]; then
                echo "=========================================="
                echo "Filtering PR builds by target branch (main)"
                echo "=========================================="

                # Filter PR builds to only include those targeting main branch
                # The target branch is in the parameters field as JSON string: "system.pullRequest.targetBranch"

                cat $(Build.ArtifactStagingDirectory)/metrics/builds-raw.json | jq '
                  .value |= map(select(
                    .parameters != null and
                    (.parameters | fromjson | .["system.pullRequest.targetBranch"] == "main")
                  ))
                ' > $(Build.ArtifactStagingDirectory)/metrics/builds.json

                TOTAL_AFTER=$(cat $(Build.ArtifactStagingDirectory)/metrics/builds.json | jq '.value | length')
                echo "Filtered to $TOTAL_AFTER PR builds targeting main branch"
              else
                echo "=========================================="
                echo "Post-merge mode - no filtering needed"
                echo "=========================================="

                # Just copy the raw file to builds.json
                cp $(Build.ArtifactStagingDirectory)/metrics/builds-raw.json $(Build.ArtifactStagingDirectory)/metrics/builds.json

                TOTAL=$(cat $(Build.ArtifactStagingDirectory)/metrics/builds.json | jq '.value | length')
                echo "Total post-merge builds: $TOTAL"
              fi

        - task: Bash@3
          displayName: Fetch timeline data for builds
          env:
            ADO_API_TOKEN: $(System.AccessToken)
            ORG: $(organization)
            PROJECT: $(targetProject)
          inputs:
            targetType: 'inline'
            script: |
              set -eu -o pipefail

              MODE=$(cat $(Build.ArtifactStagingDirectory)/metrics/mode.txt)

              echo "=========================================="
              echo "Fetching timeline data for builds ($MODE mode)"
              echo "=========================================="

              # Extract build IDs from filtered builds
              BUILD_IDS=$(cat $(Build.ArtifactStagingDirectory)/metrics/builds.json | jq -r '.value[] | .id')

              TOTAL_COUNT=$(echo "$BUILD_IDS" | wc -l | tr -d ' ')
              echo "Found $TOTAL_COUNT builds to fetch timeline data for"
              echo ""

              mkdir -p $(Build.ArtifactStagingDirectory)/metrics/timelines

              # Fetch in parallel using background jobs (20 at a time to avoid overwhelming the API)
              PARALLEL_JOBS=20
              count=0

              fetch_timeline() {
                local build_id=$1
                local output_file=$2
                curl -s -u ":$ADO_API_TOKEN" \
                  "https://dev.azure.com/$ORG/$PROJECT/_apis/build/builds/$build_id/timeline?api-version=7.1-preview.2" \
                  -o "$output_file" 2>/dev/null
              }

              for BUILD_ID in $BUILD_IDS; do
                count=$((count + 1))

                # Start background job
                fetch_timeline "$BUILD_ID" "$(Build.ArtifactStagingDirectory)/metrics/timelines/timeline_$BUILD_ID.json" &

                # Limit concurrent jobs
                if (( count % PARALLEL_JOBS == 0 )); then
                  wait  # Wait for current batch to complete
                  echo "[$count/$TOTAL_COUNT] Fetched timeline data..."
                fi
              done

              wait  # Wait for remaining jobs
              echo "Timeline data fetched for $count builds."

        - task: Bash@3
          displayName: Generate metrics JSON
          env:
            ORG: $(organization)
            PROJECT: $(targetProject)
          inputs:
            targetType: 'inline'
            script: |
              set -eu -o pipefail

              METRICS_PATH="$(Build.ArtifactStagingDirectory)/metrics"
              MODE=$(cat "$METRICS_PATH/mode.txt")

              echo "=========================================="
              echo "Generating metrics JSON ($MODE mode)"
              echo "=========================================="

              BUILDS_FILE="$METRICS_PATH/builds.json"

              # Check if jq is available
              if ! command -v jq &> /dev/null; then
                echo "Error: jq is required but not installed"
                exit 1
              fi

              # Process builds
              FILTERED_BUILDS=$(cat "$BUILDS_FILE" | jq '.value')
              TOTAL_BUILDS=$(echo "$FILTERED_BUILDS" | jq 'length')

              echo "Processing $TOTAL_BUILDS builds..."

              # Set output filename based on mode
              if [ "$MODE" = "pr" ]; then
                OUTPUT_FILE="$(Build.ArtifactStagingDirectory)/pr-data.json"
              else
                OUTPUT_FILE="$(Build.ArtifactStagingDirectory)/internal-data.json"
              fi

              # Generate chart data JSON with pre-aggregated metrics
              echo "$FILTERED_BUILDS" | jq --arg org "$ORG" --arg project "$PROJECT" --arg generatedAt "$(date -u +%Y-%m-%dT%H:%M:%SZ)" '
                # Build duration trend (avg per day)
                (group_by(.startTime | split("T")[0]) | map({
                  date: .[0].startTime | split("T")[0],
                  avgDuration: (map((.finishTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601) - (.startTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601)) | add / length / 60)
                })) as $durationTrend |

                # Recent 20 builds for table (sorted by date descending)
                ([.[] | select(.startTime and .finishTime) | {
                  id: .id,
                  startTime: .startTime,
                  duration: (((.finishTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601) - (.startTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601)) / 60),
                  result: .result,
                  source: (if (.sourceBranch // "") | startswith("refs/pull/") then "PR #" + ((.sourceBranch // "") | split("/")[2] // "N/A") elif .sourceVersion then .sourceVersion[0:7] else (.sourceBranch // "N/A" | tostring | .[0:30]) end),
                  sourceUrl: (if (.sourceBranch // "") | startswith("refs/pull/") then "https://github.com/microsoft/FluidFramework/pull/" + ((.sourceBranch // "") | split("/")[2] // "") else "https://github.com/microsoft/FluidFramework/commit/" + (.sourceVersion // "") end),
                  url: "https://dev.azure.com/\($org)/\($project)/_build/results?buildId=\(.id)"
                }] | sort_by(.startTime) | reverse | .[0:20]) as $recentBuilds |

                # Longest 20 builds for table (sorted by duration descending)
                ([.[] | select(.startTime and .finishTime) | {
                  id: .id,
                  startTime: .startTime,
                  duration: (((.finishTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601) - (.startTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601)) / 60),
                  result: .result,
                  source: (if (.sourceBranch // "") | startswith("refs/pull/") then "PR #" + ((.sourceBranch // "") | split("/")[2] // "N/A") elif .sourceVersion then .sourceVersion[0:7] else (.sourceBranch // "N/A" | tostring | .[0:30]) end),
                  sourceUrl: (if (.sourceBranch // "") | startswith("refs/pull/") then "https://github.com/microsoft/FluidFramework/pull/" + ((.sourceBranch // "") | split("/")[2] // "") else "https://github.com/microsoft/FluidFramework/commit/" + (.sourceVersion // "") end),
                  url: "https://dev.azure.com/\($org)/\($project)/_build/results?buildId=\(.id)"
                }] | sort_by(.duration) | reverse | .[0:20]) as $longestBuilds |

                {
                  generatedAt: $generatedAt,
                  summary: {
                    totalBuilds: (. | length),
                    succeeded: (map(select(.result == "succeeded")) | length),
                    successRate: ((map(select(.result == "succeeded")) | length) * 100 / (. | length)),
                    avgDuration: (map((.finishTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601) - (.startTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601)) | add / length / 60)
                  },
                  durationTrend: $durationTrend,
                  recentBuilds: $recentBuilds,
                  longestBuilds: $longestBuilds
                }
              ' > "$OUTPUT_FILE"

              # Process timeline data to extract stage and task metrics
              STAGE_DATA="{}"
              STAGE_TASKS_DATA="{}"

              for timeline_file in "$METRICS_PATH/timelines"/*.json; do
                if [ -f "$timeline_file" ]; then
                  stage_metrics=$(jq -c 'if .records == null then [] else [.records[] | select(.type == "Stage" and .startTime and .finishTime) | {name: .name, duration: (((.finishTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601) - (.startTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601)) / 60), id: .id}] end' "$timeline_file" 2>/dev/null || echo "[]")

                  if [ "$stage_metrics" != "[]" ]; then
                    STAGE_DATA=$(echo "$STAGE_DATA" | jq --argjson stages "$stage_metrics" '
                      reduce $stages[] as $s (.; .[$s.name] += [$s.duration])
                    ')
                  fi

                  stage_task_metrics=$(jq -c '
                    if .records == null then {} else
                    .records as $records |
                    [.records[] | select(.type == "Stage" and .startTime and .finishTime)] as $stages |
                    reduce $stages[] as $stage ({};
                      .[$stage.name] = [
                        $records[] | select(.type == "Phase" and .parentId == $stage.id and .startTime and .finishTime) | {
                          name: .name,
                          duration: (((.finishTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601) - (.startTime | sub("\\.[0-9]+Z$"; "Z") | fromdateiso8601)) / 60)
                        }
                      ]
                    )
                    end
                  ' "$timeline_file" 2>/dev/null || echo "{}")

                  if [ "$stage_task_metrics" != "{}" ]; then
                    STAGE_TASKS_DATA=$(echo "$STAGE_TASKS_DATA" | jq --argjson stageTaskData "$stage_task_metrics" '
                      reduce ($stageTaskData | to_entries[]) as $stage (.;
                        reduce $stage.value[] as $task (.;
                          .[$stage.key][$task.name] += [$task.duration]
                        )
                      )
                    ')
                  fi
                fi
              done

              # Add stage data to output JSON
              jq --argjson stages "$STAGE_DATA" --argjson stageTasks "$STAGE_TASKS_DATA" '
                .stagePerformance = ($stages | to_entries | map({name: .key, avgDuration: ((.value | add) / (.value | length))})) |
                .stageTaskBreakdown = ($stageTasks | to_entries | map({
                  key: .key,
                  value: (.value | to_entries | map({name: .key, avgDuration: ((.value | add) / (.value | length))}))
                }) | from_entries)
              ' "$OUTPUT_FILE" > "${OUTPUT_FILE}.tmp"
              mv "${OUTPUT_FILE}.tmp" "$OUTPUT_FILE"

              echo "Metrics JSON generated: $OUTPUT_FILE"
              echo "Data size: $(wc -c < "$OUTPUT_FILE") bytes"

        - task: Bash@3
          displayName: Prepare deployment package
          env:
            ASWA_HOSTNAME: $(ASWA_HOSTNAME)
          inputs:
            targetType: 'inline'
            script: |
              set -eu -o pipefail

              MODE=$(cat $(Build.ArtifactStagingDirectory)/metrics/mode.txt)
              DEPLOY_DIR="$(Build.ArtifactStagingDirectory)/deploy"

              echo "=========================================="
              echo "Preparing deployment package ($MODE mode)"
              echo "=========================================="

              mkdir -p "$DEPLOY_DIR/data"

              # Copy our generated data file
              if [ "$MODE" = "pr" ]; then
                cp "$(Build.ArtifactStagingDirectory)/pr-data.json" "$DEPLOY_DIR/data/pr-data.json"
                OTHER_FILE="internal-data.json"
              else
                cp "$(Build.ArtifactStagingDirectory)/internal-data.json" "$DEPLOY_DIR/data/internal-data.json"
                OTHER_FILE="pr-data.json"
              fi

              # Try to fetch the other mode's data from the live site (may not exist yet)
              echo "Fetching existing $OTHER_FILE from dashboard..."
              if curl -sf "https://$ASWA_HOSTNAME/data/$OTHER_FILE" -o "$DEPLOY_DIR/data/$OTHER_FILE" 2>/dev/null; then
                echo "Successfully fetched $OTHER_FILE"
              else
                echo "Note: $OTHER_FILE not available yet (first deployment or other mode hasn't run)"
              fi

              # Write staticwebapp.config.json inline
              cat > "$DEPLOY_DIR/staticwebapp.config.json" << 'CONFIGEOF'
              {
                "auth": {
                  "identityProviders": {
                    "azureActiveDirectory": {
                      "login": {
                        "loginParameters": ["scope=openid"]
                      }
                    }
                  }
                },
                "routes": [
                  {
                    "route": "/data/*",
                    "allowedRoles": ["anonymous", "authenticated"]
                  },
                  {
                    "route": "/*",
                    "allowedRoles": ["authenticated"]
                  }
                ],
                "responseOverrides": {
                  "401": {
                    "statusCode": 302,
                    "redirect": "/.auth/login/aad"
                  }
                },
                "globalHeaders": {
                  "Cache-Control": "no-cache"
                }
              }
              CONFIGEOF

              # Write index.html inline
              cat > "$DEPLOY_DIR/index.html" << 'HTMLEOF'
              <!DOCTYPE html>
              <html lang="en">
              <head>
                  <meta charset="UTF-8">
                  <meta name="viewport" content="width=device-width, initial-scale=1.0">
                  <title>FluidFramework Build Dashboard</title>
                  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üìä</text></svg>">
                  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
                  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
                  <style>
                      * { box-sizing: border-box; }
                      body { font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
                      .container { max-width: 1200px; margin: 0 auto; }
                      h1 { color: #323130; margin-bottom: 8px; }
                      .header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; }
                      .tabs { display: flex; gap: 4px; background: #e1dfdd; padding: 4px; border-radius: 8px; }
                      .tab { padding: 10px 24px; border: none; background: transparent; cursor: pointer; font-size: 14px; font-weight: 500; color: #605e5c; border-radius: 6px; transition: all 0.2s; }
                      .tab:hover { background: rgba(255,255,255,0.5); }
                      .tab.active { background: white; color: #323130; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
                      .tab.pr.active { color: #8b5cf6; }
                      .tab.internal.active { color: #0078d4; }
                      .tab-content { display: none; }
                      .tab-content.active { display: block; }
                      .loading { text-align: center; padding: 60px 20px; color: #605e5c; }
                      .loading-spinner { width: 40px; height: 40px; border: 3px solid #e1dfdd; border-top-color: #0078d4; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 16px; }
                      @keyframes spin { to { transform: rotate(360deg); } }
                      .no-data { text-align: center; padding: 60px 20px; color: #605e5c; background: white; border-radius: 8px; box-shadow: 0 1.6px 3.6px rgba(0,0,0,.132); }
                      .no-data h3 { margin: 0 0 8px; color: #323130; }
                      .timestamp { color: #605e5c; font-size: 14px; margin-bottom: 24px; }
                      .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 24px; }
                      .metric-card { background: white; padding: 20px; border-radius: 4px; box-shadow: 0 1.6px 3.6px rgba(0,0,0,.132); }
                      .metric-label { font-size: 12px; color: #605e5c; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; display: flex; align-items: center; gap: 4px; }
                      .metric-value { font-size: 32px; font-weight: 600; color: #323130; }
                      .metric-subtext { font-size: 14px; color: #605e5c; margin-top: 4px; }
                      .info-icon { position: relative; cursor: help; }
                      .info-icon .tooltip { visibility: hidden; width: 220px; background-color: #323130; color: #fff; text-align: center; border-radius: 4px; padding: 8px; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -110px; opacity: 0; transition: opacity 0.3s; font-size: 11px; text-transform: none; letter-spacing: normal; font-weight: normal; }
                      .info-icon .tooltip::after { content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: #323130 transparent transparent transparent; }
                      .info-icon:hover .tooltip { visibility: visible; opacity: 1; }
                      .chart-container { background: white; padding: 16px; border-radius: 4px; box-shadow: 0 1.6px 3.6px rgba(0,0,0,.132); margin-bottom: 24px; position: relative; }
                      .chart-container.duration-chart { height: 320px; }
                      .chart-container.stage-chart { height: 420px; }
                      h2 { color: #323130; font-size: 18px; margin-top: 32px; margin-bottom: 16px; }
                      .table-container { background: white; padding: 16px; border-radius: 4px; box-shadow: 0 1.6px 3.6px rgba(0,0,0,.132); margin-bottom: 24px; overflow-x: auto; }
                      .builds-table { width: 100%; border-collapse: collapse; font-size: 14px; }
                      .builds-table th, .builds-table td { padding: 12px 16px; text-align: left; border-bottom: 1px solid #edebe9; }
                      .builds-table th { background: #faf9f8; font-weight: 600; color: #323130; cursor: pointer; user-select: none; white-space: nowrap; }
                      .builds-table th:hover { background: #f3f2f1; }
                      .builds-table th .sort-icon { margin-left: 4px; opacity: 0.5; }
                      .builds-table th.sort-asc .sort-icon, .builds-table th.sort-desc .sort-icon { opacity: 1; }
                      .builds-table tbody tr:hover { background: #faf9f8; }
                      .builds-table a { color: #0078d4; text-decoration: none; }
                      .builds-table a:hover { text-decoration: underline; }
                      .pagination { display: flex; justify-content: space-between; align-items: center; margin-top: 16px; padding-top: 16px; border-top: 1px solid #edebe9; }
                      .pagination-info { color: #605e5c; font-size: 14px; }
                      .pagination-controls { display: flex; gap: 8px; }
                      .pagination-btn { padding: 8px 16px; border: 1px solid #8a8886; background: white; border-radius: 4px; cursor: pointer; font-size: 14px; color: #323130; }
                      .pagination-btn:hover:not(:disabled) { background: #f3f2f1; }
                      .pagination-btn:disabled { opacity: 0.5; cursor: not-allowed; }
                      .info { background: white; padding: 16px; border-radius: 4px; box-shadow: 0 1.6px 3.6px rgba(0,0,0,.132); margin-top: 24px; }
                      .info h3 { margin-top: 0; color: #323130; }
                      .info p, .info ul { color: #605e5c; line-height: 1.6; }
                  </style>
              </head>
              <body>
                  <div class="container">
                      <div class="header-row">
                          <h1>FluidFramework Build Dashboard</h1>
                          <div class="tabs">
                              <button class="tab pr active" onclick="switchTab('pr')">PR Builds</button>
                              <button class="tab internal" onclick="switchTab('internal')">Internal Builds</button>
                          </div>
                      </div>
                      <div id="pr-content" class="tab-content active">
                          <div class="loading" id="pr-loading"><div class="loading-spinner"></div><p>Loading PR build data...</p></div>
                          <div id="pr-dashboard" style="display: none;"></div>
                          <div class="no-data" id="pr-no-data" style="display: none;"><h3>No PR Build Data Available</h3><p>PR build metrics will appear here once the public pipeline runs.</p></div>
                      </div>
                      <div id="internal-content" class="tab-content">
                          <div class="loading" id="internal-loading"><div class="loading-spinner"></div><p>Loading internal build data...</p></div>
                          <div id="internal-dashboard" style="display: none;"></div>
                          <div class="no-data" id="internal-no-data" style="display: none;"><h3>No Internal Build Data Available</h3><p>Internal build metrics will appear here once the internal pipeline runs.</p></div>
                      </div>
                  </div>
                  <script>
                      const dashboardData = { pr: null, internal: null };
                      const chartInstances = { pr: {}, internal: {} };
                      const tableState = {
                          pr: { recent: { sort: { column: 'date', direction: 'desc' }, page: 1 }, longest: { sort: { column: 'duration', direction: 'desc' }, page: 1 } },
                          internal: { recent: { sort: { column: 'date', direction: 'desc' }, page: 1 }, longest: { sort: { column: 'duration', direction: 'desc' }, page: 1 } }
                      };
                      const itemsPerPage = 5;
                      const colors = {
                          pr: { primary: 'rgba(139, 92, 246, 1)', background: 'rgba(139, 92, 246, 0.1)', tasks: ['rgba(139, 92, 246, 0.8)', 'rgba(168, 85, 247, 0.8)', 'rgba(192, 132, 252, 0.8)', 'rgba(216, 180, 254, 0.8)', 'rgba(107, 33, 168, 0.8)', 'rgba(126, 34, 206, 0.8)'] },
                          internal: { primary: 'rgba(0, 120, 212, 1)', background: 'rgba(0, 120, 212, 0.1)', tasks: ['rgba(16, 124, 16, 0.8)', 'rgba(0, 120, 212, 0.8)', 'rgba(138, 43, 226, 0.8)', 'rgba(255, 140, 0, 0.8)', 'rgba(209, 52, 56, 0.8)', 'rgba(0, 183, 195, 0.8)'] }
                      };
                      function switchTab(mode) {
                          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                          document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                          document.querySelector('.tab.' + mode).classList.add('active');
                          document.getElementById(mode + '-content').classList.add('active');
                          if (dashboardData[mode]) setTimeout(() => renderDashboard(mode, dashboardData[mode]), 50);
                      }
                      async function loadData() {
                          const [prResult, internalResult] = await Promise.allSettled([
                              fetch('data/pr-data.json').then(r => r.ok ? r.json() : null),
                              fetch('data/internal-data.json').then(r => r.ok ? r.json() : null)
                          ]);
                          if (prResult.status === 'fulfilled' && prResult.value) {
                              dashboardData.pr = prResult.value;
                              document.getElementById('pr-loading').style.display = 'none';
                              document.getElementById('pr-dashboard').style.display = 'block';
                              renderDashboard('pr', prResult.value);
                          } else {
                              document.getElementById('pr-loading').style.display = 'none';
                              document.getElementById('pr-no-data').style.display = 'block';
                          }
                          if (internalResult.status === 'fulfilled' && internalResult.value) {
                              dashboardData.internal = internalResult.value;
                              document.getElementById('internal-loading').style.display = 'none';
                              document.getElementById('internal-dashboard').style.display = 'block';
                              renderDashboard('internal', internalResult.value);
                          } else {
                              document.getElementById('internal-loading').style.display = 'none';
                              document.getElementById('internal-no-data').style.display = 'block';
                          }
                      }
                      function renderDashboard(mode, data) {
                          const container = document.getElementById(mode + '-dashboard');
                          const colorScheme = colors[mode];
                          const modeLabel = mode === 'pr' ? 'PR' : 'Internal';
                          const trendDays = mode === 'pr' ? 3 : 7;
                          const trendDate = new Date(); trendDate.setDate(trendDate.getDate() - trendDays);
                          const trendDateStr = trendDate.toISOString().split('T')[0];
                          let durationChange = 0, durationChangeMinutes = 0;
                          if (data.durationTrend && data.durationTrend.length > 0) {
                              const recentBuilds = data.durationTrend.filter(d => d.date >= trendDateStr);
                              const previousBuilds = data.durationTrend.filter(d => d.date < trendDateStr);
                              if (recentBuilds.length > 0 && previousBuilds.length > 0) {
                                  const recentAvg = recentBuilds.reduce((sum, d) => sum + d.avgDuration, 0) / recentBuilds.length;
                                  const previousAvg = previousBuilds.reduce((sum, d) => sum + d.avgDuration, 0) / previousBuilds.length;
                                  durationChange = ((recentAvg - previousAvg) / previousAvg) * 100;
                                  durationChangeMinutes = recentAvg - previousAvg;
                              }
                          }
                          const trendColor = durationChange < 0 ? '#107c10' : durationChange > 0 ? '#d13438' : '#605e5c';
                          const trendSign = durationChange > 0 ? '+' : durationChange < 0 ? '' : '';
                          const timestamp = data.generatedAt ? new Date(data.generatedAt).toLocaleString() : 'Unknown';
                          container.innerHTML = '<div class="timestamp">Last updated: <strong>' + timestamp + '</strong></div>' +
                              '<div class="metrics"><div class="metric-card"><div class="metric-label">Total Builds</div><div class="metric-value">' + (data.summary?.totalBuilds || 0) + '</div></div>' +
                              '<div class="metric-card"><div class="metric-label">Avg Duration</div><div class="metric-value">' + (data.summary?.avgDuration || 0).toFixed(1) + 'm</div></div>' +
                              '<div class="metric-card"><div class="metric-label">' + trendDays + '-Day Trend <span class="info-icon">‚ìò<span class="tooltip">Compares average duration of last ' + trendDays + ' days vs the average of all builds before that</span></span></div>' +
                              '<div class="metric-value" style="color: ' + trendColor + '">' + trendSign + Math.abs(durationChangeMinutes).toFixed(1) + 'm <span style="font-size: 18px; opacity: 0.8;">(' + trendSign + Math.abs(durationChange).toFixed(1) + '%)</span></div></div></div>' +
                              '<h2>Duration Trend</h2><div class="chart-container duration-chart"><canvas id="' + mode + '-duration-chart"></canvas></div>' +
                              '<h2>Duration by Stage</h2><div class="chart-container stage-chart"><canvas id="' + mode + '-stage-chart"></canvas></div>' +
                              '<h2>Individual Task Duration</h2><div class="chart-container stage-chart"><canvas id="' + mode + '-task-chart"></canvas></div>' +
                              '<h2>Recent Builds</h2><div class="table-container"><table class="builds-table" id="' + mode + '-recent-table"><thead><tr><th data-sort="id">Build ID <span class="sort-icon">‚Üï</span></th><th data-sort="date" class="sort-desc">Date <span class="sort-icon">‚Üì</span></th><th data-sort="duration">Duration <span class="sort-icon">‚Üï</span></th><th data-sort="source">Source <span class="sort-icon">‚Üï</span></th></tr></thead><tbody id="' + mode + '-recent-body"></tbody></table><div class="pagination"><div class="pagination-info">Showing <span id="' + mode + '-recent-start">1</span>-<span id="' + mode + '-recent-end">5</span> of <span id="' + mode + '-recent-total">' + (data.recentBuilds || []).length + '</span></div><div class="pagination-controls"><button class="pagination-btn" id="' + mode + '-recent-prev" onclick="prevPage(\'' + mode + '\', \'recent\')">‚Üê Previous</button><button class="pagination-btn" id="' + mode + '-recent-next" onclick="nextPage(\'' + mode + '\', \'recent\')">Next ‚Üí</button></div></div></div>' +
                              '<h2>Longest Builds</h2><div class="table-container"><table class="builds-table" id="' + mode + '-longest-table"><thead><tr><th data-sort="id">Build ID <span class="sort-icon">‚Üï</span></th><th data-sort="date">Date <span class="sort-icon">‚Üï</span></th><th data-sort="duration" class="sort-desc">Duration <span class="sort-icon">‚Üì</span></th><th data-sort="source">Source <span class="sort-icon">‚Üï</span></th></tr></thead><tbody id="' + mode + '-longest-body"></tbody></table><div class="pagination"><div class="pagination-info">Showing <span id="' + mode + '-longest-start">1</span>-<span id="' + mode + '-longest-end">5</span> of <span id="' + mode + '-longest-total">' + (data.longestBuilds || []).length + '</span></div><div class="pagination-controls"><button class="pagination-btn" id="' + mode + '-longest-prev" onclick="prevPage(\'' + mode + '\', \'longest\')">‚Üê Previous</button><button class="pagination-btn" id="' + mode + '-longest-next" onclick="nextPage(\'' + mode + '\', \'longest\')">Next ‚Üí</button></div></div></div>' +
                              '<div class="info"><h3>About This Data</h3><p>This dashboard shows metrics for <strong>' + modeLabel + ' builds</strong>.</p><ul><li>Results: <code>succeeded</code> or <code>partiallySucceeded</code></li><li>Status: <code>completed</code></li><li>Data source: Azure DevOps Build API (v7.1)</li></ul></div>';
                          createDurationChart(mode, data, colorScheme);
                          createStageChart(mode, data, colorScheme);
                          createTaskChart(mode, data, colorScheme);
                          renderTable(mode, 'recent', data.recentBuilds || []);
                          renderTable(mode, 'longest', data.longestBuilds || []);
                          setupTableSorting(mode, 'recent', data.recentBuilds || []);
                          setupTableSorting(mode, 'longest', data.longestBuilds || []);
                      }
                      function createDurationChart(mode, data, colorScheme) {
                          const ctx = document.getElementById(mode + '-duration-chart');
                          if (!ctx) return;
                          if (chartInstances[mode].duration) chartInstances[mode].duration.destroy();
                          if (!data.durationTrend || data.durationTrend.length === 0) { ctx.parentElement.innerHTML = '<p style="padding: 20px; text-align: center; color: #605e5c;">No duration data available</p>'; return; }
                          const chartData = data.durationTrend.map(d => ({ x: new Date(d.date), y: d.avgDuration }));
                          chartInstances[mode].duration = new Chart(ctx, {
                              type: 'line', data: { datasets: [{ label: 'Avg Duration (minutes)', data: chartData, borderColor: colorScheme.primary, backgroundColor: colorScheme.background, borderWidth: 2, fill: true, tension: 0.4 }] },
                              options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { onClick: null }, title: { display: true, text: 'Average Build Duration', font: { size: 14, weight: 'bold' } } }, scales: { x: { type: 'time', time: { unit: 'day' }, title: { display: true, text: 'Date' } }, y: { beginAtZero: true, title: { display: true, text: 'Duration (minutes)' } } } }
                          });
                      }
                      function createStageChart(mode, data, colorScheme) {
                          const ctx = document.getElementById(mode + '-stage-chart');
                          if (!ctx) return;
                          if (chartInstances[mode].stage) chartInstances[mode].stage.destroy();
                          const stageData = data.stageTaskBreakdown || {};
                          const stagePerf = data.stagePerformance || [];
                          const stages = Object.keys(stageData).sort();
                          if (stages.length === 0) { ctx.parentElement.innerHTML = '<p style="padding: 20px; text-align: center; color: #605e5c;">No stage data available</p>'; return; }
                          const stageAvgDurations = {}; stagePerf.forEach(s => { stageAvgDurations[s.name] = s.avgDuration; });
                          const allTasks = new Set();
                          stages.forEach(stage => { const tasks = stageData[stage] || []; if (tasks.length === 0) allTasks.add(stage); else tasks.forEach(task => allTasks.add(task.name)); });
                          const taskNames = Array.from(allTasks).sort();
                          const datasets = taskNames.map((taskName, index) => ({ label: taskName, data: stages.map(stage => { const tasks = stageData[stage] || []; if (tasks.length === 0 && taskName === stage) return stageAvgDurations[stage] || 0; const task = tasks.find(t => t.name === taskName); return task ? task.avgDuration : 0; }), backgroundColor: colorScheme.tasks[index % colorScheme.tasks.length], borderWidth: 1 }));
                          chartInstances[mode].stage = new Chart(ctx, { type: 'bar', data: { labels: stages, datasets }, options: { indexAxis: 'y', responsive: true, maintainAspectRatio: false, plugins: { legend: { onClick: null, position: 'bottom', labels: { boxWidth: 12, padding: 8 } }, title: { display: true, text: 'Average Duration by Stage', font: { size: 14, weight: 'bold' } } }, scales: { x: { stacked: true, beginAtZero: true, title: { display: true, text: 'Duration (minutes)' } }, y: { stacked: true, title: { display: true, text: 'Stage' } } } } });
                      }
                      function createTaskChart(mode, data, colorScheme) {
                          const ctx = document.getElementById(mode + '-task-chart');
                          if (!ctx) return;
                          if (chartInstances[mode].task) chartInstances[mode].task.destroy();
                          const stageData = data.stageTaskBreakdown || {};
                          const stagePerf = data.stagePerformance || [];
                          if (Object.keys(stageData).length === 0) { ctx.parentElement.innerHTML = '<p style="padding: 20px; text-align: center; color: #605e5c;">No task data available</p>'; return; }
                          const allTasks = [];
                          const stageAvgDurations = {}; stagePerf.forEach(s => { stageAvgDurations[s.name] = s.avgDuration; });
                          const stages = Object.keys(stageData).sort();
                          const stageColorMap = {}; stages.forEach((stage, idx) => { stageColorMap[stage] = idx; });
                          stages.forEach(stage => { const tasks = stageData[stage] || []; if (tasks.length === 0) allTasks.push({ label: stage, duration: stageAvgDurations[stage] || 0, stageIndex: stageColorMap[stage] }); else tasks.forEach(task => { allTasks.push({ label: stage + ' ‚Ä∫ ' + task.name, duration: task.avgDuration, stageIndex: stageColorMap[stage] }); }); });
                          allTasks.sort((a, b) => b.duration - a.duration);
                          chartInstances[mode].task = new Chart(ctx, { type: 'bar', data: { labels: allTasks.map(t => t.label), datasets: [{ label: 'Avg Duration (minutes)', data: allTasks.map(t => t.duration), backgroundColor: allTasks.map(t => colorScheme.tasks[t.stageIndex % colorScheme.tasks.length]), borderWidth: 1 }] }, options: { indexAxis: 'y', responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false }, title: { display: true, text: 'Longest Average Individual Tasks', font: { size: 14, weight: 'bold' } } }, scales: { x: { beginAtZero: true, title: { display: true, text: 'Duration (minutes)' } }, y: { title: { display: true, text: 'Task' } } } } });
                      }
                      function renderTable(mode, tableType, builds) {
                          const state = tableState[mode][tableType];
                          const tbody = document.getElementById(mode + '-' + tableType + '-body');
                          if (!tbody) return;
                          const sortedBuilds = sortBuilds(builds, state.sort.column, state.sort.direction);
                          const startIdx = (state.page - 1) * itemsPerPage;
                          const endIdx = Math.min(startIdx + itemsPerPage, sortedBuilds.length);
                          const pageBuilds = sortedBuilds.slice(startIdx, endIdx);
                          tbody.innerHTML = pageBuilds.map(build => {
                              const date = new Date(build.startTime);
                              const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                              const timeStr = date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
                              const sourceCell = build.sourceUrl ? '<a href="' + build.sourceUrl + '" target="_blank">' + build.source + '</a>' : build.source;
                              return '<tr><td><a href="' + build.url + '" target="_blank">' + build.id + '</a></td><td>' + dateStr + ' ' + timeStr + '</td><td>' + build.duration.toFixed(1) + 'm</td><td>' + sourceCell + '</td></tr>';
                          }).join('');
                          document.getElementById(mode + '-' + tableType + '-start').textContent = sortedBuilds.length > 0 ? startIdx + 1 : 0;
                          document.getElementById(mode + '-' + tableType + '-end').textContent = endIdx;
                          updatePaginationControls(mode, tableType, builds.length);
                      }
                      function sortBuilds(builds, column, direction) {
                          return [...builds].sort((a, b) => { let aVal, bVal; switch (column) { case 'id': aVal = a.id; bVal = b.id; break; case 'date': aVal = new Date(a.startTime); bVal = new Date(b.startTime); break; case 'duration': aVal = a.duration; bVal = b.duration; break; case 'source': aVal = a.source; bVal = b.source; break; default: return 0; } if (aVal < bVal) return direction === 'asc' ? -1 : 1; if (aVal > bVal) return direction === 'asc' ? 1 : -1; return 0; });
                      }
                      function setupTableSorting(mode, tableType, builds) {
                          const headers = document.querySelectorAll('#' + mode + '-' + tableType + '-table th[data-sort]');
                          headers.forEach(header => { header.addEventListener('click', () => { const column = header.dataset.sort; const state = tableState[mode][tableType]; if (state.sort.column === column) state.sort.direction = state.sort.direction === 'asc' ? 'desc' : 'asc'; else { state.sort.column = column; state.sort.direction = 'desc'; } headers.forEach(h => { h.classList.remove('sort-asc', 'sort-desc'); h.querySelector('.sort-icon').textContent = '‚Üï'; }); header.classList.add('sort-' + state.sort.direction); header.querySelector('.sort-icon').textContent = state.sort.direction === 'asc' ? '‚Üë' : '‚Üì'; state.page = 1; renderTable(mode, tableType, builds); }); });
                      }
                      function updatePaginationControls(mode, tableType, totalItems) { const state = tableState[mode][tableType]; const totalPages = Math.ceil(totalItems / itemsPerPage); document.getElementById(mode + '-' + tableType + '-prev').disabled = state.page <= 1; document.getElementById(mode + '-' + tableType + '-next').disabled = state.page >= totalPages; }
                      function prevPage(mode, tableType) { const state = tableState[mode][tableType]; if (state.page > 1) { state.page--; renderTable(mode, tableType, dashboardData[mode][tableType === 'recent' ? 'recentBuilds' : 'longestBuilds'] || []); } }
                      function nextPage(mode, tableType) { const state = tableState[mode][tableType]; const builds = dashboardData[mode][tableType === 'recent' ? 'recentBuilds' : 'longestBuilds'] || []; const totalPages = Math.ceil(builds.length / itemsPerPage); if (state.page < totalPages) { state.page++; renderTable(mode, tableType, builds); } }
                      document.addEventListener('DOMContentLoaded', loadData);
                  </script>
              </body>
              </html>
              HTMLEOF

              echo "Deployment package contents:"
              find "$DEPLOY_DIR" -type f

        - task: AzureStaticWebApp@0
          displayName: Deploy to Azure Static Web Apps
          inputs:
            skip_app_build: true
            skip_api_build: true
            cwd: $(Build.ArtifactStagingDirectory)
            app_location: 'deploy'
            output_location: ''
            azure_static_web_apps_api_token: $(ASWA_DEPLOYMENT_TOKEN)

        - task: Bash@3
          displayName: Clean up
          inputs:
            targetType: 'inline'
            script: |
              echo "Cleaning up temporary files..."
              rm -rf $(Build.ArtifactStagingDirectory)/metrics
              rm -rf $(Build.ArtifactStagingDirectory)/deploy
              rm -f $(Build.ArtifactStagingDirectory)/*.json
              echo "Cleanup complete"
