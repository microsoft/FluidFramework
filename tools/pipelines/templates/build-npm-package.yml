parameters:
  - name: buildDirectory
    type: string
  - name: taskBuild
    type: string
    default: 'ci:build'
  - name: taskBuildDocs
    type: boolean
    default: true
  - name: publishDocs
    type: boolean
    default: false
  - name: taskLint
    type: boolean
    default: true
  - name: taskLintName
    type: string
    default: lint
  - name: taskTest
    type: object
    default:
      - 'ci:test'
  - name: testResultDirs
    type: object
    default:
      - nyc
  - name: taskBundleAnalysis
    type: boolean
    default: false
  - name: taskPublishBundleSizeArtifacts
    type: boolean
    default: false
  - name: taskPack
    type: boolean
    default: true
  - name: poolCG
    type: object
    default: Small
  - name: poolBuild
    type: object
    default: Small
  - name: preCG
    type: stepList
    default: []
  - name: cgSubDirectory
    type: string
    default: ''
  - name: checkoutSubmodules
    type: boolean
    default: false
  - name: namespace
    type: boolean
    default: true
  - name: buildNumberInPatch
    type: string
    default: ''
  - name: nonScopedPackages
    type: object
    default: []
  - name: publishOverride
    type: string
  - name: releaseBuildOverride
    type: string
  - name: tagName
    type: string
  - name: includeInternalVersions
    type: boolean
    default: false
  - name: buildToolsVersionToInstall
    type: string
    default: repo
  - name: packageManager
    type: string
    default: npm
  - name: packageTypesOverride
    type: string
    default: none
  - name: packageManagerInstallCommand
    type: string
    default: npm ci --unsafe-perm
  - name: additionalBuildSteps
    type: stepList
    default: []
  - name: interdependencyRange
    type: string
    default: ^
  - name: checks
    type: object
    default: []
  - name: telemetry
    type: boolean
    default: false
resources:
  repositories:
    - repository: m365Pipelines
      type: git
      name: 1ESPipelineTemplates/M365GPT
      ref: refs/tags/release
extends:
  template: v1/M365.Official.PipelineTemplate.yml@m365Pipelines
  parameters:
    pool:
      name: NewLarge-linux-1ES
      os: linux
    sdl:
      arrow:
        serviceConnection: Arrow_FluidFramework_public
      sourceAnalysisPool:
        name: Azure-Pipelines-1ESPT-ExDShared
        image: windows-2022
        os: windows
    customBuildTags:
      - ES365AIMigrationTooling
    stages:
      - '${{ if ne(convertToJson(parameters.checks), ''[]'') }}':
          - template: /tools/pipelines/templates/include-policy-check.yml@self
            parameters:
              buildDirectory: '${{ parameters.buildDirectory }}'
              checks: '${{ parameters.checks }}'
              dependencyInstallCommand: pnpm install --frozen-lockfile
      - stage: build
        displayName: Build Stage
        dependsOn: []
        jobs:
          - job: build
            displayName: Build
            variables:
              testCoverage: '${{ ne(variables[''Build.Reason''], ''PullRequest'') }}'
              releaseBuildVar: '$[variables.releaseBuild]'
              '${{ if eq(variables[''Build.Reason''], ''PullRequest'') }}':
                targetBranchName: $(System.PullRequest.TargetBranch)
            steps:
              - checkout: self
                clean: true
                lfs: '${{ parameters.checkoutSubmodules }}'
                submodules: '${{ parameters.checkoutSubmodules }}'
              - task: Bash@3
                displayName: Parameters
                inputs:
                  targetType: inline
                  workingDirectory: '${{ parameters.buildDirectory }}'
                  script: >
                    # Show all task group conditions

                    echo "

                    Pipeline Variables:
                      releaseBuild=$(releaseBuildVar)
                    Override Parameters:
                      publishOverride=${{ parameters.publishOverride }}
                      releaseBuildOverride=${{ parameters.releaseBuildOverride }}
                      packageTypesOverride=${{ parameters.packageTypesOverride }}
                    Tasks Parameters:
                      BuildDir=${{ parameters.buildDirectory }}
                      Build=${{ parameters.taskBuild }}
                      Lint=${{ parameters.taskLint }}
                      LintName: ${{ parameters.taskLintName }}
                      Test=${{ convertToJson(parameters.taskTest) }}
                      TestResultDirs=${{ convertToJson(parameters.testResultDirs) }}
                      BuildDoc=${{ parameters.taskBuildDocs }}
                      PublishDocs=${{ parameters.publishDocs }}
                      TestCoverage=$(testCoverage)
                    Variables:
                      absolutePathToTelemetryGenerator=$(absolutePathToTelemetryGenerator)
                      BuildReason=$(variables['Build.Reason'])
                    Publish Parameters:
                      nonScopedPackages=${{ join(', ', parameters.nonScopedPackages) }}
                      interdependencyRange='${{ parameters.interdependencyRange }}'
                      packageTypesOverride='${{ parameters.packageTypesOverride }}'
                    Computed variables:
                      shouldPublish=${{ variables.shouldPublish }}
                      componentDetection=${{ variables.componentDetection }}
                      publish=${{ variables.publish }}
                      canRelease=${{ variables.canRelease }}
                      publishNonScopedPackages=${{ variables.publishNonScopedPackages }}
                      pnpmStorePath=${{ variables.pnpmStorePath }}
                      release=$(release)"
                    # Target Branch variable (PR policy related)

                    if [[ ${{ variables['Build.Reason'] }} == "PullRequest" ]];
                    then
                      echo "TargetBranchName=$(targetBranchName)"
                    fi

                    # Error checking

                    if [[ "$(release)" == "release" ]]; then
                      if [[ "${{ variables.canRelease }}" == "False" ]]; then
                        echo "##vso[task.logissue type=error]Invalid branch ${{ variables['Build.SourceBranch'] }} for release"
                        exit -1;
                      fi
                      if [ -f "lerna.json" ]; then
                        grep -e fluid.*[0-9]-[0-9] `find packages -name 'package.json'`
                      else
                        grep -e fluid.*[0-9]-[0-9] `find . -name 'package.json'`
                      fi
                      if [[ $? == 0 ]]; then
                        echo "##vso[task.logissue type=error]Release shouldn't contain prerelease dependencies"
                        exit -1;
                      fi
                    fi

                    if [[ "$(release)" == "prerelease" ]]; then
                      if [[ "${{ parameters.buildNumberInPatch }}" == "true" ]]; then
                        echo "##vso[task.logissue type=error] Prerelease not allow for builds that put build number as the patch version"
                        exit -1;
                      fi
                    fi

                    if [[ "$(release)" != "prerelease" ]]; then
                      if [[ "${{ parameters.packageTypesOverride }}" == "alpha" || "${{ parameters.packageTypesOverride }}" == "beta" ]]; then
                        echo "##vso[task.logissue type=error]This release type is not supported. alpha/beta ***prerelease*** is allowed"
                        exit -1;
                      fi
                    fi

                    if [[ "$(release)" != "none" ]] && [[ "$(release)" != "" ]];
                    then
                      if [[ "${{ variables.publish }}" != "True" ]]; then
                        echo "##vso[task.logissue type=error]'$(release)'' is set but package is not published. Either the branch doesn't default to publish or it is skipped."
                        exit -1;
                      fi
                    fi
              - template: /tools/pipelines/templates/include-use-node-version.yml@self
              - template: /tools/pipelines/templates/include-install.yml@self
                parameters:
                  packageManager: '${{ parameters.packageManager }}'
                  buildDirectory: '${{ parameters.buildDirectory }}'
                  packageManagerInstallCommand: '${{ parameters.packageManagerInstallCommand }}'
              - '${{ if eq(parameters.taskPublishBundleSizeArtifacts, false) }}':
                  - template: >-
                      /tools/pipelines/templates/include-set-package-version.yml@self
                    parameters:
                      buildDirectory: '${{ parameters.buildDirectory }}'
                      buildNumberInPatch: '${{ parameters.buildNumberInPatch }}'
                      buildToolsVersionToInstall: '${{ parameters.buildToolsVersionToInstall }}'
                      tagName: '${{ parameters.tagName }}'
                      interdependencyRange: '${{ parameters.interdependencyRange }}'
                      packageTypesOverride: '${{ parameters.packageTypesOverride }}'
              - template: /tools/pipelines/templates/include-build-lint.yml@self
                parameters:
                  taskBuild: '${{ parameters.taskBuild }}'
                  taskLint: '${{ parameters.taskLint }}'
                  taskLintName: '${{ parameters.taskLintName }}'
                  buildDirectory: '${{ parameters.buildDirectory }}'
              - '${{ if ne(convertToJson(parameters.taskTest), ''[]'') }}':
                  - script: |
                      echo "##vso[task.setvariable variable=startTest]true"
                    displayName: Start Test
                  - '${{ each taskTestStep in parameters.taskTest }}':
                      - template: /tools/pipelines/templates/include-test-task.yml@self
                        parameters:
                          taskTestStep: '${{ taskTestStep }}'
                          buildDirectory: '${{ parameters.buildDirectory }}'
                  - '${{ if eq(variables[''testCoverage''], true) }}':
                      - task: Bash@3
                        displayName: Check for nyc/report directory
                        inputs:
                          targetType: inline
                          workingDirectory: '${{ parameters.buildDirectory }}'
                          script: >
                            test -d nyc/report && echo '##vso[task.setvariable
                            variable=ReportDirExists;]true' || echo 'No
                            nyc/report directory'
                        condition: >-
                          and(succeededOrFailed(), eq(variables['startTest'],
                          'true'))
                      - task: Bash@3
                        displayName: Patch Coverage Results
                        inputs:
                          targetType: inline
                          workingDirectory: '${{ parameters.buildDirectory }}/nyc/report'
                          script: >
                            sed -e 's/\(filename=\".*[\\/]external
                            .*\)"\(.*\)""/\1\&quot;\2\&quot;"/'
                            cobertura-coverage.xml >
                            cobertura-coverage-patched.xml
                        condition: >-
                          and(succeededOrFailed(),
                          eq(variables['ReportDirExists'], 'true'))
                      - task: PublishCodeCoverageResults@1
                        displayName: Publish Code Coverage
                        inputs:
                          codeCoverageTool: Cobertura
                          summaryFileLocation: >-
                            ${{ parameters.buildDirectory
                            }}/nyc/report/cobertura-coverage-patched.xml
                          reportDirectory: '${{ parameters.buildDirectory }}/nyc/report'
                          failIfCoverageEmpty: true
                        condition: >-
                          and(succeededOrFailed(),
                          eq(variables['ReportDirExists'], 'true'))
                  - '${{ if contains(convertToJson(parameters.taskTest), ''tinylicious'') }}': []
                  - template: >-
                      /tools/pipelines/templates/include-process-test-results.yml@self
                    parameters:
                      buildDirectory: '${{ parameters.buildDirectory }}'
                      testResultDirs: '${{ parameters.testResultDirs }}'
              - '${{ if ne(parameters.taskPack, false) }}':
                  - task: Bash@3
                    displayName: npm pack
                    env:
                      PACKAGE_MANAGER: '${{ parameters.packageManager }}'
                      PUBLISH_NON_SCOPED: '${{ variables.publishNonScopedPackages }}'
                      RELEASE_GROUP: '${{ parameters.tagName }}'
                      STAGING_PATH: $(Build.ArtifactStagingDirectory)
                    inputs:
                      targetType: filePath
                      workingDirectory: '${{ parameters.buildDirectory }}'
                      filePath: $(Build.SourcesDirectory)/scripts/pack-packages.sh
                  - '${{ if eq(variables.publishNonScopedPackages, true) }}':
                      - '${{ each parameter in parameters.nonScopedPackages }}':
                          - task: Bash@3
                            displayName: 'Move Non-Scoped Package ${{parameter}}'
                            inputs:
                              targetType: inline
                              workingDirectory: '${{ parameters.buildDirectory }}'
                              script: >
                                mv -t
                                $(Build.ArtifactStagingDirectory)/pack/non-scoped/
                                $(Build.ArtifactStagingDirectory)/pack/scoped/${{parameter}}*.tgz
              - '${{ if eq(parameters.taskBundleAnalysis, true) }}':
                  - task: Npm@1
                    displayName: 'npm run bundle-analysis:collect'
                    inputs:
                      command: custom
                      workingDir: '${{ parameters.buildDirectory }}'
                      customCommand: 'run bundle-analysis:collect'
                  - task: Npm@1
                    displayName: run bundle size comparison
                    condition: >-
                      and(succeeded(), eq(variables['Build.Reason'],
                      'PullRequest'))
                    continueOnError: true
                    env:
                      ADO_API_TOKEN: $(System.AccessToken)
                      DANGER_GITHUB_API_TOKEN: $(githubPublicRepoSecret)
                      TARGET_BRANCH_NAME: '${{ variables.targetBranchName }}'
                    inputs:
                      command: custom
                      workingDir: '${{ parameters.buildDirectory }}'
                      customCommand: 'run bundle-analysis:run'
                  - '${{ if and(or(eq(variables[''Build.Reason''], ''IndividualCI''), eq(variables[''Build.Reason''], ''BatchedCI'')), eq(variables[''System.TeamProject''], ''internal'')) }}':
                      - task: Bash@3
                        displayName: List report.json
                        inputs:
                          targetType: inline
                          workingDirectory: '${{ parameters.buildDirectory }}'
                          script: >
                            echo "Build Directory is ${{
                            parameters.buildDirectory }}";

                            BUNDLE_SIZE_TESTS_DIR="${{ parameters.buildDirectory
                            }}/artifacts/bundleAnalysis/@fluid-example/bundle-size-tests";

                            echo "Contents of $BUNDLE_SIZE_TESTS_DIR:";

                            ls -la $BUNDLE_SIZE_TESTS_DIR;
                      - template: >-
                          /tools/pipelines/templates/include-telemetry-setup.yml@self
                        parameters:
                          devFeedUrl: $(ado-feeds-dev)
                          officeFeedUrl: $(ado-feeds-office)
                      - task: Bash@3
                        displayName: Write bundle sizes measurements to Aria/Kusto
                        inputs:
                          targetType: inline
                          workingDirectory: $(absolutePathToTelemetryGenerator)
                          script: >
                            echo "Writing the following performance tests
                            results to Aria/Kusto"

                            echo "Report Size:"

                            ls -la
                            '../../examples/utils/bundle-size-tests/bundleAnalysis/report.json';

                            node --require @ff-internal/aria-logger bin/run
                            --handlerModule
                            $(absolutePathToTelemetryGenerator)/dist/handlers/bundleSizeHandler.js
                            --dir
                            '../../artifacts/bundleAnalysis/@fluid-example/bundle-size-tests';
              - '${{ if ne(parameters.taskBuildDocs, false) }}':
                  - task: Npm@1
                    displayName: 'npm run ci:build:docs'
                    inputs:
                      command: custom
                      workingDir: '${{ parameters.buildDirectory }}'
                      customCommand: 'run ci:build:docs'
              - '${{ if or(eq(parameters.publishDocs, true), eq(parameters.taskBuildDocs, true)) }}': []
              - '${{ if eq(parameters.packageManager, ''pnpm'') }}':
                  - task: Bash@3
                    displayName: Reset lockfile
                    inputs:
                      targetType: inline
                      workingDirectory: '${{ parameters.buildDirectory }}'
                      script: |
                        git checkout HEAD -- pnpm-lock.yaml
                  - task: Bash@3
                    displayName: Prune pnpm store
                    inputs:
                      targetType: inline
                      workingDirectory: '${{ parameters.buildDirectory }}'
                      script: |
                        pnpm store prune
              - task: Bash@3
                displayName: Check for extraneous modified files
                inputs:
                  targetType: inline
                  script: >
                    git status | grep -v -E
                    'package.json|package-lock.json|packageVersion.ts|lerna.json|.npmrc|build-tools/.npmrc|\(use.*'
                    | grep '^\s' > git_status.log

                    if [ `cat git_status.log | wc -l` != "0" ]; then
                      cat git_status.log
                      echo "##vso[task.logissue type=error]Build should not create extraneous files"
                      exit -1;
                    fi
              - '${{ parameters.additionalBuildSteps }}'
            templateContext:
              outputs:
                - '${{ if and(ne(convertToJson(parameters.taskTest), ''[]''), contains(convertToJson(parameters.taskTest), ''tinylicious'')) }}':
                    - output: pipelineArtifact
                      displayName: Publish Artifact - Tinylicious Log
                      condition: >-
                        and(succeededOrFailed(), eq(variables['startTest'],
                        'true'))
                      targetPath: >-
                        ${{ parameters.buildDirectory
                        }}/packages/test/test-end-to-end-tests/tinylicious.log
                      artifactName: tinyliciousLog_attempt-$(System.JobAttempt)
                      publishLocation: pipeline
                - '${{ if ne(parameters.taskPack, false) }}':
                    - output: pipelineArtifact
                      displayName: Publish Artifact - pack
                      targetPath: $(Build.ArtifactStagingDirectory)/pack
                      artifactName: pack
                      publishLocation: pipeline
                - output: pipelineArtifact
                  displayName: Publish Artifact - Test Files
                  targetPath: $(Build.ArtifactStagingDirectory)/test-files
                  artifactName: test-files
                  publishLocation: pipeline
                - '${{ if eq(parameters.taskBundleAnalysis, true) }}':
                    - output: pipelineArtifact
                      displayName: Publish Artifacts - bundle-analysis
                      condition: >-
                        and( succeeded(), ne(variables['Build.Reason'],
                        'PullRequest'), eq(${{
                        parameters.taskPublishBundleSizeArtifacts }}, true) )
                      targetPath: >-
                        ${{ parameters.buildDirectory
                        }}/artifacts/bundleAnalysis
                      artifactname: bundleAnalysis
                      publishLocation: Container
                - '${{ if or(eq(parameters.publishDocs, true), eq(parameters.taskBuildDocs, true)) }}':
                    - output: pipelineArtifact
                      displayName: Publish Artifact - _api-extractor-temp
                      targetPath: '${{ parameters.buildDirectory }}/_api-extractor-temp'
                      artifactName: _api-extractor-temp
                      publishLocation: pipeline
          - '${{ if eq(variables.componentDetection, true) }}':
              - job: CG
                displayName: Component Detection
                steps:
                  - checkout: self
                    clean: true
                    lfs: false
                    submodules: false
                  - '${{ parameters.preCG }}'
                  - task: ComponentGovernanceComponentDetection@0
                    displayName: Component Detection
                    inputs:
                      sourceScanPath: >-
                        ${{ parameters.buildDirectory }}/${{
                        parameters.cgSubDirectory }}
                      verbosity: Verbose
                      scanType: Register
                      alertWarningLevel: High
      - '${{ if eq(variables.publish, true) }}':
          - template: /tools/pipelines/templates/include-publish-npm-package.yml@self
            parameters:
              namespace: '${{ parameters.namespace }}'
              tagName: '${{ parameters.tagName }}'
              publishNonScopedPackages: '${{ variables.publishNonScopedPackages }}'
      - stage: upload_run_telemetry
        displayName: Upload pipeline run telemetry to Kusto
        condition: >-
          and(succeededOrFailed(), eq(variables['Build.Reason'],
          'IndividualCI'), eq(${{parameters.telemetry}}, true))
        dependsOn:
          - build
        jobs:
          - job: upload_run_telemetry
            displayName: Upload pipeline run telemetry to Kusto
            variables:
              - name: pipelineTelemetryWorkdir
                value: $(Pipeline.Workspace)/pipelineTelemetryWorkdir
            steps:
              - template: /tools/pipelines/templates/include-telemetry-setup.yml@self
                parameters:
                  devFeedUrl: $(ado-feeds-dev)
                  officeFeedUrl: $(ado-feeds-office)
                  isCheckoutNeeded: true
              - task: Bash@3
                displayName: Retrieve buildId results
                inputs:
                  targetType: inline
                  workingDirectory: $(absolutePathToTelemetryGenerator)
                  script: >
                    echo "Creating output folder "

                    mkdir -p $(pipelineTelemetryWorkdir)/timingOutput

                    echo "Retrieving pipeline run timeline data "

                    echo 'curl -u ":<REDACTED>"
                    "https://dev.azure.com/fluidframework/internal/_apis/build/builds/$BUILD_ID/timeline"'

                    curl -u ":$ADO_API_TOKEN"
                    "https://dev.azure.com/fluidframework/internal/_apis/build/builds/$BUILD_ID/timeline\?api-version\=6.0-preview.1"
                    > $(pipelineTelemetryWorkdir)/timingOutput/output.json

                    pwd;

                    ls -laR
                    $(pipelineTelemetryWorkdir)/timingOutput/output.json;

                    cat $(pipelineTelemetryWorkdir)/timingOutput/output.json;

                    node --require @ff-internal/aria-logger bin/run
                    --handlerModule
                    $(absolutePathToTelemetryGenerator)/dist/handlers/stageTimingRetriever.js
                    --dir '$(pipelineTelemetryWorkdir)/timingOutput/';
                env:
                  BUILD_ID: $(Build.BuildId)
                  ADO_API_TOKEN: $(System.AccessToken)
                  PIPELINE: BuildClient
