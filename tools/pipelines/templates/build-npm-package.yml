# Copyright (c) Microsoft Corporation and contributors. All rights reserved.
# Licensed under the MIT License.

# build-npm-package template to build NPM packages/projects

parameters:
- name: buildDirectory
  type: string

- name: taskBuild
  type: string
  default: ci:build

- name: taskBuildDocs
  type: boolean
  default: true

- name: taskLint
  type: boolean
  default: true

- name: taskTest
  type: string
  default: ci:test

- name: taskBundleAnalysis
  type: boolean
  default: false

- name: taskPublishBundleSizeArtifacts
  type: boolean
  default: false

- name: taskPack
  type: boolean
  default: true

- name: poolCG
  type: object
  default: Small-eastus2

- name: poolBuild
  type: object
  default: Small-eastus2

- name: preCG
  type: stepList
  default: []

# These should output results under an /nyc/ dir (anywhere in the repo) to get included in the published test results
- name: additionalTests
  type: stepList
  default: []

- name: cgSubDirectory
  type: string
  default:

- name: checkoutSubmodules
  type: boolean
  default: false

- name: buildNumberInPatch
  type: boolean
  default: false

- name: nonScopedPackages
  type: object
  default: []

- name: publishOverride
  type: string

- name: releaseBuildOverride
  type: string

- name: tagName
  type: string

- name: includeInternalVersions
  type: boolean
  default: false

- name: buildToolsVersionToInstall
  type: string
  default: "^0.5.0"

- name: packageManager
  type: string
  default: npm

- name: packageManagerInstallCommand
  type: string
  default: 'npm ci --unsafe-perm'

# The semver range constraint to use for interdependencies; that is, dependencies on other packages within the release
# group
- name: interdependencyRange
  type: string
  default: "^"

# Indicates if this is a release build that should be shipped to arrow.
- name: shouldShip
  type: boolean
  default: false

resources:
  repositories:
  - repository: 1ESPipelineTemplates
    type: git
    name: 1ESPipelineTemplates/1ESPipelineTemplates
    ref: refs/tags/release

extends:
  template: v1/1ES.Official.PipelineTemplate.yml@1ESPipelineTemplates
  parameters:
    pool:
      name: Small-eastus2
      os: linux
    sdl:
      ${{ if eq(variables['System.TeamProject'], 'internal') }}:
        arrow:
          # This is the service connection for the Arrow Service Connection in FluidFramework Azure DevOps organization
          serviceConnection: ff-internal-arrow-sc
          # This will make sure that the artifacts are published to the Arrow Service Connection if they are release or pre-release
          isShipped: ${{ parameters.shouldShip }}
      sourceAnalysisPool:
        name: Azure-Pipelines-1ESPT-ExDShared
        image: windows-2022
        os: windows
      # Tentative workaround for the occasional Credscan failures
      credscan:
        batchSize: 4
    # Skip tagging if Github PR coming from a fork;  This skips Microsoft security checks that won't work on forks.
    settings:
      skipBuildTagsForGitHubPullRequests: true
    customBuildTags:
      - ES365AIMigrationTooling
    stages:
    # Install / Build / Test Stage
    - stage: build
      displayName: Build Stage
      variables:
      - template: /tools/pipelines/templates/include-vars.yml@self
        parameters:
          publishOverride: '${{ parameters.publishOverride }}'
          releaseBuildOverride: '${{ parameters.releaseBuildOverride }}'
      jobs:
      # Job - Build
      - job: build
        displayName: Build
        pool: ${{ parameters.poolBuild }}
        variables:
        # We use 'chalk' to colorize output, which auto-detects color support in the
        # running terminal.  The log output shown in Azure DevOps job runs only has
        # basic ANSI color support though, so force that in the pipeline
        - name: FORCE_COLOR
          value: 1
        - group: ado-feeds
        - group: storage-vars
        # Coverage has quality issues in LTS, and root-causing + fixing is not a priority given changes to LTS at this point
        # will be things like upgrading node or security fixes, not adding new features.
        - name: testCoverage
          value: false
        - name: releaseBuildVar
          value: $[variables.releaseBuild]
        templateContext:
          outputs:
          - ${{ if ne(parameters.taskPack, false) }}:
            - output: pipelineArtifact
              displayName: 'Publish Artifact - pack'
              targetPath: '$(Build.ArtifactStagingDirectory)/pack'
              artifactName: 'pack'
              publishLocation: 'Container'
          - ${{ if ne(parameters.taskPack, false) }}:
            - output: pipelineArtifact
              displayName: 'Publish Artifact - Test Files'
              targetPath: '$(Build.ArtifactStagingDirectory)/test-files'
              artifactName: 'test-files'
              publishLocation: 'Container'
          - ${{ if eq(parameters.taskBundleAnalysis, true) }}:
            - output: pipelineArtifact
              displayName: 'Publish Artifacts - bundle-analysis'
              condition: and( succeeded(), ne(variables['Build.Reason'], 'PullRequest'), eq(${{ parameters.taskPublishBundleSizeArtifacts }}, true) )
              targetPath: '${{ parameters.buildDirectory }}/artifacts/bundleAnalysis'
              artifactName: 'bundleAnalysis'
              publishLocation: 'Container'
          - ${{ if ne(parameters.taskBuildDocs, false) }}:
            - output: pipelineArtifact
              displayName: 'Publish Artifact - _api-extractor-temp'
              targetPath: '${{ parameters.buildDirectory }}/_api-extractor-temp'
              artifactName: '_api-extractor-temp'
              publishLocation: 'Container'
        steps:
        # Setup
        - checkout: self
          clean: true
          lfs: ${{ parameters.checkoutSubmodules }}
          submodules: ${{ parameters.checkoutSubmodules }}

        - task: Bash@3
          displayName: Parameters
          inputs:
            targetType: 'inline'
            workingDirectory: ${{ parameters.buildDirectory }}
            script: |
              # Show all task group conditions

              echo "
              Pipeline Variables:
                releaseBuild=$(releaseBuildVar)

              Override Parameters:
                publishOverride=${{ parameters.publishOverride }}
                releaseBuildOverride=${{ parameters.releaseBuildOverride }}

              Tasks Parameters:
                BuildDir=${{ parameters.buildDirectory }}
                Build=${{ parameters.taskBuild }}
                Lint=${{ parameters.taskLint }}
                Test=${{ parameters.taskTest }}
                BuildDoc=${{ parameters.taskBuildDocs }}
                TestCoverage=$(testCoverage)

              Publish Parameters:
                nonScopedPackages=${{ join(', ', parameters.nonScopedPackages) }}

              Computed variables:
                shouldPublish=${{ variables.shouldPublish }}
                componentDetection=${{ variables.componentDetection }}
                publish=${{ variables.publish }}
                canRelease=${{ variables.canRelease }}
                targetBranchName = $(System.PullRequest.TargetBranch)

                release=$(release)"

              # Error checking
              if [[ "$(release)" == "release" ]]; then
                if [[ "${{ variables.canRelease }}" == "False" ]]; then
                  echo "##vso[task.logissue type=error]Invalid branch ${{ variables['Build.SourceBranch'] }} for release"
                  exit -1;
                fi

                if [ -f "lerna.json" ]; then
                  grep -e fluid.*[0-9]-[0-9] `find packages -name 'package.json'`
                else
                  grep -e fluid.*[0-9]-[0-9] `find . -name 'package.json'`
                fi

                if [[ $? == 0 ]]; then
                  echo "##vso[task.logissue type=error]Release shouldn't contain prerelease dependencies"
                  exit -1;
                fi
              fi

              if [[ "$(release)" == "prerelease" ]]; then
                if [[ "${{ parameters.buildNumberInPatch }}" == "true" ]]; then
                  echo "##vso[task.logissue type=error] Prerelease not allow for builds that put build number as the patch version"
                  exit -1;
                fi
              fi

              if [[ "$(release)" != "none" ]] && [[ "$(release)" != "" ]]; then
                if [[ "${{ variables.publish }}" != "True" ]]; then
                  echo "##vso[task.logissue type=error]'$(release)'' is set but package is not published. Either the branch doesn't default to publish or it is skipped."
                  exit -1;
                fi
              fi

        # Install
        - task: UseNode@1
          displayName: Use Node 20.15.1
          inputs:
            version: 20.15.1
        - task: Npm@1
          displayName: Install npm 10
          retryCountOnTaskFailure: 4
          inputs:
            command: 'custom'
            customCommand: 'install --global npm@^10'
            customRegistry: 'useNpmrc'

        # Install pnpm
        - template: /tools/pipelines/templates/include-install.yml@self
          parameters:
            packageManager: '${{ parameters.packageManager }}'
            buildDirectory: '${{ parameters.buildDirectory }}'
            packageManagerInstallCommand: '${{ parameters.packageManagerInstallCommand }}'

        # Set version
        - template: /tools/pipelines/templates/include-set-package-version.yml@self
          parameters:
            buildDirectory: ${{ parameters.buildDirectory }}
            buildNumberInPatch: ${{ parameters.buildNumberInPatch }}
            buildToolsVersionToInstall: ${{ parameters.buildToolsVersionToInstall }}
            tagName: ${{ parameters.tagName }}
            interdependencyRange: '${{ parameters.interdependencyRange }}'

        # Build
        - ${{ if ne(parameters.taskBuild, 'false') }}:
          - task: Npm@1
            displayName: npm run ${{ parameters.taskBuild }}
            inputs:
              command: 'custom'
              workingDir: ${{ parameters.buildDirectory }}
              customCommand: 'run ${{ parameters.taskBuild }}'

        # Lint
        - ${{ if ne(parameters.taskLint, false) }}:
          - task: Npm@1
            displayName: npm run lint
            inputs:
              command: 'custom'
              workingDir: ${{ parameters.buildDirectory }}
              customCommand: 'run lint'
        # Test
        - ${{ if ne(parameters.taskTest, 'false') }}:
          # Run any additional tests first so their results can be copied to the ~/nyc dir and published below
          - ${{ parameters.additionalTests }}

          # Test - No coverage
          - ${{ if ne(variables['testCoverage'], true) }}:
            - task: Npm@1
              displayName: npm run ${{ parameters.taskTest }}
              inputs:
                command: 'custom'
                workingDir: ${{ parameters.buildDirectory }}
                customCommand: 'run ${{ parameters.taskTest }}'

          # Test - With coverage
          - ${{ if eq(variables['testCoverage'], true) }}:
            - task: Npm@1
              displayName: npm run ci:test:coverage
              inputs:
                command: 'custom'
                workingDir: ${{ parameters.buildDirectory }}
                customCommand: 'run ci:test:coverage'
            # Some webpacked file using externals introduce file name with quotes in them
            # and Istanbul's cobertura reporter doesn't escape them causing parse error when we publish
            # A quick fix to patch the file with sed. (See https://github.com/bcoe/c8/issues/302)
            - task: Bash@3
              displayName: 'Check for nyc/report directory'
              inputs:
                targetType: 'inline'
                workingDirectory: ${{ parameters.buildDirectory }}
                script: |
                  test -d nyc/report && echo '##vso[task.setvariable variable=ReportDirExists;]true' || echo 'No
                  nyc/report directory'
              condition: succeededOrFailed()
            - task: Bash@3
              displayName: Patch Coverage Results
              inputs:
                targetType: 'inline'
                workingDirectory: ${{ parameters.buildDirectory }}/nyc/report
                script: |
                  sed -e 's/\(filename=\".*[\\/]external .*\)"\(.*\)""/\1\&quot;\2\&quot;"/' cobertura-coverage.xml > cobertura-coverage-patched.xml
              condition: and(succeededOrFailed(), eq(variables['ReportDirExists'], 'true'))

            - task: PublishCodeCoverageResults@1
              displayName: Publish Code Coverage
              inputs:
                codeCoverageTool: Cobertura
                summaryFileLocation: ${{ parameters.buildDirectory }}/nyc/report/cobertura-coverage-patched.xml
                reportDirectory: ${{ parameters.buildDirectory }}/nyc/report
                failIfCoverageEmpty: true
              condition: and(succeededOrFailed(), eq(variables['ReportDirExists'], 'true'))

          # Test - Upload results
          - task: PublishTestResults@2
            displayName: Publish Test Results
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: '**/*junit-report.xml'
              searchFolder: ${{ parameters.buildDirectory }}/nyc
              mergeTestResults: false
            condition: succeededOrFailed()

        # Pack
        - ${{ if ne(parameters.taskPack, false) }}:
          - task: Bash@3
            displayName: npm pack
            env:
              PACKAGE_MANAGER: '${{ parameters.packageManager }}'
              RELEASE_GROUP: '${{ parameters.tagName }}'
              STAGING_PATH: $(Build.ArtifactStagingDirectory)
            inputs:
              targetType: filePath
              workingDirectory: '${{ parameters.buildDirectory }}'
              filePath: $(Build.SourcesDirectory)/scripts/pack-packages.sh

        # Collect/publish/run bundle analysis
        - ${{ if eq(parameters.taskBundleAnalysis, true) }}:
          - task: Npm@1
            displayName: npm run bundle-analysis:collect
            inputs:
              command: 'custom'
              workingDir: ${{ parameters.buildDirectory }}
              customCommand: 'run bundle-analysis:collect'
          - task: Npm@1
            displayName: run bundle size comparison
            condition: and( succeeded(), eq(variables['Build.Reason'], 'PullRequest'), ne(variables['System.PullRequest.IsFork'], 'true') )
            continueOnError: true
            env:
              ADO_API_TOKEN: $(System.AccessToken)
              DANGER_GITHUB_API_TOKEN: $(githubPublicRepoSecret)
              TARGET_BRANCH_NAME: $(System.PullRequest.TargetBranch)
            inputs:
              command: 'custom'
              workingDir: ${{ parameters.buildDirectory }}
              customCommand: 'run bundle-analysis:run'

        # Docs
        - ${{ if ne(parameters.taskBuildDocs, false) }}:
          - task: Npm@1
            displayName: npm run ci:build:docs
            inputs:
              command: 'custom'
              workingDir: ${{ parameters.buildDirectory }}
              customCommand: 'run ci:build:docs'
        - task: Bash@3
          displayName: Check for extraneous modified files
          inputs:
            targetType: 'inline'
            script: |
              git status | grep -v -E 'package.json|package-lock.json|packageVersion.ts|.npmrc|lerna.json|build-cli/README.md|\(use.*' | grep '^\s' > git_status.log
              if [ `cat git_status.log | wc -l` != "0" ]; then
                cat git_status.log
                echo "##vso[task.logissue type=error]Build should not create extraneous files"
                exit -1;
              fi

    # Publish stage
    - ${{ if eq(variables.publish, true) }}:
      - template: /tools/pipelines/templates/include-publish-npm-package.yml@self
        parameters:
          tagName: ${{ parameters.tagName }}
